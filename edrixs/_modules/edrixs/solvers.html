

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>edrixs.solvers &mdash; edrixs  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/sg_gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/sg_gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/sg_gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/sg_gallery-rendered-html.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> edrixs
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../user/index.html">edrixs User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../auto_examples/index.html">Pedagogical examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">edrixs Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release-history.html">Release History</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">edrixs</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>edrixs.solvers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for edrixs.solvers</h1><div class="highlight"><pre>
<span></span><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ed_1v1c_py&#39;</span><span class="p">,</span> <span class="s1">&#39;xas_1v1c_py&#39;</span><span class="p">,</span> <span class="s1">&#39;rixs_1v1c_py&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ed_1v1c_fort&#39;</span><span class="p">,</span> <span class="s1">&#39;xas_1v1c_fort&#39;</span><span class="p">,</span> <span class="s1">&#39;rixs_1v1c_fort&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ed_2v1c_fort&#39;</span><span class="p">,</span> <span class="s1">&#39;xas_2v1c_fort&#39;</span><span class="p">,</span> <span class="s1">&#39;rixs_2v1c_fort&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ed_siam_fort&#39;</span><span class="p">,</span> <span class="s1">&#39;xas_siam_fort&#39;</span><span class="p">,</span> <span class="s1">&#39;rixs_siam_fort&#39;</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>

<span class="kn">from</span> <span class="nn">.iostream</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">write_tensor</span><span class="p">,</span> <span class="n">write_emat</span><span class="p">,</span> <span class="n">write_umat</span><span class="p">,</span> <span class="n">write_config</span><span class="p">,</span> <span class="n">read_poles_from_file</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.angular_momentum</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_sx</span><span class="p">,</span> <span class="n">get_sy</span><span class="p">,</span> <span class="n">get_sz</span><span class="p">,</span> <span class="n">get_lx</span><span class="p">,</span> <span class="n">get_ly</span><span class="p">,</span> <span class="n">get_lz</span><span class="p">,</span> <span class="n">rmat_to_euler</span><span class="p">,</span> <span class="n">get_wigner_dmat</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.photon_transition</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_trans_oper</span><span class="p">,</span> <span class="n">quadrupole_polvec</span><span class="p">,</span> <span class="n">dipole_polvec_xas</span><span class="p">,</span> <span class="n">dipole_polvec_rixs</span><span class="p">,</span> <span class="n">unit_wavevector</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.coulomb_utensor</span> <span class="kn">import</span> <span class="n">get_umat_slater</span><span class="p">,</span> <span class="n">get_umat_slater_3shells</span>
<span class="kn">from</span> <span class="nn">.manybody_operator</span> <span class="kn">import</span> <span class="n">two_fermion</span><span class="p">,</span> <span class="n">four_fermion</span>
<span class="kn">from</span> <span class="nn">.fock_basis</span> <span class="kn">import</span> <span class="n">get_fock_bin_by_N</span><span class="p">,</span> <span class="n">write_fock_dec_by_N</span>
<span class="kn">from</span> <span class="nn">.basis_transform</span> <span class="kn">import</span> <span class="n">cb_op2</span><span class="p">,</span> <span class="n">tmat_r2c</span><span class="p">,</span> <span class="n">cb_op</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">info_atomic_shell</span><span class="p">,</span> <span class="n">slater_integrals_name</span><span class="p">,</span> <span class="n">boltz_dist</span>
<span class="kn">from</span> <span class="nn">.rixs_utils</span> <span class="kn">import</span> <span class="n">scattering_mat</span>
<span class="kn">from</span> <span class="nn">.plot_spectrum</span> <span class="kn">import</span> <span class="n">get_spectra_from_poles</span><span class="p">,</span> <span class="n">merge_pole_dicts</span>
<span class="kn">from</span> <span class="nn">.soc</span> <span class="kn">import</span> <span class="n">atom_hsoc</span>


<div class="viewcode-block" id="ed_1v1c_py"><a class="viewcode-back" href="../../reference/solvers.html#edrixs.solvers.ed_1v1c_py">[docs]</a><span class="k">def</span> <span class="nf">ed_1v1c_py</span><span class="p">(</span><span class="n">shell_name</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shell_level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v_soc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c_soc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
               <span class="n">v_noccu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">slater</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ext_B</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">on_which</span><span class="o">=</span><span class="s1">&#39;spin&#39;</span><span class="p">,</span>
               <span class="n">v_cfmat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v_othermat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform ED for the case of two atomic shells, one valence plus one Core</span>
<span class="sd">    shell with pure Python solver.</span>
<span class="sd">    For example, for Ni-:math:`L_3` edge RIXS, they are 3d valence and 2p core shells.</span>

<span class="sd">    It will use scipy.linalag.eigh to exactly diagonalize both the initial and intermediate</span>
<span class="sd">    Hamiltonians to get all the eigenvalues and eigenvectors, and the transition operators</span>
<span class="sd">    will be built in the many-body eigenvector basis.</span>

<span class="sd">    This solver is only suitable for small size of Hamiltonian, typically the dimension</span>
<span class="sd">    of both initial and intermediate Hamiltonian are smaller than 10,000.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shell_name: tuple of two strings</span>
<span class="sd">        Names of valence and core shells. The 1st (2nd) string in the tuple is for the</span>
<span class="sd">        valence (core) shell.</span>

<span class="sd">        - The 1st string can only be &#39;s&#39;, &#39;p&#39;, &#39;t2g&#39;, &#39;d&#39;, &#39;f&#39;,</span>

<span class="sd">        - The 2nd string can be &#39;s&#39;, &#39;p&#39;, &#39;p12&#39;, &#39;p32&#39;, &#39;d&#39;, &#39;d32&#39;, &#39;d52&#39;,</span>
<span class="sd">          &#39;f&#39;, &#39;f52&#39;, &#39;f72&#39;.</span>

<span class="sd">        For example: shell_name=(&#39;d&#39;, &#39;p32&#39;) indicates a :math:`L_3` edge transition from</span>
<span class="sd">        core :math:`p_{3/2}` shell to valence :math:`d` shell.</span>
<span class="sd">    shell_level: tuple of two float numbers</span>
<span class="sd">        Energy level of valence (1st element) and core (2nd element) shells.</span>

<span class="sd">        They will be set to zero if not provided.</span>
<span class="sd">    v_soc: tuple of two float numbers</span>
<span class="sd">        Spin-orbit coupling strength of valence electrons, for the initial (1st element)</span>
<span class="sd">        and intermediate (2nd element) Hamiltonians.</span>

<span class="sd">        They will be set to zero if not provided.</span>
<span class="sd">    c_soc: a float number</span>
<span class="sd">        Spin-orbit coupling strength of core electrons.</span>
<span class="sd">    v_noccu: int number</span>
<span class="sd">        Number of electrons in valence shell.</span>
<span class="sd">    slater: tuple of two lists</span>
<span class="sd">        Slater integrals for initial (1st list) and intermediate (2nd list) Hamiltonians.</span>
<span class="sd">        The order of the elements in each list should be like this:</span>

<span class="sd">        [FX_vv, FX_vc, GX_vc, FX_cc],</span>

<span class="sd">        where X are integers with ascending order, it can be X=0, 2, 4, 6 or X=1, 3, 5.</span>
<span class="sd">        One can ignore all the continuous zeros at the end of the list.</span>

<span class="sd">        For example, if the full list is: [F0_dd, F2_dd, F4_dd, 0, F2_dp, 0, 0, 0, 0], one can</span>
<span class="sd">        just provide [F0_dd, F2_dd, F4_dd, 0, F2_dp]</span>

<span class="sd">        All the Slater integrals will be set to zero if slater=None.</span>
<span class="sd">    ext_B: tuple of three float numbers</span>
<span class="sd">        Vector of external magnetic field with respect to global :math:`xyz`-axis.</span>

<span class="sd">        They will be set to zero if not provided.</span>
<span class="sd">    on_which: string</span>
<span class="sd">        Apply Zeeman exchange field on which sector. Options are &#39;spin&#39;, &#39;orbital&#39; or &#39;both&#39;.</span>
<span class="sd">    v_cfmat: 2d complex array</span>
<span class="sd">        Crystal field splitting Hamiltonian of valence electrons. The dimension and the orbital</span>
<span class="sd">        order should be consistent with the type of valence shell.</span>

<span class="sd">        They will be zeros if not provided.</span>
<span class="sd">    v_othermat: 2d complex array</span>
<span class="sd">        Other possible Hamiltonian of valence electrons. The dimension and the orbital order</span>
<span class="sd">        should be consistent with the type of valence shell.</span>

<span class="sd">        They will be zeros if not provided.</span>
<span class="sd">    loc_axis: 3*3 float array</span>
<span class="sd">        The local axis with respect to which local orbitals are defined.</span>

<span class="sd">        - x: local_axis[:,0],</span>

<span class="sd">        - y: local_axis[:,1],</span>

<span class="sd">        - z: local_axis[:,2].</span>

<span class="sd">        It will be an identity matrix if not provided.</span>
<span class="sd">    verbose: int</span>
<span class="sd">        Level of writting data to files. Hopping matrices, Coulomb tensors, eigvenvalues</span>
<span class="sd">        will be written if verbose &gt; 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eval_i:  1d float array</span>
<span class="sd">        The eigenvalues of initial Hamiltonian.</span>
<span class="sd">    eval_n: 1d float array</span>
<span class="sd">        The eigenvalues of intermediate Hamiltonian.</span>
<span class="sd">    trans_op: 3d complex array</span>
<span class="sd">        The matrices of transition operators in the eigenvector basis.</span>
<span class="sd">        Their components are defined with respect to the global :math:`xyz`-axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Running ED ...&quot;</span><span class="p">)</span>
    <span class="n">v_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]</span>
    <span class="n">c_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p12&#39;</span><span class="p">,</span> <span class="s1">&#39;p32&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;d32&#39;</span><span class="p">,</span> <span class="s1">&#39;d52&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;f52&#39;</span><span class="p">,</span> <span class="s1">&#39;f72&#39;</span><span class="p">]</span>
    <span class="n">v_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">c_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">v_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of valence shell: &quot;</span><span class="p">,</span> <span class="n">v_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of core shell: &quot;</span><span class="p">,</span> <span class="n">c_name</span><span class="p">)</span>

    <span class="n">info_shell</span> <span class="o">=</span> <span class="n">info_atomic_shell</span><span class="p">()</span>

    <span class="c1"># Quantum numbers of angular momentum</span>
    <span class="n">v_orbl</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">v_name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># number of orbitals including spin degree of freedom</span>
    <span class="n">v_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">v_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">c_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">c_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># total number of orbitals</span>
    <span class="n">ntot</span> <span class="o">=</span> <span class="n">v_norb</span> <span class="o">+</span> <span class="n">c_norb</span>

    <span class="n">emat_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">emat_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="c1"># Coulomb interaction</span>
    <span class="c1"># Get the names of all the required slater integrals</span>
    <span class="n">slater_name</span> <span class="o">=</span> <span class="n">slater_integrals_name</span><span class="p">((</span><span class="n">v_name</span><span class="p">,</span> <span class="n">c_name</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">))</span>
    <span class="n">nslat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">slater_name</span><span class="p">)</span>

    <span class="n">slater_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nslat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">slater_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nslat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">slater</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nslat</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">slater</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">slater_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">slater</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">slater</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slater_i</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">slater</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">nslat</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nslat</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">slater</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">slater_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">slater</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">slater</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slater_n</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">slater</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">nslat</span><span class="p">]</span>

    <span class="c1"># print summary of slater integrals</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Summary of Slater integrals:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ------------------------------&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Terms,   Initial Hamiltonian,  Intermediate Hamiltonian&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nslat</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    &quot;</span><span class="p">,</span> <span class="n">slater_name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;:  </span><span class="si">{:20.10f}{:20.10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">slater_i</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">slater_n</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="n">case</span> <span class="o">=</span> <span class="n">v_name</span> <span class="o">+</span> <span class="n">c_name</span>
    <span class="n">umat_i</span> <span class="o">=</span> <span class="n">get_umat_slater</span><span class="p">(</span><span class="n">case</span><span class="p">,</span> <span class="o">*</span><span class="n">slater_i</span><span class="p">)</span>
    <span class="n">umat_n</span> <span class="o">=</span> <span class="n">get_umat_slater</span><span class="p">(</span><span class="n">case</span><span class="p">,</span> <span class="o">*</span><span class="n">slater_n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">write_umat</span><span class="p">(</span><span class="n">umat_i</span><span class="p">,</span> <span class="s1">&#39;coulomb_i.in&#39;</span><span class="p">)</span>
        <span class="n">write_umat</span><span class="p">(</span><span class="n">umat_n</span><span class="p">,</span> <span class="s1">&#39;coulomb_n.in&#39;</span><span class="p">)</span>

    <span class="c1"># SOC</span>
    <span class="k">if</span> <span class="n">v_soc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">atom_hsoc</span><span class="p">(</span><span class="n">v_name</span><span class="p">,</span> <span class="n">v_soc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">atom_hsoc</span><span class="p">(</span><span class="n">v_name</span><span class="p">,</span> <span class="n">v_soc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># when the core-shell is any of p12, p32, d32, d52, f52, f72,</span>
    <span class="c1"># do not need to add SOC for core shell</span>
    <span class="k">if</span> <span class="n">c_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]:</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="n">v_norb</span><span class="p">:</span><span class="n">ntot</span><span class="p">,</span> <span class="n">v_norb</span><span class="p">:</span><span class="n">ntot</span><span class="p">]</span> <span class="o">+=</span> <span class="n">atom_hsoc</span><span class="p">(</span><span class="n">c_name</span><span class="p">,</span> <span class="n">c_soc</span><span class="p">)</span>

    <span class="c1"># crystal field</span>
    <span class="k">if</span> <span class="n">v_cfmat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v_cfmat</span><span class="p">)</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v_cfmat</span><span class="p">)</span>

    <span class="c1"># other hopping matrix</span>
    <span class="k">if</span> <span class="n">v_othermat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v_othermat</span><span class="p">)</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v_othermat</span><span class="p">)</span>

    <span class="c1"># energy of shells</span>
    <span class="k">if</span> <span class="n">shell_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">v_norb</span><span class="p">)</span> <span class="o">*</span> <span class="n">shell_level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="n">v_norb</span><span class="p">:</span><span class="n">ntot</span><span class="p">,</span> <span class="n">v_norb</span><span class="p">:</span><span class="n">ntot</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">c_norb</span><span class="p">)</span> <span class="o">*</span> <span class="n">shell_level</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">v_norb</span><span class="p">)</span> <span class="o">*</span> <span class="n">shell_level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="n">v_norb</span><span class="p">:</span><span class="n">ntot</span><span class="p">,</span> <span class="n">v_norb</span><span class="p">:</span><span class="n">ntot</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">c_norb</span><span class="p">)</span> <span class="o">*</span> <span class="n">shell_level</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># external magnetic field</span>
    <span class="k">if</span> <span class="n">v_name</span> <span class="o">==</span> <span class="s1">&#39;t2g&#39;</span><span class="p">:</span>
        <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">lz</span> <span class="o">=</span> <span class="n">get_lx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">get_ly</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">get_lz</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">get_sx</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">get_sy</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">get_sz</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">lz</span> <span class="o">=</span> <span class="o">-</span><span class="n">lx</span><span class="p">,</span> <span class="o">-</span><span class="n">ly</span><span class="p">,</span> <span class="o">-</span><span class="n">lz</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">lz</span> <span class="o">=</span> <span class="n">get_lx</span><span class="p">(</span><span class="n">v_orbl</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">get_ly</span><span class="p">(</span><span class="n">v_orbl</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">get_lz</span><span class="p">(</span><span class="n">v_orbl</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">get_sx</span><span class="p">(</span><span class="n">v_orbl</span><span class="p">),</span> <span class="n">get_sy</span><span class="p">(</span><span class="n">v_orbl</span><span class="p">),</span> <span class="n">get_sz</span><span class="p">(</span><span class="n">v_orbl</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ext_B</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">on_which</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;spin&#39;</span><span class="p">:</span>
            <span class="n">zeeman</span> <span class="o">=</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sx</span><span class="p">)</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sy</span><span class="p">)</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">on_which</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;orbital&#39;</span><span class="p">:</span>
            <span class="n">zeeman</span> <span class="o">=</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">lx</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ly</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">lz</span>
        <span class="k">elif</span> <span class="n">on_which</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">zeeman</span> <span class="o">=</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">lx</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sx</span><span class="p">)</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ly</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sy</span><span class="p">)</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">lz</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown value of on_which&quot;</span><span class="p">,</span> <span class="n">on_which</span><span class="p">)</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">zeeman</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">zeeman</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">write_emat</span><span class="p">(</span><span class="n">emat_i</span><span class="p">,</span> <span class="s1">&#39;hopping_i.in&#39;</span><span class="p">)</span>
        <span class="n">write_emat</span><span class="p">(</span><span class="n">emat_n</span><span class="p">,</span> <span class="s1">&#39;hopping_n.in&#39;</span><span class="p">)</span>

    <span class="n">basis_i</span> <span class="o">=</span> <span class="n">get_fock_bin_by_N</span><span class="p">(</span><span class="n">v_norb</span><span class="p">,</span> <span class="n">v_noccu</span><span class="p">,</span> <span class="n">c_norb</span><span class="p">,</span> <span class="n">c_norb</span><span class="p">)</span>
    <span class="n">basis_n</span> <span class="o">=</span> <span class="n">get_fock_bin_by_N</span><span class="p">(</span><span class="n">v_norb</span><span class="p">,</span> <span class="n">v_noccu</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">c_norb</span><span class="p">,</span> <span class="n">c_norb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ncfg_i</span><span class="p">,</span> <span class="n">ncfg_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis_i</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis_n</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Dimension of the initial Hamiltonian: &quot;</span><span class="p">,</span> <span class="n">ncfg_i</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Dimension of the intermediate Hamiltonian: &quot;</span><span class="p">,</span> <span class="n">ncfg_n</span><span class="p">)</span>

    <span class="c1"># Build many-body Hamiltonian in Fock basis</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Building Many-body Hamiltonians ...&quot;</span><span class="p">)</span>
    <span class="n">hmat_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncfg_i</span><span class="p">,</span> <span class="n">ncfg_i</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">hmat_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncfg_n</span><span class="p">,</span> <span class="n">ncfg_n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">hmat_i</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">two_fermion</span><span class="p">(</span><span class="n">emat_i</span><span class="p">,</span> <span class="n">basis_i</span><span class="p">,</span> <span class="n">basis_i</span><span class="p">)</span>
    <span class="n">hmat_i</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">four_fermion</span><span class="p">(</span><span class="n">umat_i</span><span class="p">,</span> <span class="n">basis_i</span><span class="p">)</span>
    <span class="n">hmat_n</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">two_fermion</span><span class="p">(</span><span class="n">emat_n</span><span class="p">,</span> <span class="n">basis_n</span><span class="p">,</span> <span class="n">basis_n</span><span class="p">)</span>
    <span class="n">hmat_n</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">four_fermion</span><span class="p">(</span><span class="n">umat_n</span><span class="p">,</span> <span class="n">basis_n</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Done !&quot;</span><span class="p">)</span>

    <span class="c1"># Do exact-diagonalization to get eigenvalues and eigenvectors</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Exact Diagonalization of Hamiltonians ...&quot;</span><span class="p">)</span>
    <span class="n">eval_i</span><span class="p">,</span> <span class="n">evec_i</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">hmat_i</span><span class="p">)</span>
    <span class="n">eval_n</span><span class="p">,</span> <span class="n">evec_n</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">hmat_n</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Done !&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">write_tensor</span><span class="p">(</span><span class="n">eval_i</span><span class="p">,</span> <span class="s1">&#39;eval_i.dat&#39;</span><span class="p">)</span>
        <span class="n">write_tensor</span><span class="p">(</span><span class="n">eval_n</span><span class="p">,</span> <span class="s1">&#39;eval_n.dat&#39;</span><span class="p">)</span>

    <span class="c1"># Build dipolar transition operators in local-xyz axis</span>
    <span class="k">if</span> <span class="n">loc_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">local_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loc_axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">local_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">get_trans_oper</span><span class="p">(</span><span class="n">case</span><span class="p">)</span>
    <span class="n">npol</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">tmp_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npol</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="c1"># Transform the transition operators to global-xyz axis</span>
    <span class="c1"># dipolar transition</span>
    <span class="k">if</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">tmp_g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">local_axis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

    <span class="c1"># quadrupolar transition</span>
    <span class="k">elif</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">rmat_to_euler</span><span class="p">(</span><span class="n">local_axis</span><span class="p">)</span>
        <span class="n">wignerD</span> <span class="o">=</span> <span class="n">get_wigner_dmat</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
        <span class="n">rotmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmat_r2c</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">wignerD</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tmat_r2c</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">))))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                <span class="n">tmp_g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rotmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Have NOT implemented this case: &quot;</span><span class="p">,</span> <span class="n">npol</span><span class="p">)</span>

    <span class="n">tmp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npol</span><span class="p">,</span> <span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">trans_op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npol</span><span class="p">,</span> <span class="n">ncfg_n</span><span class="p">,</span> <span class="n">ncfg_i</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">):</span>
        <span class="n">tmp2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="n">v_norb</span><span class="p">:</span><span class="n">ntot</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">trans_op</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">two_fermion</span><span class="p">(</span><span class="n">tmp2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">basis_n</span><span class="p">,</span> <span class="n">basis_i</span><span class="p">)</span>
        <span class="n">trans_op</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cb_op2</span><span class="p">(</span><span class="n">trans_op</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">evec_n</span><span class="p">,</span> <span class="n">evec_i</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; ED Done !&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">eval_i</span><span class="p">,</span> <span class="n">eval_n</span><span class="p">,</span> <span class="n">trans_op</span></div>


<div class="viewcode-block" id="xas_1v1c_py"><a class="viewcode-back" href="../../reference/solvers.html#edrixs.solvers.xas_1v1c_py">[docs]</a><span class="k">def</span> <span class="nf">xas_1v1c_py</span><span class="p">(</span><span class="n">eval_i</span><span class="p">,</span> <span class="n">eval_n</span><span class="p">,</span> <span class="n">trans_op</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">gamma_c</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">pol_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gs_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate XAS for the case of one valence shell plus one core shell with Python solver.</span>

<span class="sd">    This solver is only suitable for small size of Hamiltonian, typically the dimension</span>
<span class="sd">    of both initial and intermediate Hamiltonian are smaller than 10,000.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    eval_i: 1d float array</span>
<span class="sd">        The eigenvalues of the initial Hamiltonian.</span>
<span class="sd">    eval_n: 1d float array</span>
<span class="sd">        The eigenvalues of the intermediate Hamiltonian.</span>
<span class="sd">    trans_op: 3d complex array</span>
<span class="sd">        The transition operators in the eigenstates basis.</span>
<span class="sd">    ominc: 1d float array</span>
<span class="sd">        Incident energy of photon.</span>
<span class="sd">    gamma_c: a float number or a 1d float array with the same shape as ominc.</span>
<span class="sd">        The core-hole life-time broadening factor. It can be a constant value</span>
<span class="sd">        or incident energy dependent.</span>
<span class="sd">    thin: float number</span>
<span class="sd">        The incident angle of photon (in radian).</span>
<span class="sd">    phi: float number</span>
<span class="sd">        Azimuthal angle (in radian), defined with respect to the</span>
<span class="sd">        :math:`x`-axis of the scattering axis: scatter_axis[:,0].</span>
<span class="sd">    pol_type: list of tuples</span>
<span class="sd">        Type of polarization, options can be:</span>

<span class="sd">        - (&#39;linear&#39;, alpha), linear polarization, where alpha is the angle between the</span>
<span class="sd">          polarization vector and the scattering plane in radians.</span>

<span class="sd">        - (&#39;left&#39;, 0), left circular polarization.</span>

<span class="sd">        - (&#39;right&#39;, 0), right circular polarization.</span>

<span class="sd">        - (&#39;isotropic&#39;, 0). isotropic polarization.</span>

<span class="sd">        It will set pol_type=[(&#39;isotropic&#39;, 0)] if not provided.</span>
<span class="sd">    gs_list: 1d list of ints</span>
<span class="sd">        The indices of initial states which will be used in XAS calculations.</span>

<span class="sd">        It will set gs_list=[0] if not provided.</span>
<span class="sd">    temperature: float number</span>
<span class="sd">        Temperature (in K) for boltzmann distribution.</span>
<span class="sd">    scatter_axis: 3*3 float array</span>
<span class="sd">        The local axis defining the scattering plane. The scattering plane is defined in</span>
<span class="sd">        the local :math:`zx`-plane.</span>

<span class="sd">        local :math:`x`-axis: scatter_axis[:,0]</span>

<span class="sd">        local :math:`y`-axis: scatter_axis[:,1]</span>

<span class="sd">        local :math:`z`-axis: scatter_axis[:,2]</span>

<span class="sd">        It will be set to an identity matrix if not provided.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xas: 2d float array</span>
<span class="sd">        The calculated XAS spectra. The 1st dimension is for the incident energy, and the</span>
<span class="sd">        2nd dimension is for different polarizations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Running XAS ...&quot;</span><span class="p">)</span>
    <span class="n">n_om</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ominc</span><span class="p">)</span>
    <span class="n">npol</span><span class="p">,</span> <span class="n">ncfg_n</span> <span class="o">=</span> <span class="n">trans_op</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">trans_op</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">pol_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pol_type</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;isotropic&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">gs_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gs_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">scatter_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scatter_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scatter_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scatter_axis</span><span class="p">)</span>

    <span class="n">xas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_om</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pol_type</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">gamma_core</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_om</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">prob</span> <span class="o">=</span> <span class="n">boltz_dist</span><span class="p">([</span><span class="n">eval_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gs_list</span><span class="p">],</span> <span class="n">temperature</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">gamma_c</span><span class="p">):</span>
        <span class="n">gamma_core</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_om</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma_c</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gamma_core</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gamma_c</span>

    <span class="n">kvec</span> <span class="o">=</span> <span class="n">unit_wavevector</span><span class="p">(</span><span class="n">thin</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">om</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ominc</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">it</span><span class="p">,</span> <span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pol_type</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;isotropic&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown polarization type: &quot;</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span>
            <span class="n">polvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span> <span class="ow">or</span> <span class="n">pt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span> <span class="ow">or</span> <span class="n">pt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
                <span class="n">pol</span> <span class="o">=</span> <span class="n">dipole_polvec_xas</span><span class="p">(</span><span class="n">thin</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># dipolar transition</span>
                    <span class="n">polvec</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">pol</span>
                <span class="k">if</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>  <span class="c1"># quadrupolar transition</span>
                    <span class="n">polvec</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">quadrupole_polvec</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">kvec</span><span class="p">)</span>

            <span class="c1"># loop over all the initial states</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">igs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gs_list</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">pt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;isotropic&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">):</span>
                        <span class="n">xas</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">it</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="n">prob</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">trans_op</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:,</span> <span class="n">igs</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gamma_core</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span>
                                             <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">((</span><span class="n">om</span> <span class="o">-</span> <span class="p">(</span><span class="n">eval_n</span><span class="p">[:]</span> <span class="o">-</span> <span class="n">eval_i</span><span class="p">[</span><span class="n">igs</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                             <span class="n">gamma_core</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                        <span class="p">)</span> <span class="o">/</span> <span class="n">npol</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">F_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ncfg_n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">):</span>
                        <span class="n">F_mag</span> <span class="o">+=</span> <span class="n">trans_op</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:,</span> <span class="n">igs</span><span class="p">]</span> <span class="o">*</span> <span class="n">polvec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">xas</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">it</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">prob</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">F_mag</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gamma_core</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span>
                                         <span class="p">((</span><span class="n">om</span> <span class="o">-</span> <span class="p">(</span><span class="n">eval_n</span><span class="p">[:]</span> <span class="o">-</span> <span class="n">eval_i</span><span class="p">[</span><span class="n">igs</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gamma_core</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                    <span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; XAS Done !&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xas</span></div>


<div class="viewcode-block" id="rixs_1v1c_py"><a class="viewcode-back" href="../../reference/solvers.html#edrixs.solvers.rixs_1v1c_py">[docs]</a><span class="k">def</span> <span class="nf">rixs_1v1c_py</span><span class="p">(</span><span class="n">eval_i</span><span class="p">,</span> <span class="n">eval_n</span><span class="p">,</span> <span class="n">trans_op</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="n">eloss</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                 <span class="n">gamma_c</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">gamma_f</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">thout</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">pol_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gs_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate RIXS for the case of one valence shell plus one core shell with Python solver.</span>

<span class="sd">    This solver is only suitable for small size of Hamiltonian, typically the dimension</span>
<span class="sd">    of both initial and intermediate Hamiltonian are smaller than 10,000.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    eval_i: 1d float array</span>
<span class="sd">        The eigenvalues of the initial Hamiltonian.</span>
<span class="sd">    eval_n: 1d float array</span>
<span class="sd">        The eigenvalues of the intermediate Hamiltonian.</span>
<span class="sd">    trans_op: 3d complex array</span>
<span class="sd">        The transition operators in the eigenstates basis.</span>
<span class="sd">    ominc: 1d float array</span>
<span class="sd">        Incident energy of photon.</span>
<span class="sd">    eloss: 1d float array</span>
<span class="sd">        Energy loss.</span>
<span class="sd">    gamma_c: a float number or a 1d float array with same shape as ominc.</span>
<span class="sd">        The core-hole life-time broadening factor. It can be a constant value</span>
<span class="sd">        or incident energy dependent.</span>
<span class="sd">    gamma_f: a float number or a 1d float array with same shape as eloss.</span>
<span class="sd">        The final states life-time broadening factor. It can be a constant value</span>
<span class="sd">        or energy loss dependent.</span>
<span class="sd">    thin: float number</span>
<span class="sd">        The incident angle of photon (in radian).</span>
<span class="sd">    thout: float number</span>
<span class="sd">        The scattered angle of photon (in radian).</span>
<span class="sd">    phi: float number</span>
<span class="sd">        Azimuthal angle (in radian), defined with respect to the</span>
<span class="sd">        :math:`x`-axis of scattering axis: scatter_axis[:,0].</span>
<span class="sd">    pol_type: list of 4-elements-tuples</span>
<span class="sd">        Type of polarizations. It has the following form:</span>

<span class="sd">        (str1, alpha, str2, beta)</span>

<span class="sd">        where, str1 (str2) can be &#39;linear&#39;, &#39;left&#39;, &#39;right&#39;, and alpha (beta) is</span>
<span class="sd">        the angle (in radians) between the linear polarization vector and the scattering plane.</span>

<span class="sd">        It will set pol_type=[(&#39;linear&#39;, 0, &#39;linear&#39;, 0)] if not provided.</span>
<span class="sd">    gs_list: 1d list of ints</span>
<span class="sd">        The indices of initial states which will be used in RIXS calculations.</span>

<span class="sd">        It will set gs_list=[0] if not provided.</span>
<span class="sd">    temperature: float number</span>
<span class="sd">        Temperature (in K) for boltzmann distribution.</span>
<span class="sd">    scatter_axis: 3*3 float array</span>
<span class="sd">        The local axis defining the scattering plane. The scattering plane is defined in</span>
<span class="sd">        the local :math:`zx`-plane.</span>

<span class="sd">        - local :math:`x`-axis: scatter_axis[:,0]</span>

<span class="sd">        - local :math:`y`-axis: scatter_axis[:,1]</span>

<span class="sd">        - local :math:`z`-axis: scatter_axis[:,2]</span>

<span class="sd">        It will be an identity matrix if not provided.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rixs: 3d float array</span>
<span class="sd">        The calculated RIXS spectra. The 1st dimension is for the incident energy,</span>
<span class="sd">        the 2nd dimension is for the energy loss and the 3rd dimension is for</span>
<span class="sd">        different polarizations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Running RIXS ... &quot;</span><span class="p">)</span>
    <span class="n">n_ominc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ominc</span><span class="p">)</span>
    <span class="n">n_eloss</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eloss</span><span class="p">)</span>
    <span class="n">gamma_core</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_ominc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">gamma_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_eloss</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">gamma_c</span><span class="p">):</span>
        <span class="n">gamma_core</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_ominc</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma_c</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gamma_core</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gamma_c</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">gamma_f</span><span class="p">):</span>
        <span class="n">gamma_final</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_eloss</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma_f</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gamma_final</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gamma_f</span>

    <span class="k">if</span> <span class="n">pol_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pol_type</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">gs_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gs_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">scatter_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scatter_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scatter_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scatter_axis</span><span class="p">)</span>

    <span class="n">prob</span> <span class="o">=</span> <span class="n">boltz_dist</span><span class="p">([</span><span class="n">eval_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gs_list</span><span class="p">],</span> <span class="n">temperature</span><span class="p">)</span>
    <span class="n">rixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ominc</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">eloss</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">pol_type</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">npol</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">trans_op</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">trans_emi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npol</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">):</span>
        <span class="n">trans_emi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">trans_op</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="n">polvec_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">polvec_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="c1"># Calculate RIXS</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">om</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ominc</span><span class="p">):</span>
        <span class="n">F_fi</span> <span class="o">=</span> <span class="n">scattering_mat</span><span class="p">(</span><span class="n">eval_i</span><span class="p">,</span> <span class="n">eval_n</span><span class="p">,</span> <span class="n">trans_op</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="nb">max</span><span class="p">(</span><span class="n">gs_list</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                              <span class="n">trans_emi</span><span class="p">,</span> <span class="n">om</span><span class="p">,</span> <span class="n">gamma_core</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">jt</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pol_type</span><span class="p">):</span>
            <span class="n">ei</span><span class="p">,</span> <span class="n">ef</span> <span class="o">=</span> <span class="n">dipole_polvec_rixs</span><span class="p">(</span><span class="n">thin</span><span class="p">,</span> <span class="n">thout</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span>
                                        <span class="n">scatter_axis</span><span class="p">,</span> <span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">jt</span><span class="p">))</span>
            <span class="c1"># dipolar transition</span>
            <span class="k">if</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">polvec_i</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ei</span>
                <span class="n">polvec_f</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ef</span>
            <span class="c1"># quadrupolar transition</span>
            <span class="k">elif</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">ki</span> <span class="o">=</span> <span class="n">unit_wavevector</span><span class="p">(</span><span class="n">thin</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;in&#39;</span><span class="p">)</span>
                <span class="n">kf</span> <span class="o">=</span> <span class="n">unit_wavevector</span><span class="p">(</span><span class="n">thout</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)</span>
                <span class="n">polvec_i</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">quadrupole_polvec</span><span class="p">(</span><span class="n">ei</span><span class="p">,</span> <span class="n">ki</span><span class="p">)</span>
                <span class="n">polvec_f</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">quadrupole_polvec</span><span class="p">(</span><span class="n">ef</span><span class="p">,</span> <span class="n">kf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Have NOT implemented this type of transition operators&quot;</span><span class="p">)</span>
            <span class="c1"># scattering magnitude with polarization vectors</span>
            <span class="n">F_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">eval_i</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">gs_list</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">):</span>
                    <span class="n">F_mag</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">polvec_f</span><span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="o">*</span> <span class="n">F_fi</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">polvec_i</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">igs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gs_list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">eval_i</span><span class="p">)):</span>
                    <span class="n">rixs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">prob</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">F_mag</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">igs</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gamma_final</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span>
                        <span class="p">((</span><span class="n">eloss</span> <span class="o">-</span> <span class="p">(</span><span class="n">eval_i</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">eval_i</span><span class="p">[</span><span class="n">igs</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gamma_final</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; RIXS Done !&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rixs</span></div>


<div class="viewcode-block" id="ed_1v1c_fort"><a class="viewcode-back" href="../../reference/solvers.html#edrixs.solvers.ed_1v1c_fort">[docs]</a><span class="k">def</span> <span class="nf">ed_1v1c_fort</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">shell_name</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shell_level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">v_soc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c_soc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">v_noccu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">slater</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">ext_B</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">on_which</span><span class="o">=</span><span class="s1">&#39;spin&#39;</span><span class="p">,</span>
                 <span class="n">v_cfmat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v_othermat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">do_ed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ed_solver</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nvector</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">idump</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">eigval_tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">min_ndim</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform ED for the case of one valence shell plus one Core-shell with Fortran ED solver.</span>

<span class="sd">    The hopping and Coulomb terms of both the initial and intermediate Hamiltonians will be</span>
<span class="sd">    constructed and written to files (hopping_i.in, hopping_n.in, coulomb_i.in and coulomb_n.in).</span>
<span class="sd">    Fock basis for the initial Hamiltonian will be written to file (fock_i.in).</span>

<span class="sd">    ED will be only performed on the initial Hamiltonian to find a few lowest eigenstates</span>
<span class="sd">    do_ed=True. Only input files will be written if do_ed=False.</span>
<span class="sd">    Due to large Hilbert space, the ed_fsolver written in Fortran will be called.</span>
<span class="sd">    mpi4py and a MPI environment (mpich or openmpi) are required to launch ed_fsolver.</span>

<span class="sd">    If do_ed=True, it will output the eigenvalues in file (eigvals.dat) and eigenvectors in files</span>
<span class="sd">    (eigvec.n), where n means the n-th eigenvectors. The eigvec.n files will be used later</span>
<span class="sd">    as the inputs for XAS and RIXS calculations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    comm: MPI_comm</span>
<span class="sd">        The MPI communicator from mpi4py.</span>
<span class="sd">    shell_name: tuple of two strings</span>
<span class="sd">        Names of valence and core shells. The 1st (2nd) string in the tuple is for the</span>
<span class="sd">        valence (core) shell.</span>

<span class="sd">        - The 1st strings can only be &#39;s&#39;, &#39;p&#39;, &#39;t2g&#39;, &#39;d&#39;, &#39;f&#39;</span>

<span class="sd">        - The 2nd string can be &#39;s&#39;, &#39;p&#39;, &#39;p12&#39;, &#39;p32&#39;, &#39;d&#39;, &#39;d32&#39;, &#39;d52&#39;,</span>
<span class="sd">          &#39;f&#39;, &#39;f52&#39;, &#39;f72&#39;.</span>

<span class="sd">        For example: shell_name=(&#39;d&#39;, &#39;p32&#39;) may indicate a :math:`L_3` edge transition from</span>
<span class="sd">        core :math:`2p_{3/2}` shell to valence :math:`3d` shell for Ni.</span>
<span class="sd">    shell_level: tuple of two float numbers</span>
<span class="sd">        Energy level of valence (1st element) and core (2nd element) shells.</span>

<span class="sd">        They will be set to zero if not provided.</span>
<span class="sd">    v_soc: tuple of two float numbers</span>
<span class="sd">        Spin-orbit coupling strength of the valence shell,</span>
<span class="sd">        v1_soc[0] for the initial Hamiltonian, and</span>
<span class="sd">        v1_soc[1] for the intermediate Hamiltonian.</span>

<span class="sd">        They will be set to zero if not provided.</span>
<span class="sd">    c_soc: float number</span>
<span class="sd">        Spin-orbit coupling strength of core electrons.</span>
<span class="sd">    v_noccu: int number</span>
<span class="sd">        Total number of electrons in valence shells.</span>
<span class="sd">    slater: tuple of two lists</span>
<span class="sd">        Slater integrals for initial (1st list) and intermediate (2nd list) Hamiltonians.</span>
<span class="sd">        The order of the elements in each list should be like this:</span>

<span class="sd">        [FX_vv, FX_vc, GX_vc, FX_cc],</span>

<span class="sd">        where X are integers with ascending order, it can be X=0, 2, 4, 6 or X=1, 3, 5.</span>
<span class="sd">        One can ignore all the continuous zeros at the end of the list.</span>

<span class="sd">        For example, if the full list is: [F0_dd, F2_dd, F4_dd, 0, F2_dp, 0, 0, 0, 0], one can</span>
<span class="sd">        just provide [F0_dd, F2_dd, F4_dd, 0, F2_dp]</span>

<span class="sd">        All the Slater integrals will be set to zero if slater==None.</span>
<span class="sd">    ext_B: tuple of three float numbers</span>
<span class="sd">        Vector of external magnetic field with respect to global :math:`xyz`-axis applied</span>
<span class="sd">        on the valence shell.</span>

<span class="sd">        It will be set to zeros if not provided.</span>
<span class="sd">    on_which: string</span>
<span class="sd">        Apply Zeeman exchange field on which sector. Options are &#39;spin&#39;, &#39;orbital&#39; or &#39;both&#39;.</span>
<span class="sd">    v_cfmat: 2d complex array</span>
<span class="sd">        Crystal field splitting Hamiltonian of the valence shell. The dimension and the orbital</span>
<span class="sd">        order should be consistent with the type of the valence shell.</span>

<span class="sd">        They will be zeros if not provided.</span>
<span class="sd">    v_othermat: 2d complex array</span>
<span class="sd">        Other possible Hamiltonian of the valence shell. The dimension and the orbital order</span>
<span class="sd">        should be consistent with the type of the valence shell.</span>

<span class="sd">        They will be zeros if not provided.</span>
<span class="sd">    do_ed: logical</span>
<span class="sd">        If do_end=True, diagonalize the Hamitlonian to find a few lowest eigenstates, return the</span>
<span class="sd">        eigenvalues and density matirx, and write the eigenvectors in files eigvec.n, otherwise,</span>
<span class="sd">        just write out the input files, do not perform the ED.</span>
<span class="sd">    ed_solver: int</span>
<span class="sd">        Type of ED solver, options can be 0, 1, 2</span>

<span class="sd">        - 0: use Lapack to fully diagonalize Hamiltonian to get all the eigenvalues.</span>

<span class="sd">        - 1: use standard Lanczos algorithm to find only a few lowest eigenvalues,</span>
<span class="sd">          no re-orthogonalization has been applied, so it is not very accurate.</span>

<span class="sd">        - 2: use parallel version of Arpack library to find a few lowest eigenvalues,</span>
<span class="sd">          it is accurate and is the recommeded choice in real calculations of XAS and RIXS.</span>
<span class="sd">    neval: int</span>
<span class="sd">        Number of eigenvalues to be found. For ed_solver=2, the value should not be too small,</span>
<span class="sd">        neval &gt; 10 is usually a safe value.</span>
<span class="sd">    nvector: int</span>
<span class="sd">        Number of eigenvectors to be found and written into files.</span>
<span class="sd">    ncv: int</span>
<span class="sd">        Used for ed_solver=2, it should be at least ncv &gt; neval + 2. Usually, set it a little</span>
<span class="sd">        bit larger than neval, for example, set ncv=200 when neval=100.</span>
<span class="sd">    idump: logical</span>
<span class="sd">        Whether to dump the eigenvectors to files &quot;eigvec.n&quot;, where n means the n-th vectors.</span>
<span class="sd">    maxiter: int</span>
<span class="sd">        Maximum number of iterations in finding all the eigenvalues, used for ed_solver=1, 2.</span>
<span class="sd">    eigval_tol: float</span>
<span class="sd">        The convergence criteria of eigenvalues, used for ed_solver=1, 2.</span>
<span class="sd">    min_ndim: int</span>
<span class="sd">        The minimum dimension of the Hamiltonian when the ed_solver=1, 2 can be used, otherwise,</span>
<span class="sd">        ed_solver=1 will be used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eval_i: 1d float array, shape=(neval, )</span>
<span class="sd">        The eigenvalues of initial Hamiltonian.</span>
<span class="sd">    denmat: 2d complex array, shape=(nvector, v_norb, v_norb))</span>
<span class="sd">        The density matrix in the eigenstates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]</span>
    <span class="n">c_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p12&#39;</span><span class="p">,</span> <span class="s1">&#39;p32&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;d32&#39;</span><span class="p">,</span> <span class="s1">&#39;d52&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;f52&#39;</span><span class="p">,</span> <span class="s1">&#39;f72&#39;</span><span class="p">]</span>
    <span class="n">v_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">c_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">v_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of valence shell: &quot;</span><span class="p">,</span> <span class="n">v_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of core shell: &quot;</span><span class="p">,</span> <span class="n">c_name</span><span class="p">)</span>

    <span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_name</span><span class="p">,</span> <span class="s1">&#39;empty&#39;</span><span class="p">,</span> <span class="n">c_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shell_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="p">(</span><span class="n">shell_level</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shell_level</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">eval_i</span><span class="p">,</span> <span class="n">denmat</span> <span class="o">=</span> <span class="n">_ed_1or2_valence_1core</span><span class="p">(</span>
        <span class="n">comm</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">shell_level</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">v1_soc</span><span class="o">=</span><span class="n">v_soc</span><span class="p">,</span> <span class="n">c_soc</span><span class="o">=</span><span class="n">c_soc</span><span class="p">,</span>
        <span class="n">v_tot_noccu</span><span class="o">=</span><span class="n">v_noccu</span><span class="p">,</span> <span class="n">slater</span><span class="o">=</span><span class="n">slater</span><span class="p">,</span> <span class="n">v1_ext_B</span><span class="o">=</span><span class="n">ext_B</span><span class="p">,</span>
        <span class="n">v1_on_which</span><span class="o">=</span><span class="n">on_which</span><span class="p">,</span> <span class="n">v1_cfmat</span><span class="o">=</span><span class="n">v_cfmat</span><span class="p">,</span> <span class="n">v1_othermat</span><span class="o">=</span><span class="n">v_othermat</span><span class="p">,</span>
        <span class="n">do_ed</span><span class="o">=</span><span class="n">do_ed</span><span class="p">,</span> <span class="n">ed_solver</span><span class="o">=</span><span class="n">ed_solver</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="n">neval</span><span class="p">,</span> <span class="n">nvector</span><span class="o">=</span><span class="n">nvector</span><span class="p">,</span>
        <span class="n">ncv</span><span class="o">=</span><span class="n">ncv</span><span class="p">,</span> <span class="n">idump</span><span class="o">=</span><span class="n">idump</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">eigval_tol</span><span class="o">=</span><span class="n">eigval_tol</span><span class="p">,</span>
        <span class="n">min_ndim</span><span class="o">=</span><span class="n">min_ndim</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">eval_i</span><span class="p">,</span> <span class="n">denmat</span></div>


<div class="viewcode-block" id="ed_2v1c_fort"><a class="viewcode-back" href="../../reference/solvers.html#edrixs.solvers.ed_2v1c_fort">[docs]</a><span class="k">def</span> <span class="nf">ed_2v1c_fort</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">shell_name</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shell_level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">v1_soc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v2_soc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c_soc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">v_tot_noccu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">slater</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">v1_ext_B</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v2_ext_B</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v1_on_which</span><span class="o">=</span><span class="s1">&#39;spin&#39;</span><span class="p">,</span> <span class="n">v2_on_which</span><span class="o">=</span><span class="s1">&#39;spin&#39;</span><span class="p">,</span>
                 <span class="n">v1_cfmat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v2_cfmat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v1_othermat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v2_othermat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">hopping_v1v2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">do_ed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ed_solver</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nvector</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">idump</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">eigval_tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">min_ndim</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform ED for the case of two valence shell plus one core-shell with Fortran solver.</span>
<span class="sd">    For example, for Ni :math:`K`-edge RIXS, :math:`1s\\rightarrow 4p` transition,</span>
<span class="sd">    the valence shells involved in RIXS are :math:`3d` and :math:`4p`.</span>

<span class="sd">    The hopping and Coulomb terms of both the initial and intermediate Hamiltonians will be</span>
<span class="sd">    constructed and written to files (hopping_i.in, hopping_n.in, coulomb_i.in and coulomb_n.in).</span>
<span class="sd">    Fock basis for the initial Hamiltonian will be written to file (fock_i.in).</span>

<span class="sd">    ED will be only performed on the initial Hamiltonian to find a few lowest eigenstates</span>
<span class="sd">    do_ed=True. Only input files will be written if do_ed=False.</span>
<span class="sd">    Due to large Hilbert space, the ed_fsolver written in Fortran will be called.</span>
<span class="sd">    mpi4py and a MPI environment (mpich or openmpi) are required to launch ed_fsolver.</span>

<span class="sd">    If do_ed=True, it will output the eigenvalues in file (eigvals.dat) and eigenvectors in files</span>
<span class="sd">    (eigvec.n), where n means the n-th eigenvectors. The eigvec.n files will be used later</span>
<span class="sd">    as the inputs for XAS and RIXS calculations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    comm: MPI_comm</span>
<span class="sd">        The MPI communicator from mpi4py.</span>
<span class="sd">    shell_name: tuple of three strings</span>
<span class="sd">        Names of valence and core shells. The 1st (2nd) string in the tuple is for the</span>
<span class="sd">        1st (2nd) valence shell, and the 3rd one is for the core shell.</span>

<span class="sd">        - The 1st and 2nd strings can only be &#39;s&#39;, &#39;p&#39;, &#39;t2g&#39;, &#39;d&#39;, &#39;f&#39;</span>

<span class="sd">        - The 3nd string can be &#39;s&#39;, &#39;p&#39;, &#39;p12&#39;, &#39;p32&#39;, &#39;d&#39;, &#39;d32&#39;, &#39;d52&#39;,</span>
<span class="sd">          &#39;f&#39;, &#39;f52&#39;, &#39;f72&#39;.</span>

<span class="sd">        For example: shell_name=(&#39;d&#39;, &#39;p&#39;, &#39;s&#39;) may indicate a :math:`K` edge transition from</span>
<span class="sd">        core :math:`1s` shell to valence :math:`3d` and :math:`4p` shell for Ni.</span>
<span class="sd">    shell_level: tuple of three float numbers</span>
<span class="sd">        Energy level of valence (1st and 2nd elements) and core (3nd element) shells.</span>

<span class="sd">        They will be set to zero if not provided.</span>
<span class="sd">    v1_soc: tuple of two float numbers</span>
<span class="sd">        Spin-orbit coupling strength of the 1st valence shell,</span>
<span class="sd">        v1_soc[0] for the initial Hamiltonian, and</span>
<span class="sd">        v1_soc[1] for the intermediate Hamiltonian.</span>

<span class="sd">        They will be set to zero if not provided.</span>
<span class="sd">    v2_soc: tuple of two float numbers</span>
<span class="sd">        Spin-orbit coupling strength of the 2nd valence shell,</span>
<span class="sd">        v2_soc[0] for the initial Hamiltonian, and</span>
<span class="sd">        v2_soc[1] for the intermediate Hamiltonian.</span>

<span class="sd">        They will be set to zero if not provided.</span>
<span class="sd">    c_soc: float number</span>
<span class="sd">        Spin-orbit coupling strength of core electrons.</span>
<span class="sd">    v_tot_noccu: int number</span>
<span class="sd">        Total number of electrons in valence shells.</span>
<span class="sd">    slater: tuple of two lists</span>
<span class="sd">        Slater integrals for initial (1st list) and intermediate (2nd list) Hamiltonians.</span>
<span class="sd">        The order of the elements in each list should be like this:</span>

<span class="sd">        [FX_v1v1, FX_v1v2, GX_v1v2, FX_v2v2, FX_v1c, GX_v1c, FX_v2c, GX_v2c],</span>

<span class="sd">        where X are integers with ascending order, it can be X=0, 2, 4, 6 or X=1, 3, 5.</span>
<span class="sd">        One can ignore all the continuous zeros at the end of the list.</span>

<span class="sd">        For example, if the full list is: [F0_dd, F2_dd, F4_dd, 0, F2_dp, 0, 0, 0, 0], one can</span>
<span class="sd">        just provide [F0_dd, F2_dd, F4_dd, 0, F2_dp]</span>

<span class="sd">        All the Slater integrals will be set to zero if slater==None.</span>
<span class="sd">    v1_ext_B: tuple of three float numbers</span>
<span class="sd">        Vector of external magnetic field with respect to global :math:`xyz`-axis applied</span>
<span class="sd">        on the 1st valence shell.</span>

<span class="sd">        It will be set to zeros if not provided.</span>
<span class="sd">    v2_ext_B: tuple of three float numbers</span>
<span class="sd">        Vector of external magnetic field with respect to global :math:`xyz`-axis applied</span>
<span class="sd">        on the 2nd valence shell.</span>

<span class="sd">        It will be set to zeros if not provided.</span>
<span class="sd">    v1_on_which: string</span>
<span class="sd">        Apply Zeeman exchange field on which sector. Options are &#39;spin&#39;, &#39;orbital&#39; or &#39;both&#39;.</span>
<span class="sd">        For the 1st valence shell.</span>
<span class="sd">    v2_on_which: string</span>
<span class="sd">        Apply Zeeman exchange field on which sector. Options are &#39;spin&#39;, &#39;orbital&#39; or &#39;both&#39;.</span>
<span class="sd">        For the 2nd valence shell.</span>
<span class="sd">    v1_cfmat: 2d complex array</span>
<span class="sd">        Crystal field splitting Hamiltonian of the 1st valence shell. The dimension and the orbital</span>
<span class="sd">        order should be consistent with the type of the 1st valence shell.</span>

<span class="sd">        They will be zeros if not provided.</span>
<span class="sd">    v2_cfmat: 2d complex array</span>
<span class="sd">        Crystal field splitting Hamiltonian of the 2nd valence shell. The dimension and the orbital</span>
<span class="sd">        order should be consistent with the type of the 2nd valence shell.</span>

<span class="sd">        They will be zeros if not provided.</span>
<span class="sd">    v1_othermat: 2d complex array</span>
<span class="sd">        Other possible Hamiltonian of the 1st valence shell. The dimension and the orbital order</span>
<span class="sd">        should be consistent with the type of the 1st valence shell.</span>

<span class="sd">        They will be zeros if not provided.</span>
<span class="sd">    v2_othermat: 2d complex array</span>
<span class="sd">        Other possible Hamiltonian of the 2nd valence shell. The dimension and the orbital order</span>
<span class="sd">        should be consistent with the type of the 2nd valence shell.</span>

<span class="sd">        They will be zeros if not provided.</span>
<span class="sd">    hopping_v1v2: 2d complex array</span>
<span class="sd">        Hopping between the two valence shells. The 1st-index (2nd-index) is the 1st (2nd)</span>
<span class="sd">        valence shell.</span>

<span class="sd">        They will be zeros if not provided.</span>
<span class="sd">    do_ed: logical</span>
<span class="sd">        If do_end=True, diagonalize the Hamitlonian to find a few lowest eigenstates, return the</span>
<span class="sd">        eigenvalues and density matirx, and write the eigenvectors in files eigvec.n, otherwise,</span>
<span class="sd">        just write out the input files, do not perform the ED.</span>
<span class="sd">    ed_solver: int</span>
<span class="sd">        Type of ED solver, options can be 0, 1, 2</span>

<span class="sd">        - 0: use Lapack to fully diagonalize Hamiltonian to get all the eigenvalues.</span>

<span class="sd">        - 1: use standard Lanczos algorithm to find only a few lowest eigenvalues,</span>
<span class="sd">          no re-orthogonalization has been applied, so it is not very accurate.</span>

<span class="sd">        - 2: use parallel version of Arpack library to find a few lowest eigenvalues,</span>
<span class="sd">          it is accurate and is the recommeded choice in real calculations of XAS and RIXS.</span>
<span class="sd">    neval: int</span>
<span class="sd">        Number of eigenvalues to be found. For ed_solver=2, the value should not be too small,</span>
<span class="sd">        neval &gt; 10 is usually a safe value.</span>
<span class="sd">    nvector: int</span>
<span class="sd">        Number of eigenvectors to be found and written into files.</span>
<span class="sd">    ncv: int</span>
<span class="sd">        Used for ed_solver=2, it should be at least ncv &gt; neval + 2. Usually, set it a little</span>
<span class="sd">        bit larger than neval, for example, set ncv=200 when neval=100.</span>
<span class="sd">    idump: logical</span>
<span class="sd">        Whether to dump the eigenvectors to files &quot;eigvec.n&quot;, where n means the n-th vectors.</span>
<span class="sd">    maxiter: int</span>
<span class="sd">        Maximum number of iterations in finding all the eigenvalues, used for ed_solver=1, 2.</span>
<span class="sd">    eigval_tol: float</span>
<span class="sd">        The convergence criteria of eigenvalues, used for ed_solver=1, 2.</span>
<span class="sd">    min_ndim: int</span>
<span class="sd">        The minimum dimension of the Hamiltonian when the ed_solver=1, 2 can be used, otherwise,</span>
<span class="sd">        ed_solver=1 will be used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eval_i: 1d float array, shape=(neval, )</span>
<span class="sd">        The eigenvalues of initial Hamiltonian.</span>
<span class="sd">    denmat: 2d complex array, shape=(nvector, v1v2_norb, v1v2_norb))</span>
<span class="sd">        The density matrix in the eigenstates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]</span>
    <span class="n">c_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p12&#39;</span><span class="p">,</span> <span class="s1">&#39;p32&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;d32&#39;</span><span class="p">,</span> <span class="s1">&#39;d52&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;f52&#39;</span><span class="p">,</span> <span class="s1">&#39;f72&#39;</span><span class="p">]</span>
    <span class="n">v1_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">v2_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">c_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">v1_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of valence shell: &quot;</span><span class="p">,</span> <span class="n">v1_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">v2_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of valence shell: &quot;</span><span class="p">,</span> <span class="n">v2_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of core shell: &quot;</span><span class="p">,</span> <span class="n">c_name</span><span class="p">)</span>

    <span class="n">eval_i</span><span class="p">,</span> <span class="n">denmat</span> <span class="o">=</span> <span class="n">_ed_1or2_valence_1core</span><span class="p">(</span>
        <span class="n">comm</span><span class="p">,</span> <span class="n">shell_name</span><span class="p">,</span> <span class="n">shell_level</span><span class="o">=</span><span class="n">shell_level</span><span class="p">,</span> <span class="n">v1_soc</span><span class="o">=</span><span class="n">v1_soc</span><span class="p">,</span> <span class="n">v2_soc</span><span class="o">=</span><span class="n">v2_soc</span><span class="p">,</span> <span class="n">c_soc</span><span class="o">=</span><span class="n">c_soc</span><span class="p">,</span>
        <span class="n">v_tot_noccu</span><span class="o">=</span><span class="n">v_tot_noccu</span><span class="p">,</span> <span class="n">slater</span><span class="o">=</span><span class="n">slater</span><span class="p">,</span> <span class="n">v1_ext_B</span><span class="o">=</span><span class="n">v1_ext_B</span><span class="p">,</span> <span class="n">v2_ext_B</span><span class="o">=</span><span class="n">v2_ext_B</span><span class="p">,</span>
        <span class="n">v1_on_which</span><span class="o">=</span><span class="n">v1_on_which</span><span class="p">,</span> <span class="n">v2_on_which</span><span class="o">=</span><span class="n">v2_on_which</span><span class="p">,</span> <span class="n">v1_cfmat</span><span class="o">=</span><span class="n">v1_cfmat</span><span class="p">,</span>
        <span class="n">v2_cfmat</span><span class="o">=</span><span class="n">v2_cfmat</span><span class="p">,</span> <span class="n">v1_othermat</span><span class="o">=</span><span class="n">v1_othermat</span><span class="p">,</span> <span class="n">v2_othermat</span><span class="o">=</span><span class="n">v2_othermat</span><span class="p">,</span>
        <span class="n">hopping_v1v2</span><span class="o">=</span><span class="n">hopping_v1v2</span><span class="p">,</span> <span class="n">do_ed</span><span class="o">=</span><span class="n">do_ed</span><span class="p">,</span> <span class="n">ed_solver</span><span class="o">=</span><span class="n">ed_solver</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="n">neval</span><span class="p">,</span>
        <span class="n">nvector</span><span class="o">=</span><span class="n">nvector</span><span class="p">,</span> <span class="n">ncv</span><span class="o">=</span><span class="n">ncv</span><span class="p">,</span> <span class="n">idump</span><span class="o">=</span><span class="n">idump</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">eigval_tol</span><span class="o">=</span><span class="n">eigval_tol</span><span class="p">,</span>
        <span class="n">min_ndim</span><span class="o">=</span><span class="n">min_ndim</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">eval_i</span><span class="p">,</span> <span class="n">denmat</span></div>


<span class="k">def</span> <span class="nf">_ed_1or2_valence_1core</span><span class="p">(</span>
        <span class="n">comm</span><span class="p">,</span> <span class="n">shell_name</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shell_level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">v1_soc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v2_soc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c_soc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">v_tot_noccu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">slater</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">v1_ext_B</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v2_ext_B</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v1_on_which</span><span class="o">=</span><span class="s1">&#39;spin&#39;</span><span class="p">,</span> <span class="n">v2_on_which</span><span class="o">=</span><span class="s1">&#39;spin&#39;</span><span class="p">,</span>
        <span class="n">v1_cfmat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v2_cfmat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v1_othermat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v2_othermat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">hopping_v1v2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">do_ed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ed_solver</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nvector</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">idump</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">eigval_tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">min_ndim</span><span class="o">=</span><span class="mi">1000</span>
        <span class="p">):</span>
    <span class="kn">from</span> <span class="nn">.fedrixs</span> <span class="kn">import</span> <span class="n">ed_fsolver</span>

    <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
    <span class="n">fcomm</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">py2f</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Running ED ...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">v1_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">v2_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">c_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">info_shell</span> <span class="o">=</span> <span class="n">info_atomic_shell</span><span class="p">()</span>

    <span class="c1"># Quantum numbers of angular momentum</span>
    <span class="n">v1_orbl</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">v1_name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">v2_name</span> <span class="o">!=</span> <span class="s1">&#39;empty&#39;</span><span class="p">:</span>
        <span class="n">v2_orbl</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">v2_name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v2_orbl</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># number of orbitals with spin</span>
    <span class="n">v1_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">v1_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">v2_name</span> <span class="o">!=</span> <span class="s1">&#39;empty&#39;</span><span class="p">:</span>
        <span class="n">v2_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">v2_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v2_norb</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">c_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">c_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># total number of orbitals</span>
    <span class="n">ntot</span> <span class="o">=</span> <span class="n">v1_norb</span> <span class="o">+</span> <span class="n">v2_norb</span> <span class="o">+</span> <span class="n">c_norb</span>
    <span class="n">v1v2_norb</span> <span class="o">=</span> <span class="n">v1_norb</span> <span class="o">+</span> <span class="n">v2_norb</span>

    <span class="c1"># Coulomb interaction</span>
    <span class="k">if</span> <span class="n">v2_name</span> <span class="o">==</span> <span class="s1">&#39;empty&#39;</span><span class="p">:</span>
        <span class="n">slater_name</span> <span class="o">=</span> <span class="n">slater_integrals_name</span><span class="p">((</span><span class="n">v1_name</span><span class="p">,</span> <span class="n">c_name</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">slater_name</span> <span class="o">=</span> <span class="n">slater_integrals_name</span><span class="p">((</span><span class="n">v1_name</span><span class="p">,</span> <span class="n">v2_name</span><span class="p">,</span> <span class="n">c_name</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;v1&#39;</span><span class="p">,</span> <span class="s1">&#39;v2&#39;</span><span class="p">,</span> <span class="s1">&#39;c1&#39;</span><span class="p">))</span>
    <span class="n">nslat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">slater_name</span><span class="p">)</span>
    <span class="n">slater_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nslat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">slater_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nslat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">slater</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nslat</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">slater</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">slater_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">slater</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">slater</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slater_i</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">slater</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">nslat</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nslat</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">slater</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">slater_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">slater</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">slater</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slater_n</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">slater</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">nslat</span><span class="p">]</span>

    <span class="c1"># print summary of slater integrals</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Summary of Slater integrals:&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ------------------------------&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Terms,  Initial Hamiltonian,  Intermediate Hamiltonian&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nslat</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;    &quot;</span><span class="p">,</span> <span class="n">slater_name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="s2">&quot;:  </span><span class="si">{:20.10f}{:20.10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">slater_i</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">slater_n</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">v2_name</span> <span class="o">==</span> <span class="s1">&#39;empty&#39;</span><span class="p">:</span>
        <span class="n">umat_i</span> <span class="o">=</span> <span class="n">get_umat_slater</span><span class="p">(</span><span class="n">v1_name</span> <span class="o">+</span> <span class="n">c_name</span><span class="p">,</span> <span class="o">*</span><span class="n">slater_i</span><span class="p">)</span>
        <span class="n">umat_n</span> <span class="o">=</span> <span class="n">get_umat_slater</span><span class="p">(</span><span class="n">v1_name</span> <span class="o">+</span> <span class="n">c_name</span><span class="p">,</span> <span class="o">*</span><span class="n">slater_n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">umat_i</span> <span class="o">=</span> <span class="n">get_umat_slater_3shells</span><span class="p">((</span><span class="n">v1_name</span><span class="p">,</span> <span class="n">v2_name</span><span class="p">,</span> <span class="n">c_name</span><span class="p">),</span> <span class="o">*</span><span class="n">slater_i</span><span class="p">)</span>
        <span class="n">umat_n</span> <span class="o">=</span> <span class="n">get_umat_slater_3shells</span><span class="p">((</span><span class="n">v1_name</span><span class="p">,</span> <span class="n">v2_name</span><span class="p">,</span> <span class="n">c_name</span><span class="p">),</span> <span class="o">*</span><span class="n">slater_n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">write_umat</span><span class="p">(</span><span class="n">umat_i</span><span class="p">,</span> <span class="s1">&#39;coulomb_i.in&#39;</span><span class="p">)</span>
        <span class="n">write_umat</span><span class="p">(</span><span class="n">umat_n</span><span class="p">,</span> <span class="s1">&#39;coulomb_n.in&#39;</span><span class="p">)</span>

    <span class="n">emat_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">emat_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="c1"># SOC</span>
    <span class="k">if</span> <span class="n">v1_soc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">v1_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]:</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">atom_hsoc</span><span class="p">(</span><span class="n">v1_name</span><span class="p">,</span> <span class="n">v1_soc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">atom_hsoc</span><span class="p">(</span><span class="n">v1_name</span><span class="p">,</span> <span class="n">v1_soc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">v2_soc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">v2_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]:</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">atom_hsoc</span><span class="p">(</span><span class="n">v2_name</span><span class="p">,</span> <span class="n">v2_soc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">atom_hsoc</span><span class="p">(</span><span class="n">v2_name</span><span class="p">,</span> <span class="n">v2_soc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">c_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]:</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="n">v1v2_norb</span><span class="p">:</span><span class="n">ntot</span><span class="p">,</span> <span class="n">v1v2_norb</span><span class="p">:</span><span class="n">ntot</span><span class="p">]</span> <span class="o">+=</span> <span class="n">atom_hsoc</span><span class="p">(</span><span class="n">c_name</span><span class="p">,</span> <span class="n">c_soc</span><span class="p">)</span>

    <span class="c1"># crystal field</span>
    <span class="k">if</span> <span class="n">v1_cfmat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v1_cfmat</span><span class="p">)</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v1_cfmat</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">v2_cfmat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">v2_name</span> <span class="o">!=</span> <span class="s1">&#39;empty&#39;</span><span class="p">:</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v2_cfmat</span><span class="p">)</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v2_cfmat</span><span class="p">)</span>

    <span class="c1"># other mat</span>
    <span class="k">if</span> <span class="n">v1_othermat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v1_othermat</span><span class="p">)</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v1_othermat</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">v2_othermat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">v2_name</span> <span class="o">!=</span> <span class="s1">&#39;empty&#39;</span><span class="p">:</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v2_othermat</span><span class="p">)</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v2_othermat</span><span class="p">)</span>

    <span class="c1"># energy of shell</span>
    <span class="k">if</span> <span class="n">shell_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">eval_shift</span> <span class="o">=</span> <span class="n">shell_level</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">c_norb</span> <span class="o">/</span> <span class="n">v_tot_noccu</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">v1_norb</span><span class="p">)</span> <span class="o">*</span> <span class="n">shell_level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">v1_norb</span><span class="p">)</span> <span class="o">*</span> <span class="n">eval_shift</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">v1_norb</span><span class="p">)</span> <span class="o">*</span> <span class="n">shell_level</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="n">v1v2_norb</span><span class="p">:</span><span class="n">ntot</span><span class="p">,</span> <span class="n">v1v2_norb</span><span class="p">:</span><span class="n">ntot</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">c_norb</span><span class="p">)</span> <span class="o">*</span> <span class="n">shell_level</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">v2_name</span> <span class="o">!=</span> <span class="s1">&#39;empty&#39;</span><span class="p">:</span>
            <span class="n">emat_i</span><span class="p">[</span><span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">v2_norb</span><span class="p">)</span> <span class="o">*</span> <span class="n">shell_level</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">emat_i</span><span class="p">[</span><span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">v2_norb</span><span class="p">)</span> <span class="o">*</span> <span class="n">eval_shift</span>
            <span class="n">emat_n</span><span class="p">[</span><span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">v2_norb</span><span class="p">)</span> <span class="o">*</span> <span class="n">shell_level</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># external magnetic field</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">ext_B</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">v1_name</span><span class="p">,</span> <span class="n">v1_orbl</span><span class="p">,</span> <span class="n">v1_ext_B</span><span class="p">,</span> <span class="n">v1_on_which</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v1_norb</span><span class="p">),</span>
        <span class="p">(</span><span class="n">v2_name</span><span class="p">,</span> <span class="n">v2_orbl</span><span class="p">,</span> <span class="n">v2_ext_B</span><span class="p">,</span> <span class="n">v2_on_which</span><span class="p">,</span> <span class="n">v1_norb</span><span class="p">,</span> <span class="n">v1v2_norb</span><span class="p">)</span>
    <span class="p">]:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;empty&#39;</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;t2g&#39;</span><span class="p">:</span>
            <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">lz</span> <span class="o">=</span> <span class="n">get_lx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">get_ly</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">get_lz</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">get_sx</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">get_sy</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">get_sz</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">lz</span> <span class="o">=</span> <span class="o">-</span><span class="n">lx</span><span class="p">,</span> <span class="o">-</span><span class="n">ly</span><span class="p">,</span> <span class="o">-</span><span class="n">lz</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">lz</span> <span class="o">=</span> <span class="n">get_lx</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">get_ly</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">get_lz</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">get_sx</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">get_sy</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">get_sz</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ext_B</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">which</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;spin&#39;</span><span class="p">:</span>
                <span class="n">zeeman</span> <span class="o">=</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sx</span><span class="p">)</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sy</span><span class="p">)</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">which</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;orbital&#39;</span><span class="p">:</span>
                <span class="n">zeeman</span> <span class="o">=</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">lx</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ly</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">lz</span>
            <span class="k">elif</span> <span class="n">which</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
                <span class="n">zeeman</span> <span class="o">=</span> <span class="p">(</span><span class="n">ext_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">lx</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sx</span><span class="p">)</span> <span class="o">+</span>
                          <span class="n">ext_B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ly</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sy</span><span class="p">)</span> <span class="o">+</span>
                          <span class="n">ext_B</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">lz</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sz</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown value of zeeman_on_which&quot;</span><span class="p">,</span> <span class="n">which</span><span class="p">)</span>
            <span class="n">emat_i</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">,</span> <span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">zeeman</span>
            <span class="n">emat_n</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">,</span> <span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">zeeman</span>

    <span class="c1"># hopping between the two valence shells</span>
    <span class="k">if</span> <span class="n">hopping_v1v2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">v2_name</span> <span class="o">!=</span> <span class="s1">&#39;empty&#39;</span><span class="p">:</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">,</span> <span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hopping_v1v2</span><span class="p">)</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">hopping_v1v2</span><span class="p">))</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">,</span> <span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hopping_v1v2</span><span class="p">)</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">hopping_v1v2</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">write_emat</span><span class="p">(</span><span class="n">emat_i</span><span class="p">,</span> <span class="s1">&#39;hopping_i.in&#39;</span><span class="p">)</span>
        <span class="n">write_emat</span><span class="p">(</span><span class="n">emat_n</span><span class="p">,</span> <span class="s1">&#39;hopping_n.in&#39;</span><span class="p">)</span>
        <span class="n">write_config</span><span class="p">(</span>
            <span class="s1">&#39;./&#39;</span><span class="p">,</span> <span class="n">ed_solver</span><span class="p">,</span> <span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">c_norb</span><span class="p">,</span> <span class="n">neval</span><span class="p">,</span> <span class="n">nvector</span><span class="p">,</span> <span class="n">ncv</span><span class="p">,</span> <span class="n">idump</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">min_ndim</span><span class="o">=</span><span class="n">min_ndim</span><span class="p">,</span> <span class="n">eigval_tol</span><span class="o">=</span><span class="n">eigval_tol</span>
        <span class="p">)</span>
        <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v_tot_noccu</span><span class="p">,</span> <span class="s2">&quot;fock_i.in&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">do_ed</span><span class="p">:</span>
        <span class="c1"># now, call ed solver</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
        <span class="n">ed_fsolver</span><span class="p">(</span><span class="n">fcomm</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>

        <span class="c1"># read eigvals.dat and denmat.dat</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;eigvals.dat&#39;</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">eval_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">neval</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">eval_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">neval</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">neval</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;denmat.dat&#39;</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">nvector</span><span class="p">,</span> <span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v1v2_norb</span><span class="p">)</span>
        <span class="n">denmat</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">eval_i</span><span class="p">,</span> <span class="n">denmat</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>


<div class="viewcode-block" id="xas_1v1c_fort"><a class="viewcode-back" href="../../reference/solvers.html#edrixs.solvers.xas_1v1c_fort">[docs]</a><span class="k">def</span> <span class="nf">xas_1v1c_fort</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">shell_name</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">gamma_c</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                  <span class="n">v_noccu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pol_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">num_gs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nkryl</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                  <span class="n">loc_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate XAS for the case with one valence shells plus one core shell with Fortran solver.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    comm: MPI_comm</span>
<span class="sd">        MPI communicator.</span>
<span class="sd">    shell_name: tuple of two strings</span>
<span class="sd">        Names of valence and core shells. The 1st (2nd) string in the tuple is for the</span>
<span class="sd">        valence (core) shell.</span>

<span class="sd">        - The 1st string can only be &#39;s&#39;, &#39;p&#39;, &#39;t2g&#39;, &#39;d&#39;, &#39;f&#39;,</span>

<span class="sd">        - The 2nd string can be &#39;s&#39;, &#39;p&#39;, &#39;p12&#39;, &#39;p32&#39;, &#39;d&#39;, &#39;d32&#39;, &#39;d52&#39;,</span>
<span class="sd">          &#39;f&#39;, &#39;f52&#39;, &#39;f72&#39;.</span>

<span class="sd">        For example: shell_name=(&#39;d&#39;, &#39;p32&#39;) may indicate a :math:`L_3` edge transition from</span>
<span class="sd">        core :math:`2p_{3/2}` shell to valence :math:`3d` shell for Ni.</span>
<span class="sd">    ominc: 1d float array</span>
<span class="sd">        Incident energy of photon.</span>
<span class="sd">    gamma_c: a float number or a 1d float array with the same shape as ominc.</span>
<span class="sd">        The core-hole life-time broadening factor. It can be a constant value</span>
<span class="sd">        or incident energy dependent.</span>
<span class="sd">    v_noccu: int</span>
<span class="sd">        Total occupancy of valence shells.</span>
<span class="sd">    thin: float number</span>
<span class="sd">        The incident angle of photon (in radian).</span>
<span class="sd">    phi: float number</span>
<span class="sd">        Azimuthal angle (in radian), defined with respect to the</span>
<span class="sd">        :math:`x`-axis of the local scattering axis: scatter_axis[:,0].</span>
<span class="sd">    pol_type: list of tuples</span>
<span class="sd">        Type of polarization, options can be:</span>

<span class="sd">        - (&#39;linear&#39;, alpha), linear polarization, where alpha is the angle between the</span>
<span class="sd">          polarization vector and the scattering plane in radians.</span>

<span class="sd">        - (&#39;left&#39;, 0), left circular polarization.</span>

<span class="sd">        - (&#39;right&#39;, 0), right circular polarization.</span>

<span class="sd">        - (&#39;isotropic&#39;, 0). isotropic polarization.</span>

<span class="sd">        It will set pol_type=[(&#39;isotropic&#39;, 0)] if not provided.</span>
<span class="sd">    num_gs: int</span>
<span class="sd">        Number of initial states used in XAS calculations.</span>
<span class="sd">    nkryl: int</span>
<span class="sd">        Maximum number of poles obtained.</span>
<span class="sd">    temperature: float number</span>
<span class="sd">        Temperature (in K) for boltzmann distribution.</span>
<span class="sd">    loc_axis: 3*3 float array</span>
<span class="sd">        The local axis with respect to which local orbitals are defined.</span>

<span class="sd">        - x: local_axis[:,0],</span>

<span class="sd">        - y: local_axis[:,1],</span>

<span class="sd">        - z: local_axis[:,2].</span>

<span class="sd">        It will be an identity matrix if not provided.</span>
<span class="sd">    scatter_axis: 3*3 float array</span>
<span class="sd">        The local axis defining the scattering geometry. The scattering plane is defined in</span>
<span class="sd">        the local :math:`zx`-plane.</span>

<span class="sd">        - local :math:`x`-axis: scatter_axis[:,0]</span>

<span class="sd">        - local :math:`y`-axis: scatter_axis[:,1]</span>

<span class="sd">        - local :math:`z`-axis: scatter_axis[:,2]</span>

<span class="sd">        It will be set to an identity matrix if not provided.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xas: 2d array, shape=(len(ominc), len(pol_type))</span>
<span class="sd">        The calculated XAS spectra. The first dimension is for ominc, and the second dimension</span>
<span class="sd">        if for different polarizations.</span>
<span class="sd">    poles: list of dict, shape=(len(pol_type), )</span>
<span class="sd">        The calculated XAS poles for different polarizations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]</span>
    <span class="n">c_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p12&#39;</span><span class="p">,</span> <span class="s1">&#39;p32&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;d32&#39;</span><span class="p">,</span> <span class="s1">&#39;d52&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;f52&#39;</span><span class="p">,</span> <span class="s1">&#39;f72&#39;</span><span class="p">]</span>

    <span class="n">v_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">c_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">v_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of valence shell: &quot;</span><span class="p">,</span> <span class="n">v_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of core shell: &quot;</span><span class="p">,</span> <span class="n">c_name</span><span class="p">)</span>

    <span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_name</span><span class="p">,</span> <span class="s1">&#39;empty&#39;</span><span class="p">,</span> <span class="n">c_name</span><span class="p">)</span>

    <span class="n">xas</span><span class="p">,</span> <span class="n">poles</span> <span class="o">=</span> <span class="n">_xas_1or2_valence_1core</span><span class="p">(</span>
        <span class="n">comm</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="n">gamma_c</span><span class="o">=</span><span class="n">gamma_c</span><span class="p">,</span> <span class="n">v_tot_noccu</span><span class="o">=</span><span class="n">v_noccu</span><span class="p">,</span>
        <span class="n">trans_to_which</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="n">thin</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span> <span class="n">pol_type</span><span class="o">=</span><span class="n">pol_type</span><span class="p">,</span>
        <span class="n">num_gs</span><span class="o">=</span><span class="n">num_gs</span><span class="p">,</span> <span class="n">nkryl</span><span class="o">=</span><span class="n">nkryl</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span>
        <span class="n">loc_axis</span><span class="o">=</span><span class="n">loc_axis</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="o">=</span><span class="n">scatter_axis</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">xas</span><span class="p">,</span> <span class="n">poles</span></div>


<div class="viewcode-block" id="xas_2v1c_fort"><a class="viewcode-back" href="../../reference/solvers.html#edrixs.solvers.xas_2v1c_fort">[docs]</a><span class="k">def</span> <span class="nf">xas_2v1c_fort</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">shell_name</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">gamma_c</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                  <span class="n">v_tot_noccu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">trans_to_which</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                  <span class="n">pol_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_gs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nkryl</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                  <span class="n">loc_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate XAS for the case with two valence shells plus one core shell with Fortran solver.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    comm: MPI_comm</span>
<span class="sd">        MPI communicator.</span>
<span class="sd">    shell_name: tuple of three strings</span>
<span class="sd">        Names of valence and core shells. The 1st (2nd) string in the tuple is for the</span>
<span class="sd">        1st (2nd) valence shell, and the 3rd one is for the core shell.</span>

<span class="sd">        - The 1st and 2nd strings can only be &#39;s&#39;, &#39;p&#39;, &#39;t2g&#39;, &#39;d&#39;, &#39;f&#39;,</span>

<span class="sd">        - The 3nd string can be &#39;s&#39;, &#39;p&#39;, &#39;p12&#39;, &#39;p32&#39;, &#39;d&#39;, &#39;d32&#39;, &#39;d52&#39;,</span>
<span class="sd">          &#39;f&#39;, &#39;f52&#39;, &#39;f72&#39;.</span>

<span class="sd">        For example: shell_name=(&#39;d&#39;, &#39;p&#39;, &#39;s&#39;) may indicate a :math:`K` edge transition from</span>
<span class="sd">        core :math:`1s` shell to valence :math:`3d` and :math:`4p` shell for Ni.</span>
<span class="sd">    ominc: 1d float array</span>
<span class="sd">        Incident energy of photon.</span>
<span class="sd">    gamma_c: a float number or a 1d float array with the same shape as ominc.</span>
<span class="sd">        The core-hole life-time broadening factor. It can be a constant value</span>
<span class="sd">        or incident energy dependent.</span>
<span class="sd">    v_tot_noccu: int</span>
<span class="sd">        Total occupancy of valence shells.</span>
<span class="sd">    trans_to_which: int</span>
<span class="sd">        Photon transition to which valence shell.</span>

<span class="sd">        - 1: to 1st valence shell,</span>

<span class="sd">        - 2: to 2nd valence shell.</span>
<span class="sd">    thin: float number</span>
<span class="sd">        The incident angle of photon (in radian).</span>
<span class="sd">    phi: float number</span>
<span class="sd">        Azimuthal angle (in radian), defined with respect to the</span>
<span class="sd">        :math:`x`-axis of the local scattering axis: scatter_axis[:,0].</span>
<span class="sd">    pol_type: list of tuples</span>
<span class="sd">        Type of polarization, options can be:</span>

<span class="sd">        - (&#39;linear&#39;, alpha), linear polarization, where alpha is the angle between the</span>
<span class="sd">          polarization vector and the scattering plane in radians.</span>

<span class="sd">        - (&#39;left&#39;, 0), left circular polarization.</span>

<span class="sd">        - (&#39;right&#39;, 0), right circular polarization.</span>

<span class="sd">        - (&#39;isotropic&#39;, 0). isotropic polarization.</span>

<span class="sd">        It will set pol_type=[(&#39;isotropic&#39;, 0)] if not provided.</span>
<span class="sd">    num_gs: int</span>
<span class="sd">        Number of initial states used in XAS calculations.</span>
<span class="sd">    nkryl: int</span>
<span class="sd">        Maximum number of poles obtained.</span>
<span class="sd">    temperature: float number</span>
<span class="sd">        Temperature (in K) for boltzmann distribution.</span>
<span class="sd">    loc_axis: 3*3 float array</span>
<span class="sd">        The local axis with respect to which local orbitals are defined.</span>

<span class="sd">        - x: local_axis[:,0],</span>

<span class="sd">        - y: local_axis[:,1],</span>

<span class="sd">        - z: local_axis[:,2].</span>

<span class="sd">        It will be an identity matrix if not provided.</span>
<span class="sd">    scatter_axis: 3*3 float array</span>
<span class="sd">        The local axis defining the scattering geometry. The scattering plane is defined in</span>
<span class="sd">        the local :math:`zx`-plane.</span>

<span class="sd">        - local :math:`x`-axis: scatter_axis[:,0]</span>

<span class="sd">        - local :math:`y`-axis: scatter_axis[:,1]</span>

<span class="sd">        - local :math:`z`-axis: scatter_axis[:,2]</span>

<span class="sd">        It will be set to an identity matrix if not provided.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xas: 2d array, shape=(len(ominc), len(pol_type))</span>
<span class="sd">        The calculated XAS spectra. The first dimension is for ominc, and the second dimension</span>
<span class="sd">        if for different polarizations.</span>
<span class="sd">    poles: list of dict, shape=(len(pol_type), )</span>
<span class="sd">        The calculated XAS poles for different polarizations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]</span>
    <span class="n">c_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p12&#39;</span><span class="p">,</span> <span class="s1">&#39;p32&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;d32&#39;</span><span class="p">,</span> <span class="s1">&#39;d52&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;f52&#39;</span><span class="p">,</span> <span class="s1">&#39;f72&#39;</span><span class="p">]</span>

    <span class="n">v1_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">v2_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">c_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">v1_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of valence shell: &quot;</span><span class="p">,</span> <span class="n">v1_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">v2_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of valence shell: &quot;</span><span class="p">,</span> <span class="n">v2_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of core shell: &quot;</span><span class="p">,</span> <span class="n">c_name</span><span class="p">)</span>

    <span class="n">xas</span><span class="p">,</span> <span class="n">poles</span> <span class="o">=</span> <span class="n">_xas_1or2_valence_1core</span><span class="p">(</span>
        <span class="n">comm</span><span class="p">,</span> <span class="n">shell_name</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="n">gamma_c</span><span class="o">=</span><span class="n">gamma_c</span><span class="p">,</span> <span class="n">v_tot_noccu</span><span class="o">=</span><span class="n">v_tot_noccu</span><span class="p">,</span>
        <span class="n">trans_to_which</span><span class="o">=</span><span class="n">trans_to_which</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="n">thin</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span> <span class="n">pol_type</span><span class="o">=</span><span class="n">pol_type</span><span class="p">,</span>
        <span class="n">num_gs</span><span class="o">=</span><span class="n">num_gs</span><span class="p">,</span> <span class="n">nkryl</span><span class="o">=</span><span class="n">nkryl</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span>
        <span class="n">loc_axis</span><span class="o">=</span><span class="n">loc_axis</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="o">=</span><span class="n">scatter_axis</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">xas</span><span class="p">,</span> <span class="n">poles</span></div>


<span class="k">def</span> <span class="nf">_xas_1or2_valence_1core</span><span class="p">(</span>
        <span class="n">comm</span><span class="p">,</span> <span class="n">shell_name</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">gamma_c</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">v_tot_noccu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">trans_to_which</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">pol_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_gs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nkryl</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">loc_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">):</span>
    <span class="kn">from</span> <span class="nn">.fedrixs</span> <span class="kn">import</span> <span class="n">xas_fsolver</span>

    <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
    <span class="n">fcomm</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">py2f</span><span class="p">()</span>

    <span class="n">v1_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">v2_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">c_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="n">info_shell</span> <span class="o">=</span> <span class="n">info_atomic_shell</span><span class="p">()</span>
    <span class="n">v1_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">v1_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">v2_name</span> <span class="o">!=</span> <span class="s1">&#39;empty&#39;</span><span class="p">:</span>
        <span class="n">v2_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">v2_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v2_norb</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">c_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">c_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ntot</span> <span class="o">=</span> <span class="n">v1_norb</span> <span class="o">+</span> <span class="n">v2_norb</span> <span class="o">+</span> <span class="n">c_norb</span>
    <span class="n">v1v2_norb</span> <span class="o">=</span> <span class="n">v1_norb</span> <span class="o">+</span> <span class="n">v2_norb</span>
    <span class="k">if</span> <span class="n">pol_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pol_type</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;isotropic&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">loc_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">loc_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loc_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loc_axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scatter_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scatter_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scatter_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scatter_axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Running XAS ...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">write_config</span><span class="p">(</span><span class="n">num_val_orbs</span><span class="o">=</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">num_core_orbs</span><span class="o">=</span><span class="n">c_norb</span><span class="p">,</span>
                     <span class="n">num_gs</span><span class="o">=</span><span class="n">num_gs</span><span class="p">,</span> <span class="n">nkryl</span><span class="o">=</span><span class="n">nkryl</span><span class="p">)</span>
        <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v_tot_noccu</span><span class="p">,</span> <span class="s2">&quot;fock_i.in&quot;</span><span class="p">)</span>
        <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v_tot_noccu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;fock_n.in&quot;</span><span class="p">)</span>

    <span class="c1"># Build transition operators in local-xyz axis</span>
    <span class="k">if</span> <span class="n">trans_to_which</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">case</span> <span class="o">=</span> <span class="n">v1_name</span> <span class="o">+</span> <span class="n">c_name</span>
    <span class="k">elif</span> <span class="n">trans_to_which</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">v2_name</span> <span class="o">!=</span> <span class="s1">&#39;empty&#39;</span><span class="p">:</span>
        <span class="n">case</span> <span class="o">=</span> <span class="n">v2_name</span> <span class="o">+</span> <span class="n">c_name</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unkonwn trans_to_which: &#39;</span><span class="p">,</span> <span class="n">trans_to_which</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">get_trans_oper</span><span class="p">(</span><span class="n">case</span><span class="p">)</span>
    <span class="n">npol</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">tmp_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npol</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">trans_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npol</span><span class="p">,</span> <span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="c1"># Transform the transition operators to global-xyz axis</span>
    <span class="c1"># dipolar transition</span>
    <span class="k">if</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">tmp_g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">loc_axis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="c1"># quadrupolar transition</span>
    <span class="k">elif</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">rmat_to_euler</span><span class="p">(</span><span class="n">loc_axis</span><span class="p">)</span>
        <span class="n">wignerD</span> <span class="o">=</span> <span class="n">get_wigner_dmat</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
        <span class="n">rotmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmat_r2c</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">wignerD</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tmat_r2c</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">))))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                <span class="n">tmp_g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rotmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Have NOT implemented this case: &quot;</span><span class="p">,</span> <span class="n">npol</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">trans_to_which</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">trans_mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">,</span> <span class="n">v1v2_norb</span><span class="p">:</span><span class="n">ntot</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_g</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trans_mat</span><span class="p">[:,</span> <span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v1v2_norb</span><span class="p">:</span><span class="n">ntot</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_g</span>

    <span class="n">n_om</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ominc</span><span class="p">)</span>
    <span class="n">gamma_core</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_om</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">gamma_c</span><span class="p">):</span>
        <span class="n">gamma_core</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_om</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma_c</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gamma_core</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gamma_c</span>

    <span class="c1"># loop over different polarization</span>
    <span class="n">xas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_om</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pol_type</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">poles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">it</span><span class="p">,</span> <span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pol_type</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span> <span class="ow">or</span> <span class="n">pt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span> <span class="ow">or</span> <span class="n">pt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Loop over for polarization: &quot;</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">kvec</span> <span class="o">=</span> <span class="n">unit_wavevector</span><span class="p">(</span><span class="n">thin</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">)</span>
                <span class="n">polvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">pol</span> <span class="o">=</span> <span class="n">dipole_polvec_xas</span><span class="p">(</span><span class="n">thin</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Dipolar transition</span>
                    <span class="n">polvec</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">pol</span>
                <span class="k">if</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>  <span class="c1"># Quadrupolar transition</span>
                    <span class="n">polvec</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">quadrupole_polvec</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">kvec</span><span class="p">)</span>
                <span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">):</span>
                    <span class="n">trans</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">trans_mat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">polvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">write_emat</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s1">&#39;transop_xas.in&#39;</span><span class="p">)</span>

            <span class="c1"># call XAS solver in fedrixs</span>
            <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
            <span class="n">xas_fsolver</span><span class="p">(</span><span class="n">fcomm</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>

            <span class="n">file_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;xas_poles.&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_gs</span><span class="p">)]</span>
            <span class="n">pole_dict</span> <span class="o">=</span> <span class="n">read_poles_from_file</span><span class="p">(</span><span class="n">file_list</span><span class="p">)</span>
            <span class="n">poles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pole_dict</span><span class="p">)</span>
            <span class="n">xas</span><span class="p">[:,</span> <span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_spectra_from_poles</span><span class="p">(</span><span class="n">pole_dict</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="n">gamma_core</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;isotropic&#39;</span><span class="p">:</span>
            <span class="n">pole_dicts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Loop over for polarization: &quot;</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Isotropic, component: &quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">write_emat</span><span class="p">(</span><span class="n">trans_mat</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="s1">&#39;transop_xas.in&#39;</span><span class="p">)</span>
                <span class="c1"># call XAS solver in fedrixs</span>
                <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
                <span class="n">xas_fsolver</span><span class="p">(</span><span class="n">fcomm</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
                <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>

                <span class="n">file_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;xas_poles.&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_gs</span><span class="p">)]</span>
                <span class="n">pole_tmp</span> <span class="o">=</span> <span class="n">read_poles_from_file</span><span class="p">(</span><span class="n">file_list</span><span class="p">)</span>
                <span class="n">xas</span><span class="p">[:,</span> <span class="n">it</span><span class="p">]</span> <span class="o">+=</span> <span class="n">get_spectra_from_poles</span><span class="p">(</span><span class="n">pole_tmp</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="n">gamma_core</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>
                <span class="n">pole_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pole_tmp</span><span class="p">)</span>
            <span class="n">xas</span><span class="p">[:,</span> <span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="n">xas</span><span class="p">[:,</span> <span class="n">it</span><span class="p">]</span> <span class="o">/</span> <span class="n">npol</span>
            <span class="n">poles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merge_pole_dicts</span><span class="p">(</span><span class="n">pole_dicts</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown polarization type: &quot;</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xas</span><span class="p">,</span> <span class="n">poles</span>


<div class="viewcode-block" id="rixs_1v1c_fort"><a class="viewcode-back" href="../../reference/solvers.html#edrixs.solvers.rixs_1v1c_fort">[docs]</a><span class="k">def</span> <span class="nf">rixs_1v1c_fort</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">shell_name</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="n">eloss</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">gamma_c</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">gamma_f</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                   <span class="n">v_noccu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">thout</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pol_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">num_gs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nkryl</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">linsys_max</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">linsys_tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
                   <span class="n">temperature</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">loc_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate RIXS for the case with one valence shell plus one core shell with Fortran solver.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    comm: MPI_comm</span>
<span class="sd">        MPI communicator.</span>
<span class="sd">    shell_name: tuple of two strings</span>
<span class="sd">        Names of valence and core shells. The 1st (2nd) string in the tuple is for the</span>
<span class="sd">        valence (core) shell.</span>

<span class="sd">        - The 1st string can only be &#39;s&#39;, &#39;p&#39;, &#39;t2g&#39;, &#39;d&#39;, &#39;f&#39;,</span>

<span class="sd">        - The 2nd string can be &#39;s&#39;, &#39;p&#39;, &#39;p12&#39;, &#39;p32&#39;, &#39;d&#39;, &#39;d32&#39;, &#39;d52&#39;,</span>
<span class="sd">          &#39;f&#39;, &#39;f52&#39;, &#39;f72&#39;.</span>

<span class="sd">        For example: shell_name=(&#39;d&#39;, &#39;p32&#39;) may indicate a :math:`L_3` edge transition from</span>
<span class="sd">        core :math:`2p_{3/2}` shell to valence :math:`3d` shell for Ni.</span>
<span class="sd">    ominc: 1d float array</span>
<span class="sd">        Incident energy of photon.</span>
<span class="sd">    eloss: 1d float array</span>
<span class="sd">        Energy loss.</span>
<span class="sd">    gamma_c: a float number or a 1d float array with same shape as ominc.</span>
<span class="sd">        The core-hole life-time broadening factor. It can be a constant value</span>
<span class="sd">        or incident energy dependent.</span>
<span class="sd">    gamma_f: a float number or a 1d float array with same shape as eloss.</span>
<span class="sd">        The final states life-time broadening factor. It can be a constant value</span>
<span class="sd">        or energy loss dependent.</span>
<span class="sd">    v_noccu: int</span>
<span class="sd">        Total occupancy of valence shells.</span>
<span class="sd">    thin: float number</span>
<span class="sd">        The incident angle of photon (in radian).</span>
<span class="sd">    thout: float number</span>
<span class="sd">        The scattered angle of photon (in radian).</span>
<span class="sd">    phi: float number</span>
<span class="sd">        Azimuthal angle (in radian), defined with respect to the</span>
<span class="sd">        :math:`x`-axis of scattering axis: scatter_axis[:,0].</span>
<span class="sd">    pol_type: list of 4-elements-tuples</span>
<span class="sd">        Type of polarizations. It has the following form:</span>

<span class="sd">        (str1, alpha, str2, beta)</span>

<span class="sd">        where, str1 (str2) can be &#39;linear&#39;, &#39;left&#39;, &#39;right&#39;, and alpha (beta) is</span>
<span class="sd">        the angle (in radians) between the linear polarization vector and the scattering plane.</span>

<span class="sd">        It will set pol_type=[(&#39;linear&#39;, 0, &#39;linear&#39;, 0)] if not provided.</span>
<span class="sd">    num_gs: int</span>
<span class="sd">        Number of initial states used in RIXS calculations.</span>
<span class="sd">    nkryl: int</span>
<span class="sd">        Maximum number of poles obtained.</span>
<span class="sd">    linsys_max: int</span>
<span class="sd">        Maximum iterations of solving linear equations.</span>
<span class="sd">    linsys_tol: float</span>
<span class="sd">        Convergence for solving linear equations.</span>
<span class="sd">    temperature: float number</span>
<span class="sd">        Temperature (in K) for boltzmann distribution.</span>
<span class="sd">    loc_axis: 3*3 float array</span>
<span class="sd">        The local axis with respect to which local orbitals are defined.</span>

<span class="sd">        - x: local_axis[:,0],</span>

<span class="sd">        - y: local_axis[:,1],</span>

<span class="sd">        - z: local_axis[:,2].</span>

<span class="sd">        It will be an identity matrix if not provided.</span>
<span class="sd">    scatter_axis: 3*3 float array</span>
<span class="sd">        The local axis defining the scattering geometry. The scattering plane is defined in</span>
<span class="sd">        the local :math:`zx`-plane.</span>

<span class="sd">        - local :math:`x`-axis: scatter_axis[:,0]</span>

<span class="sd">        - local :math:`y`-axis: scatter_axis[:,1]</span>

<span class="sd">        - local :math:`z`-axis: scatter_axis[:,2]</span>

<span class="sd">        It will be set to an identity matrix if not provided.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rixs: 3d float array, shape=(len(ominc), len(eloss), len(pol_type))</span>
<span class="sd">        The calculated RIXS spectra. The 1st dimension is for the incident energy,</span>
<span class="sd">        the 2nd dimension is for the energy loss and the 3rd dimension is for</span>
<span class="sd">        different polarizations.</span>
<span class="sd">    poles: 2d list of dict, shape=(len(ominc), len(pol_type))</span>
<span class="sd">        The calculated RIXS poles. The 1st dimension is for incident energy, and the</span>
<span class="sd">        2nd dimension is for different polarizations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]</span>
    <span class="n">c_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p12&#39;</span><span class="p">,</span> <span class="s1">&#39;p32&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;d32&#39;</span><span class="p">,</span> <span class="s1">&#39;d52&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;f52&#39;</span><span class="p">,</span> <span class="s1">&#39;f72&#39;</span><span class="p">]</span>
    <span class="n">v_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">c_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">v_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of valence shell: &quot;</span><span class="p">,</span> <span class="n">v_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of core shell: &quot;</span><span class="p">,</span> <span class="n">c_name</span><span class="p">)</span>

    <span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_name</span><span class="p">,</span> <span class="s1">&#39;empty&#39;</span><span class="p">,</span> <span class="n">c_name</span><span class="p">)</span>
    <span class="n">rixs</span><span class="p">,</span> <span class="n">poles</span> <span class="o">=</span> <span class="n">_rixs_1or2_valence_1core</span><span class="p">(</span>
        <span class="n">comm</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="n">eloss</span><span class="p">,</span> <span class="n">gamma_c</span><span class="o">=</span><span class="n">gamma_c</span><span class="p">,</span> <span class="n">gamma_f</span><span class="o">=</span><span class="n">gamma_f</span><span class="p">,</span>
        <span class="n">v_tot_noccu</span><span class="o">=</span><span class="n">v_noccu</span><span class="p">,</span> <span class="n">trans_to_which</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="n">thin</span><span class="p">,</span>
        <span class="n">thout</span><span class="o">=</span><span class="n">thout</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span> <span class="n">pol_type</span><span class="o">=</span><span class="n">pol_type</span><span class="p">,</span> <span class="n">num_gs</span><span class="o">=</span><span class="n">num_gs</span><span class="p">,</span> <span class="n">nkryl</span><span class="o">=</span><span class="n">nkryl</span><span class="p">,</span>
        <span class="n">linsys_max</span><span class="o">=</span><span class="n">linsys_max</span><span class="p">,</span> <span class="n">linsys_tol</span><span class="o">=</span><span class="n">linsys_tol</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span>
        <span class="n">loc_axis</span><span class="o">=</span><span class="n">loc_axis</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="o">=</span><span class="n">loc_axis</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">rixs</span><span class="p">,</span> <span class="n">poles</span></div>


<div class="viewcode-block" id="rixs_2v1c_fort"><a class="viewcode-back" href="../../reference/solvers.html#edrixs.solvers.rixs_2v1c_fort">[docs]</a><span class="k">def</span> <span class="nf">rixs_2v1c_fort</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">shell_name</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="n">eloss</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">gamma_c</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">gamma_f</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                   <span class="n">v_tot_noccu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">trans_to_which</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">thout</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">pol_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_gs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nkryl</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">linsys_max</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">linsys_tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
                   <span class="n">temperature</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">loc_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate RIXS for the case with 2 valence shells plus 1 core shell.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    comm: MPI_comm</span>
<span class="sd">        MPI communicator.</span>
<span class="sd">    shell_name: tuple of three strings</span>
<span class="sd">        Names of valence and core shells. The 1st (2nd) string in the tuple is for the</span>
<span class="sd">        1st (2nd) valence shell, and the 3rd one is for the core shell.</span>

<span class="sd">        - The 1st and 2nd strings can only be &#39;s&#39;, &#39;p&#39;, &#39;t2g&#39;, &#39;d&#39;, &#39;f&#39;,</span>

<span class="sd">        - The 3nd string can be &#39;s&#39;, &#39;p&#39;, &#39;p12&#39;, &#39;p32&#39;, &#39;d&#39;, &#39;d32&#39;, &#39;d52&#39;,</span>
<span class="sd">          &#39;f&#39;, &#39;f52&#39;, &#39;f72&#39;.</span>

<span class="sd">        For example: shell_name=(&#39;d&#39;, &#39;p&#39;, &#39;s&#39;) may indicate a :math:`K` edge transition from</span>
<span class="sd">        core :math:`1s` shell to valence :math:`3d` and :math:`4p` shell for Ni.</span>
<span class="sd">    ominc: 1d float array</span>
<span class="sd">        Incident energy of photon.</span>
<span class="sd">    eloss: 1d float array</span>
<span class="sd">        Energy loss.</span>
<span class="sd">    gamma_c: a float number or a 1d float array with same shape as ominc.</span>
<span class="sd">        The core-hole life-time broadening factor. It can be a constant value</span>
<span class="sd">        or incident energy dependent.</span>
<span class="sd">    gamma_f: a float number or a 1d float array with same shape as eloss.</span>
<span class="sd">        The final states life-time broadening factor. It can be a constant value</span>
<span class="sd">        or energy loss dependent.</span>
<span class="sd">    v_tot_noccu: int</span>
<span class="sd">        Total occupancy of valence shells.</span>
<span class="sd">    trans_to_which: int</span>
<span class="sd">        Photon transition to which valence shell.</span>

<span class="sd">        - 1: to 1st valence shell,</span>

<span class="sd">        - 2: to 2nd valence shell.</span>
<span class="sd">    thin: float number</span>
<span class="sd">        The incident angle of photon (in radian).</span>
<span class="sd">    thout: float number</span>
<span class="sd">        The scattered angle of photon (in radian).</span>
<span class="sd">    phi: float number</span>
<span class="sd">        Azimuthal angle (in radian), defined with respect to the</span>
<span class="sd">        :math:`x`-axis of scattering axis: scatter_axis[:,0].</span>
<span class="sd">    pol_type: list of 4-elements-tuples</span>
<span class="sd">        Type of polarizations. It has the following form:</span>

<span class="sd">        (str1, alpha, str2, beta)</span>

<span class="sd">        where, str1 (str2) can be &#39;linear&#39;, &#39;left&#39;, &#39;right&#39;, and alpha (beta) is</span>
<span class="sd">        the angle (in radians) between the linear polarization vector and the scattering plane.</span>

<span class="sd">        It will set pol_type=[(&#39;linear&#39;, 0, &#39;linear&#39;, 0)] if not provided.</span>
<span class="sd">    num_gs: int</span>
<span class="sd">        Number of initial states used in RIXS calculations.</span>
<span class="sd">    nkryl: int</span>
<span class="sd">        Maximum number of poles obtained.</span>
<span class="sd">    linsys_max: int</span>
<span class="sd">        Maximum iterations of solving linear equations.</span>
<span class="sd">    linsys_tol: float</span>
<span class="sd">        Convergence for solving linear equations.</span>
<span class="sd">    temperature: float number</span>
<span class="sd">        Temperature (in K) for boltzmann distribution.</span>
<span class="sd">    loc_axis: 3*3 float array</span>
<span class="sd">        The local axis with respect to which local orbitals are defined.</span>

<span class="sd">        - x: local_axis[:,0],</span>

<span class="sd">        - y: local_axis[:,1],</span>

<span class="sd">        - z: local_axis[:,2].</span>

<span class="sd">        It will be an identity matrix if not provided.</span>
<span class="sd">    scatter_axis: 3*3 float array</span>
<span class="sd">        The local axis defining the scattering geometry. The scattering plane is defined in</span>
<span class="sd">        the local :math:`zx`-plane.</span>

<span class="sd">        - local :math:`x`-axis: scatter_axis[:,0]</span>

<span class="sd">        - local :math:`y`-axis: scatter_axis[:,1]</span>

<span class="sd">        - local :math:`z`-axis: scatter_axis[:,2]</span>

<span class="sd">        It will be set to an identity matrix if not provided.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rixs: 3d float array, shape=(len(ominc), len(eloss), len(pol_type))</span>
<span class="sd">        The calculated RIXS spectra. The 1st dimension is for the incident energy,</span>
<span class="sd">        the 2nd dimension is for the energy loss and the 3rd dimension is for</span>
<span class="sd">        different polarizations.</span>
<span class="sd">    poles: 2d list of dict, shape=(len(ominc), len(pol_type))</span>
<span class="sd">        The calculated RIXS poles. The 1st dimension is for incident energy, and the</span>
<span class="sd">        2nd dimension is for different polarizations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]</span>
    <span class="n">c_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p12&#39;</span><span class="p">,</span> <span class="s1">&#39;p32&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;d32&#39;</span><span class="p">,</span> <span class="s1">&#39;d52&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;f52&#39;</span><span class="p">,</span> <span class="s1">&#39;f72&#39;</span><span class="p">]</span>
    <span class="n">v1_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">v2_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">c_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">v1_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of valence shell: &quot;</span><span class="p">,</span> <span class="n">v1_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">v2_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of valence shell: &quot;</span><span class="p">,</span> <span class="n">v2_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of core shell: &quot;</span><span class="p">,</span> <span class="n">c_name</span><span class="p">)</span>

    <span class="n">rixs</span><span class="p">,</span> <span class="n">poles</span> <span class="o">=</span> <span class="n">_rixs_1or2_valence_1core</span><span class="p">(</span>
        <span class="n">comm</span><span class="p">,</span> <span class="n">shell_name</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="n">eloss</span><span class="p">,</span> <span class="n">gamma_c</span><span class="o">=</span><span class="n">gamma_c</span><span class="p">,</span> <span class="n">gamma_f</span><span class="o">=</span><span class="n">gamma_f</span><span class="p">,</span>
        <span class="n">v_tot_noccu</span><span class="o">=</span><span class="n">v_tot_noccu</span><span class="p">,</span> <span class="n">trans_to_which</span><span class="o">=</span><span class="n">trans_to_which</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="n">thin</span><span class="p">,</span>
        <span class="n">thout</span><span class="o">=</span><span class="n">thout</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span> <span class="n">pol_type</span><span class="o">=</span><span class="n">pol_type</span><span class="p">,</span> <span class="n">num_gs</span><span class="o">=</span><span class="n">num_gs</span><span class="p">,</span> <span class="n">nkryl</span><span class="o">=</span><span class="n">nkryl</span><span class="p">,</span>
        <span class="n">linsys_max</span><span class="o">=</span><span class="n">linsys_max</span><span class="p">,</span> <span class="n">linsys_tol</span><span class="o">=</span><span class="n">linsys_tol</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span>
        <span class="n">loc_axis</span><span class="o">=</span><span class="n">loc_axis</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="o">=</span><span class="n">loc_axis</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">rixs</span><span class="p">,</span> <span class="n">poles</span></div>


<span class="k">def</span> <span class="nf">_rixs_1or2_valence_1core</span><span class="p">(</span>
        <span class="n">comm</span><span class="p">,</span> <span class="n">shell_name</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="n">eloss</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">gamma_c</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">gamma_f</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">v_tot_noccu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">trans_to_which</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">thout</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">pol_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_gs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nkryl</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">linsys_max</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">linsys_tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">temperature</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">loc_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">):</span>
    <span class="kn">from</span> <span class="nn">.fedrixs</span> <span class="kn">import</span> <span class="n">rixs_fsolver</span>

    <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
    <span class="n">fcomm</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">py2f</span><span class="p">()</span>

    <span class="n">v1_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">v2_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">c_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="n">info_shell</span> <span class="o">=</span> <span class="n">info_atomic_shell</span><span class="p">()</span>

    <span class="n">v1_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">v1_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">v2_name</span> <span class="o">!=</span> <span class="s1">&#39;empty&#39;</span><span class="p">:</span>
        <span class="n">v2_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">v2_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v2_norb</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">c_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">c_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ntot</span> <span class="o">=</span> <span class="n">v1_norb</span> <span class="o">+</span> <span class="n">v2_norb</span> <span class="o">+</span> <span class="n">c_norb</span>
    <span class="n">v1v2_norb</span> <span class="o">=</span> <span class="n">v1_norb</span> <span class="o">+</span> <span class="n">v2_norb</span>
    <span class="k">if</span> <span class="n">pol_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pol_type</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">loc_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">loc_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loc_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loc_axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scatter_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scatter_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scatter_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scatter_axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Running RIXS ...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v_tot_noccu</span><span class="p">,</span> <span class="s2">&quot;fock_i.in&quot;</span><span class="p">)</span>
        <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v_tot_noccu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;fock_n.in&quot;</span><span class="p">)</span>
        <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v_tot_noccu</span><span class="p">,</span> <span class="s2">&quot;fock_f.in&quot;</span><span class="p">)</span>

        <span class="c1"># Build transition operators in local-xyz axis</span>
        <span class="k">if</span> <span class="n">trans_to_which</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">case</span> <span class="o">=</span> <span class="n">v1_name</span> <span class="o">+</span> <span class="n">c_name</span>
        <span class="k">elif</span> <span class="n">trans_to_which</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">case</span> <span class="o">=</span> <span class="n">v2_name</span> <span class="o">+</span> <span class="n">c_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unkonwn trans_to_which: &#39;</span><span class="p">,</span> <span class="n">trans_to_which</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">get_trans_oper</span><span class="p">(</span><span class="n">case</span><span class="p">)</span>
        <span class="n">npol</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">tmp_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npol</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">trans_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npol</span><span class="p">,</span> <span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="c1"># Transform the transition operators to global-xyz axis</span>
        <span class="c1"># dipolar transition</span>
        <span class="k">if</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">tmp_g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">loc_axis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="c1"># quadrupolar transition</span>
        <span class="k">elif</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">rmat_to_euler</span><span class="p">(</span><span class="n">loc_axis</span><span class="p">)</span>
            <span class="n">wignerD</span> <span class="o">=</span> <span class="n">get_wigner_dmat</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
            <span class="n">rotmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmat_r2c</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">wignerD</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tmat_r2c</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">))))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                    <span class="n">tmp_g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rotmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Have NOT implemented this case: &quot;</span><span class="p">,</span> <span class="n">npol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trans_to_which</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">trans_mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v1_norb</span><span class="p">,</span> <span class="n">v1v2_norb</span><span class="p">:</span><span class="n">ntot</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_g</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trans_mat</span><span class="p">[:,</span> <span class="n">v1_norb</span><span class="p">:</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">v1v2_norb</span><span class="p">:</span><span class="n">ntot</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_g</span>

    <span class="n">n_om</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ominc</span><span class="p">)</span>
    <span class="n">neloss</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eloss</span><span class="p">)</span>
    <span class="n">gamma_core</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_om</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">gamma_c</span><span class="p">):</span>
        <span class="n">gamma_core</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_om</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma_c</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gamma_core</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gamma_c</span>
    <span class="n">gamma_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">neloss</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">gamma_f</span><span class="p">):</span>
        <span class="n">gamma_final</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">neloss</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma_f</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gamma_final</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gamma_f</span>

    <span class="c1"># loop over different polarization</span>
    <span class="n">rixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_om</span><span class="p">,</span> <span class="n">neloss</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pol_type</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">poles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
    <span class="c1"># loop over different polarization</span>
    <span class="k">for</span> <span class="n">iom</span><span class="p">,</span> <span class="n">omega</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ominc</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">write_config</span><span class="p">(</span>
                <span class="n">num_val_orbs</span><span class="o">=</span><span class="n">v1v2_norb</span><span class="p">,</span> <span class="n">num_core_orbs</span><span class="o">=</span><span class="n">c_norb</span><span class="p">,</span>
                <span class="n">omega_in</span><span class="o">=</span><span class="n">omega</span><span class="p">,</span> <span class="n">gamma_in</span><span class="o">=</span><span class="n">gamma_core</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span>
                <span class="n">num_gs</span><span class="o">=</span><span class="n">num_gs</span><span class="p">,</span> <span class="n">nkryl</span><span class="o">=</span><span class="n">nkryl</span><span class="p">,</span> <span class="n">linsys_max</span><span class="o">=</span><span class="n">linsys_max</span><span class="p">,</span>
                <span class="n">linsys_tol</span><span class="o">=</span><span class="n">linsys_tol</span>
            <span class="p">)</span>
        <span class="n">poles_per_om</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># loop over polarization</span>
        <span class="k">for</span> <span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">jt</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pol_type</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Calculate RIXS for incident energy: &quot;</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Polarization: &quot;</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">polvec_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">polvec_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">ei</span><span class="p">,</span> <span class="n">ef</span> <span class="o">=</span> <span class="n">dipole_polvec_rixs</span><span class="p">(</span><span class="n">thin</span><span class="p">,</span> <span class="n">thout</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span>
                                            <span class="n">scatter_axis</span><span class="p">,</span> <span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">jt</span><span class="p">))</span>
                <span class="c1"># dipolar transition</span>
                <span class="k">if</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">polvec_i</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ei</span>
                    <span class="n">polvec_f</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ef</span>
                <span class="c1"># quadrupolar transition</span>
                <span class="k">elif</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="n">ki</span> <span class="o">=</span> <span class="n">unit_wavevector</span><span class="p">(</span><span class="n">thin</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;in&#39;</span><span class="p">)</span>
                    <span class="n">kf</span> <span class="o">=</span> <span class="n">unit_wavevector</span><span class="p">(</span><span class="n">thout</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)</span>
                    <span class="n">polvec_i</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">quadrupole_polvec</span><span class="p">(</span><span class="n">ei</span><span class="p">,</span> <span class="n">ki</span><span class="p">)</span>
                    <span class="n">polvec_f</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">quadrupole_polvec</span><span class="p">(</span><span class="n">ef</span><span class="p">,</span> <span class="n">kf</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Have NOT implemented this type of transition operators&quot;</span><span class="p">)</span>
                <span class="n">trans_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">trans_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">):</span>
                    <span class="n">trans_i</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">trans_mat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">polvec_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">write_emat</span><span class="p">(</span><span class="n">trans_i</span><span class="p">,</span> <span class="s1">&#39;transop_rixs_i.in&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">):</span>
                    <span class="n">trans_f</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">trans_mat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">polvec_f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">write_emat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">trans_f</span><span class="p">)),</span> <span class="s1">&#39;transop_rixs_f.in&#39;</span><span class="p">)</span>

            <span class="c1"># call RIXS solver in fedrixs</span>
            <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
            <span class="n">rixs_fsolver</span><span class="p">(</span><span class="n">fcomm</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>

            <span class="n">file_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rixs_poles.&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_gs</span><span class="p">)]</span>
            <span class="n">pole_dict</span> <span class="o">=</span> <span class="n">read_poles_from_file</span><span class="p">(</span><span class="n">file_list</span><span class="p">)</span>
            <span class="n">poles_per_om</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pole_dict</span><span class="p">)</span>
            <span class="n">rixs</span><span class="p">[</span><span class="n">iom</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ip</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_spectra_from_poles</span><span class="p">(</span><span class="n">pole_dict</span><span class="p">,</span> <span class="n">eloss</span><span class="p">,</span>
                                                      <span class="n">gamma_final</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>

        <span class="n">poles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poles_per_om</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rixs</span><span class="p">,</span> <span class="n">poles</span>


<div class="viewcode-block" id="ed_siam_fort"><a class="viewcode-back" href="../../reference/solvers.html#edrixs.solvers.ed_siam_fort">[docs]</a><span class="k">def</span> <span class="nf">ed_siam_fort</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">shell_name</span><span class="p">,</span> <span class="n">nbath</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">siam_type</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">v_noccu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">static_core_pot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">c_soc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trans_c2n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">imp_mat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">imp_mat_n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bath_level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">bath_level_n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hyb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hyb_n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hopping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hopping_n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">slater</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ext_B</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">on_which</span><span class="o">=</span><span class="s1">&#39;spin&#39;</span><span class="p">,</span> <span class="n">do_ed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ed_solver</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">nvector</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">idump</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">eigval_tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">min_ndim</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the ground state of the initial Hamiltonian of a Single Impuirty Anderson Model (SIAM),</span>
<span class="sd">    and also prepare input files, *hopping_i.in*, *hopping_n.in*, *coulomb_i.in*, *coulomb_n.in*</span>
<span class="sd">    for following XAS and RIXS calculations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    comm: MPI_Comm</span>
<span class="sd">        MPI Communicator</span>
<span class="sd">    shell_name: tuple of two strings</span>
<span class="sd">        Names of valence and core shells. The 1st (2nd) string in the tuple is for the</span>
<span class="sd">        valence (core) shell.</span>

<span class="sd">        - The 1st string can only be &#39;s&#39;, &#39;p&#39;, &#39;t2g&#39;, &#39;d&#39;, &#39;f&#39;,</span>

<span class="sd">        - The 2nd string can be &#39;s&#39;, &#39;p&#39;, &#39;p12&#39;, &#39;p32&#39;, &#39;d&#39;, &#39;d32&#39;, &#39;d52&#39;,</span>
<span class="sd">          &#39;f&#39;, &#39;f52&#39;, &#39;f72&#39;.</span>

<span class="sd">        For example: shell_name=(&#39;d&#39;, &#39;p32&#39;) indicates a :math:`L_3` edge transition from</span>
<span class="sd">        core :math:`p_{3/2}` shell to valence :math:`d` shell.</span>
<span class="sd">    nbath: int</span>
<span class="sd">        Number of bath sites.</span>
<span class="sd">    siam_type: int</span>
<span class="sd">        Type of SIAM Hamiltonian,</span>

<span class="sd">        - 0: diagonal hybridization function, parameterized by *imp_mat*, *bath_level* and *hyb*</span>

<span class="sd">        - 1: general hybridization function, parameterized by matrix *hopping*</span>

<span class="sd">        if *siam_type=0*, only *imp_mat*, *bath_level* and *hyb* are required,</span>
<span class="sd">        if *siam_type=1*, only *hopping* is required.</span>
<span class="sd">    v_noccu: int</span>
<span class="sd">        Number of total occupancy of impurity and baths orbitals, required when do_ed=1, 2</span>
<span class="sd">    static_core_pot: float</span>
<span class="sd">        Static core hole potential.</span>
<span class="sd">    c_level: float</span>
<span class="sd">        Energy level of core shell.</span>
<span class="sd">    c_soc: float</span>
<span class="sd">        Spin-orbit coupling strength of core electrons.</span>
<span class="sd">    trans_c2n: 2d complex array</span>
<span class="sd">        The transformation matrix from the spherical harmonics basis to the basis on which</span>
<span class="sd">        the `imp_mat` and hybridization function (`bath_level`, `hyb`, `hopping`) are defined.</span>
<span class="sd">    imp_mat: 2d complex array</span>
<span class="sd">        Impurity matrix for the impurity site, including CF or SOC, for siam_type=0</span>
<span class="sd">        and the initial configurations.</span>
<span class="sd">    imp_mat_n: 2d complex array</span>
<span class="sd">        Impurity matrix for the impurity site, including CF or SOC, for siam_type=0</span>
<span class="sd">        and the intermediate configurations. If imp_mat_n=None, imp_mat will be used.</span>
<span class="sd">    bath_level: 2d complex array</span>
<span class="sd">        Energy level of bath sites, 1st (2nd) dimension is for different bath sites (orbitals),</span>
<span class="sd">        for siam_type=0 and the initial configurations.</span>
<span class="sd">    bath_level_n: 2d complex array</span>
<span class="sd">        Energy level of bath sites, 1st (2nd) dimension is for different bath sites (orbitals),</span>
<span class="sd">        for siam_type=0 and the intermediate configurations. If bath_level_n=None,</span>
<span class="sd">        bath_level will be used.</span>
<span class="sd">    hyb: 2d complex array</span>
<span class="sd">        Hybridization strength of bath sites, 1st (2nd) dimension is for different bath</span>
<span class="sd">        sites (orbitals), for siam_type=0 and the initial configurations.</span>
<span class="sd">    hyb_n: 2d complex array</span>
<span class="sd">        Hybridization strength of bath sites, 1st (2nd) dimension is for different bath</span>
<span class="sd">        sites (orbitals), for siam_type=0 and the intermediate configurations.</span>
<span class="sd">        If hyb_n=None, hyb will be used.</span>
<span class="sd">    hopping: 2d complex array</span>
<span class="sd">        General hopping matrix when siam_type=1, including imp_mat and hybridization functions,</span>
<span class="sd">        for siam_type=1 and the initial configurations.</span>
<span class="sd">    hopping_n: 2d complex array</span>
<span class="sd">        General hopping matrix when siam_type=1, including imp_mat and hybridization functions,</span>
<span class="sd">        for siam_type=1 and the intermediate configurations. If hopping_n=None,</span>
<span class="sd">        hopping will be used.</span>
<span class="sd">    slater: tuple of two lists</span>
<span class="sd">        Slater integrals for initial (1st list) and intermediate (2nd list) Hamiltonians.</span>
<span class="sd">        The order of the elements in each list should be like this:</span>

<span class="sd">        [FX_vv, FX_vc, GX_vc, FX_cc],</span>

<span class="sd">        where X are integers with ascending order, it can be X=0, 2, 4, 6 or X=1, 3, 5.</span>
<span class="sd">        One can ignore all the continuous zeros at the end of the list.</span>

<span class="sd">        For example, if the full list is: [F0_dd, F2_dd, F4_dd, 0, F2_dp, 0, 0, 0, 0], one can</span>
<span class="sd">        just provide [F0_dd, F2_dd, F4_dd, 0, F2_dp]</span>

<span class="sd">        All the Slater integrals will be set to zero if slater=None.</span>
<span class="sd">    ext_B: tuple of three float numbers</span>
<span class="sd">        Vector of external magnetic field with respect to global :math:`xyz`-axis.</span>

<span class="sd">        They will be set to zero if not provided.</span>
<span class="sd">    on_which: string</span>
<span class="sd">        Apply Zeeman exchange field on which sector. Options are &#39;spin&#39;, &#39;orbital&#39; or &#39;both&#39;.</span>
<span class="sd">    do_ed: int</span>
<span class="sd">        - 0: First, search the ground state in different subspaces of total occupancy</span>
<span class="sd">          :math:`N` with ed_solver=1, and then do a more accurate ED in the subspace</span>
<span class="sd">          :math:`N` where the ground state lies to find a few lowest eigenstates, return</span>
<span class="sd">          the eigenvalues and density matirx, and write the eigenvectors in files eigvec.n</span>

<span class="sd">        - 1: Only do ED for given occupancy number *v_noccu*, return eigenvalues and</span>
<span class="sd">          density matrix, write eigenvectors to files eigvec.n</span>

<span class="sd">        - 2: Do not do ED, only write parameters into files: *hopping_i.in*, *hopping_n.in*,</span>
<span class="sd">          *coulomb_i.in*, *coulomb_n.in* for later XAS or RIXS calculations.</span>
<span class="sd">    ed_solver: int</span>
<span class="sd">        Type of ED solver, options can be 0, 1, 2</span>

<span class="sd">        - 0: use Lapack to fully diagonalize Hamiltonian to get all the eigenvalues.</span>

<span class="sd">        - 1: use standard Lanczos algorithm to find only a few lowest eigenvalues,</span>
<span class="sd">          no re-orthogonalization has been applied, so it is not very accurate.</span>

<span class="sd">        - 2: use parallel version of Arpack library to find a few lowest eigenvalues,</span>
<span class="sd">          it is accurate and is the recommeded choice in real calculations of XAS and RIXS.</span>
<span class="sd">    neval: int</span>
<span class="sd">        Number of eigenvalues to be found. For ed_solver=2, the value should not be too small,</span>
<span class="sd">        neval &gt; 10 is usually a safe value.</span>
<span class="sd">    nvector: int</span>
<span class="sd">        Number of eigenvectors to be found and written into files.</span>
<span class="sd">    ncv: int</span>
<span class="sd">        Used for ed_solver=2, it should be at least ncv &gt; neval + 2. Usually, set it a little</span>
<span class="sd">        bit larger than neval, for example, set ncv=200 when neval=100.</span>
<span class="sd">    idump: logical</span>
<span class="sd">        Whether to dump the eigenvectors to files &quot;eigvec.n&quot;, where n means the n-th vectors.</span>
<span class="sd">    maxiter: int</span>
<span class="sd">        Maximum number of iterations in finding all the eigenvalues, used for ed_solver=1, 2.</span>
<span class="sd">    eigval_tol: float</span>
<span class="sd">        The convergence criteria of eigenvalues, used for ed_solver=1, 2.</span>
<span class="sd">    min_ndim: int</span>
<span class="sd">        The minimum dimension of the Hamiltonian when the ed_solver=1, 2 can be used, otherwise,</span>
<span class="sd">        ed_solver=1 will be used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eval_i: 1d float array</span>
<span class="sd">        Eigenvalues of initial Hamiltonian.</span>
<span class="sd">    denmat: 2d complex array</span>
<span class="sd">        Density matrix.</span>
<span class="sd">    noccu_gs: int</span>
<span class="sd">        Occupancy of the ground state.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.fedrixs</span> <span class="kn">import</span> <span class="n">ed_fsolver</span>

    <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
    <span class="n">fcomm</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">py2f</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Running ED ...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">v_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]</span>
    <span class="n">c_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p12&#39;</span><span class="p">,</span> <span class="s1">&#39;p32&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;d32&#39;</span><span class="p">,</span> <span class="s1">&#39;d52&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;f52&#39;</span><span class="p">,</span> <span class="s1">&#39;f72&#39;</span><span class="p">]</span>
    <span class="n">v_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">c_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">v_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of valence shell: &quot;</span><span class="p">,</span> <span class="n">v_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of core shell: &quot;</span><span class="p">,</span> <span class="n">c_name</span><span class="p">)</span>

    <span class="n">info_shell</span> <span class="o">=</span> <span class="n">info_atomic_shell</span><span class="p">()</span>
    <span class="n">v_orbl</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">v_name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">v_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">v_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">c_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">c_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ntot_v</span> <span class="o">=</span> <span class="n">v_norb</span> <span class="o">*</span> <span class="p">(</span><span class="n">nbath</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ntot</span> <span class="o">=</span> <span class="n">ntot_v</span> <span class="o">+</span> <span class="n">c_norb</span>

    <span class="n">slater_name</span> <span class="o">=</span> <span class="n">slater_integrals_name</span><span class="p">((</span><span class="n">v_name</span><span class="p">,</span> <span class="n">c_name</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">))</span>
    <span class="n">nslat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">slater_name</span><span class="p">)</span>
    <span class="n">slater_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nslat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">slater_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nslat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">slater</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nslat</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">slater</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">slater_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">slater</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">slater</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slater_i</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">slater</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">nslat</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nslat</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">slater</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">slater_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">slater</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">slater</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slater_n</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">slater</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">nslat</span><span class="p">]</span>

    <span class="c1"># print summary of slater integrals</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Summary of Slater integrals:&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ------------------------------&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Terms,  Initial Hamiltonian,  Intermediate Hamiltonian&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nslat</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;    &quot;</span><span class="p">,</span> <span class="n">slater_name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="s2">&quot;:  </span><span class="si">{:20.10f}{:20.10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">slater_i</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">slater_n</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">umat_tmp_i</span> <span class="o">=</span> <span class="n">get_umat_slater</span><span class="p">(</span><span class="n">v_name</span> <span class="o">+</span> <span class="n">c_name</span><span class="p">,</span> <span class="o">*</span><span class="n">slater_i</span><span class="p">)</span>
    <span class="n">umat_tmp_n</span> <span class="o">=</span> <span class="n">get_umat_slater</span><span class="p">(</span><span class="n">v_name</span> <span class="o">+</span> <span class="n">c_name</span><span class="p">,</span> <span class="o">*</span><span class="n">slater_n</span><span class="p">)</span>

    <span class="n">umat_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">umat_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="n">indx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v_norb</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="n">ntot_v</span> <span class="o">+</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c_norb</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v_norb</span><span class="o">+</span><span class="n">c_norb</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v_norb</span><span class="o">+</span><span class="n">c_norb</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v_norb</span><span class="o">+</span><span class="n">c_norb</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v_norb</span><span class="o">+</span><span class="n">c_norb</span><span class="p">):</span>
                    <span class="n">umat_i</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indx</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">indx</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">indx</span><span class="p">[</span><span class="n">m</span><span class="p">]]</span> <span class="o">=</span> <span class="n">umat_tmp_i</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>
                    <span class="n">umat_n</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indx</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">indx</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">indx</span><span class="p">[</span><span class="n">m</span><span class="p">]]</span> <span class="o">=</span> <span class="n">umat_tmp_n</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">write_umat</span><span class="p">(</span><span class="n">umat_i</span><span class="p">,</span> <span class="s1">&#39;coulomb_i.in&#39;</span><span class="p">)</span>
        <span class="n">write_umat</span><span class="p">(</span><span class="n">umat_n</span><span class="p">,</span> <span class="s1">&#39;coulomb_n.in&#39;</span><span class="p">)</span>

    <span class="n">emat_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">emat_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="c1"># General hybridization function, including off-diagonal terms</span>
    <span class="k">if</span> <span class="n">siam_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">hopping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ntot_v</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ntot_v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hopping</span>
        <span class="k">if</span> <span class="n">hopping_n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ntot_v</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ntot_v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hopping_n</span>
        <span class="k">elif</span> <span class="n">hopping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ntot_v</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ntot_v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hopping</span>
    <span class="c1"># Diagonal hybridization function</span>
    <span class="k">elif</span> <span class="n">siam_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># matrix (CF or SOC) for impuirty site</span>
        <span class="k">if</span> <span class="n">imp_mat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">imp_mat</span>
        <span class="k">if</span> <span class="n">imp_mat_n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">imp_mat_n</span>
        <span class="k">elif</span> <span class="n">imp_mat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">imp_mat</span>
        <span class="c1"># bath levels</span>
        <span class="k">if</span> <span class="n">bath_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbath</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v_norb</span><span class="p">):</span>
                    <span class="n">indx</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_norb</span> <span class="o">+</span> <span class="n">j</span>
                    <span class="n">emat_i</span><span class="p">[</span><span class="n">indx</span><span class="p">,</span> <span class="n">indx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bath_level</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bath_level_n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbath</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v_norb</span><span class="p">):</span>
                    <span class="n">indx</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_norb</span> <span class="o">+</span> <span class="n">j</span>
                    <span class="n">emat_n</span><span class="p">[</span><span class="n">indx</span><span class="p">,</span> <span class="n">indx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bath_level_n</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">bath_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbath</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v_norb</span><span class="p">):</span>
                    <span class="n">indx</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_norb</span> <span class="o">+</span> <span class="n">j</span>
                    <span class="n">emat_n</span><span class="p">[</span><span class="n">indx</span><span class="p">,</span> <span class="n">indx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bath_level</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">hyb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbath</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v_norb</span><span class="p">):</span>
                    <span class="n">indx1</span><span class="p">,</span> <span class="n">indx2</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_norb</span> <span class="o">+</span> <span class="n">j</span>
                    <span class="n">emat_i</span><span class="p">[</span><span class="n">indx1</span><span class="p">,</span> <span class="n">indx2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hyb</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">emat_i</span><span class="p">[</span><span class="n">indx2</span><span class="p">,</span> <span class="n">indx1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">hyb</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">hyb_n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbath</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v_norb</span><span class="p">):</span>
                    <span class="n">indx1</span><span class="p">,</span> <span class="n">indx2</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_norb</span> <span class="o">+</span> <span class="n">j</span>
                    <span class="n">emat_n</span><span class="p">[</span><span class="n">indx1</span><span class="p">,</span> <span class="n">indx2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hyb_n</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">emat_n</span><span class="p">[</span><span class="n">indx2</span><span class="p">,</span> <span class="n">indx1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">hyb_n</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">hyb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbath</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v_norb</span><span class="p">):</span>
                    <span class="n">indx1</span><span class="p">,</span> <span class="n">indx2</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v_norb</span> <span class="o">+</span> <span class="n">j</span>
                    <span class="n">emat_n</span><span class="p">[</span><span class="n">indx1</span><span class="p">,</span> <span class="n">indx2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hyb</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">emat_n</span><span class="p">[</span><span class="n">indx2</span><span class="p">,</span> <span class="n">indx1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">hyb</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown siam_type: &quot;</span><span class="p">,</span> <span class="n">siam_type</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">c_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]:</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="n">ntot_v</span><span class="p">:</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot_v</span><span class="p">:</span><span class="n">ntot</span><span class="p">]</span> <span class="o">+=</span> <span class="n">atom_hsoc</span><span class="p">(</span><span class="n">c_name</span><span class="p">,</span> <span class="n">c_soc</span><span class="p">)</span>

    <span class="c1"># static core potential</span>
    <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">v_norb</span><span class="p">)</span> <span class="o">*</span> <span class="n">static_core_pot</span>

    <span class="k">if</span> <span class="n">trans_c2n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">trans_c2n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">v_norb</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trans_c2n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trans_c2n</span><span class="p">)</span>

    <span class="n">tmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">ntot</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbath</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">off</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">v_norb</span>
        <span class="n">tmat</span><span class="p">[</span><span class="n">off</span><span class="p">:</span><span class="n">off</span><span class="o">+</span><span class="n">v_norb</span><span class="p">,</span> <span class="n">off</span><span class="p">:</span><span class="n">off</span><span class="o">+</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">trans_c2n</span><span class="p">))</span>
    <span class="n">emat_i</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cb_op</span><span class="p">(</span><span class="n">emat_i</span><span class="p">,</span> <span class="n">tmat</span><span class="p">)</span>
    <span class="n">emat_n</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cb_op</span><span class="p">(</span><span class="n">emat_n</span><span class="p">,</span> <span class="n">tmat</span><span class="p">)</span>

    <span class="c1"># zeeman field</span>
    <span class="k">if</span> <span class="n">v_name</span> <span class="o">==</span> <span class="s1">&#39;t2g&#39;</span><span class="p">:</span>
        <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">lz</span> <span class="o">=</span> <span class="n">get_lx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">get_ly</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">get_lz</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">get_sx</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">get_sy</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">get_sz</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">lz</span> <span class="o">=</span> <span class="o">-</span><span class="n">lx</span><span class="p">,</span> <span class="o">-</span><span class="n">ly</span><span class="p">,</span> <span class="o">-</span><span class="n">lz</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">lz</span> <span class="o">=</span> <span class="n">get_lx</span><span class="p">(</span><span class="n">v_orbl</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">get_ly</span><span class="p">(</span><span class="n">v_orbl</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">get_lz</span><span class="p">(</span><span class="n">v_orbl</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">get_sx</span><span class="p">(</span><span class="n">v_orbl</span><span class="p">),</span> <span class="n">get_sy</span><span class="p">(</span><span class="n">v_orbl</span><span class="p">),</span> <span class="n">get_sz</span><span class="p">(</span><span class="n">v_orbl</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ext_B</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">on_which</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;spin&#39;</span><span class="p">:</span>
            <span class="n">zeeman</span> <span class="o">=</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sx</span><span class="p">)</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sy</span><span class="p">)</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">on_which</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;orbital&#39;</span><span class="p">:</span>
            <span class="n">zeeman</span> <span class="o">=</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">lx</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ly</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">lz</span>
        <span class="k">elif</span> <span class="n">on_which</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">zeeman</span> <span class="o">=</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">lx</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sx</span><span class="p">)</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ly</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sy</span><span class="p">)</span> <span class="o">+</span> <span class="n">ext_B</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">lz</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown value of on_which&quot;</span><span class="p">,</span> <span class="n">on_which</span><span class="p">)</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">zeeman</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">]</span> <span class="o">+=</span> <span class="n">zeeman</span>

    <span class="c1"># Perform ED if necessary</span>
    <span class="k">if</span> <span class="n">do_ed</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">do_ed</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">eval_shift</span> <span class="o">=</span> <span class="n">c_level</span> <span class="o">*</span> <span class="n">c_norb</span> <span class="o">/</span> <span class="n">v_noccu</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ntot_v</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ntot_v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">ntot_v</span><span class="p">)</span> <span class="o">*</span> <span class="n">eval_shift</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="n">ntot_v</span><span class="p">:</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot_v</span><span class="p">:</span><span class="n">ntot</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">c_norb</span><span class="p">)</span> <span class="o">*</span> <span class="n">c_level</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">write_emat</span><span class="p">(</span><span class="n">emat_i</span><span class="p">,</span> <span class="s1">&#39;hopping_i.in&#39;</span><span class="p">)</span>
            <span class="n">write_emat</span><span class="p">(</span><span class="n">emat_n</span><span class="p">,</span> <span class="s1">&#39;hopping_n.in&#39;</span><span class="p">)</span>
            <span class="n">write_config</span><span class="p">(</span>
                <span class="n">ed_solver</span><span class="o">=</span><span class="n">ed_solver</span><span class="p">,</span> <span class="n">num_val_orbs</span><span class="o">=</span><span class="n">ntot_v</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="n">neval</span><span class="p">,</span> <span class="n">nvector</span><span class="o">=</span><span class="n">nvector</span><span class="p">,</span> <span class="n">ncv</span><span class="o">=</span><span class="n">ncv</span><span class="p">,</span>
                <span class="n">idump</span><span class="o">=</span><span class="n">idump</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">min_ndim</span><span class="o">=</span><span class="n">min_ndim</span><span class="p">,</span> <span class="n">eigval_tol</span><span class="o">=</span><span class="n">eigval_tol</span>
            <span class="p">)</span>
            <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">ntot_v</span><span class="p">,</span> <span class="n">v_noccu</span><span class="p">,</span> <span class="s2">&quot;fock_i.in&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">do_ed</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; do_ed=1, perform ED at noccu: &quot;</span><span class="p">,</span> <span class="n">v_noccu</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
            <span class="n">ed_fsolver</span><span class="p">(</span><span class="n">fcomm</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;eigvals.dat&#39;</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">eval_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">neval</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">eval_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">neval</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">neval</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;denmat.dat&#39;</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">nvector</span><span class="p">,</span> <span class="n">ntot_v</span><span class="p">,</span> <span class="n">ntot_v</span><span class="p">)</span>
            <span class="n">denmat</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">eval_i</span><span class="p">,</span> <span class="n">denmat</span><span class="p">,</span> <span class="n">v_noccu</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; do_ed=2, Do not perform ED, only write files&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1"># Find the ground states by total occupancy N</span>
    <span class="k">elif</span> <span class="n">do_ed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; do_ed=0, serach ground state by total occupancy N&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">flog</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;search_gs.log&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">write_emat</span><span class="p">(</span><span class="n">emat_i</span><span class="p">,</span> <span class="s1">&#39;hopping_i.in&#39;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">num_electron</span> <span class="o">=</span> <span class="n">ntot_v</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">noccu_gs</span> <span class="o">=</span> <span class="n">num_electron</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">write_config</span><span class="p">(</span>
                <span class="n">ed_solver</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_val_orbs</span><span class="o">=</span><span class="n">ntot_v</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nvector</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">idump</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">min_ndim</span><span class="o">=</span><span class="n">min_ndim</span><span class="p">,</span> <span class="n">eigval_tol</span><span class="o">=</span><span class="n">eigval_tol</span>
            <span class="p">)</span>
            <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">ntot_v</span><span class="p">,</span> <span class="n">num_electron</span><span class="p">,</span> <span class="s2">&quot;fock_i.in&quot;</span><span class="p">)</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
        <span class="n">ed_fsolver</span><span class="p">(</span><span class="n">fcomm</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;eigvals.dat&#39;</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">eval_gs</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;denmat.dat&#39;</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ntot_v</span><span class="p">,</span> <span class="n">ntot_v</span><span class="p">)</span>
        <span class="n">denmat</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="n">imp_occu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">denmat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">])</span><span class="o">.</span><span class="n">real</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">num_electron</span><span class="p">,</span> <span class="n">eval_gs</span><span class="p">,</span> <span class="n">imp_occu</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">num_electron</span><span class="p">,</span> <span class="n">eval_gs</span><span class="p">,</span> <span class="n">imp_occu</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">flog</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">nplus_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_electron</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntot_v</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="n">nminus_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_electron</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntot_v</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="n">nplus_direction</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">nminus_direction</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntot_v</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nplus_direction</span><span class="p">:</span>
                <span class="n">num_electron</span> <span class="o">=</span> <span class="n">nplus_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">ntot_v</span><span class="p">,</span> <span class="n">num_electron</span><span class="p">,</span> <span class="s2">&quot;fock_i.in&quot;</span><span class="p">)</span>
                <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
                <span class="n">ed_fsolver</span><span class="p">(</span><span class="n">fcomm</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
                <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;eigvals.dat&#39;</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">eigval</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">eigval</span> <span class="o">&gt;</span> <span class="n">eval_gs</span><span class="p">:</span>
                    <span class="n">nplus_direction</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nminus_direction</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">eval_gs</span> <span class="o">=</span> <span class="n">eigval</span>
                    <span class="n">noccu_gs</span> <span class="o">=</span> <span class="n">num_electron</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;denmat.dat&#39;</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ntot_v</span><span class="p">,</span> <span class="n">ntot_v</span><span class="p">)</span>
                <span class="n">denmat</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
                <span class="n">imp_occu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">denmat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">])</span><span class="o">.</span><span class="n">real</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">num_electron</span><span class="p">,</span> <span class="n">eigval</span><span class="p">,</span> <span class="n">imp_occu</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">num_electron</span><span class="p">,</span> <span class="n">eigval</span><span class="p">,</span> <span class="n">imp_occu</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">flog</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nminus_direction</span><span class="p">:</span>
                <span class="n">num_electron</span> <span class="o">=</span> <span class="n">nminus_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">ntot_v</span><span class="p">,</span> <span class="n">num_electron</span><span class="p">,</span> <span class="s2">&quot;fock_i.in&quot;</span><span class="p">)</span>
                <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
                <span class="n">ed_fsolver</span><span class="p">(</span><span class="n">fcomm</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
                <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;eigvals.dat&#39;</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">eigval</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">eigval</span> <span class="o">&gt;</span> <span class="n">eval_gs</span><span class="p">:</span>
                    <span class="n">nminus_direction</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nplus_direction</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">eval_gs</span> <span class="o">=</span> <span class="n">eigval</span>
                    <span class="n">noccu_gs</span> <span class="o">=</span> <span class="n">num_electron</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;denmat.dat&#39;</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ntot_v</span><span class="p">,</span> <span class="n">ntot_v</span><span class="p">)</span>
                <span class="n">denmat</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
                <span class="n">imp_occu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">denmat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">])</span><span class="o">.</span><span class="n">real</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">num_electron</span><span class="p">,</span> <span class="n">eigval</span><span class="p">,</span> <span class="n">imp_occu</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">num_electron</span><span class="p">,</span> <span class="n">eigval</span><span class="p">,</span> <span class="n">imp_occu</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">flog</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">flog</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;search_result.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:10d}{:20.10f}{:20.10f}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; do_ed=0, Perform ED at occupancy: &quot;</span><span class="p">,</span> <span class="n">noccu_gs</span><span class="p">,</span>
                  <span class="s2">&quot;with more accuracy&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Do ED for the occupancy of ground state with more accuracy</span>
        <span class="n">eval_shift</span> <span class="o">=</span> <span class="n">c_level</span> <span class="o">*</span> <span class="n">c_norb</span> <span class="o">/</span> <span class="n">noccu_gs</span>
        <span class="n">emat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ntot_v</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ntot_v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">ntot_v</span><span class="p">)</span> <span class="o">*</span> <span class="n">eval_shift</span>
        <span class="n">emat_n</span><span class="p">[</span><span class="n">ntot_v</span><span class="p">:</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot_v</span><span class="p">:</span><span class="n">ntot</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">c_norb</span><span class="p">)</span> <span class="o">*</span> <span class="n">c_level</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">write_emat</span><span class="p">(</span><span class="n">emat_i</span><span class="p">,</span> <span class="s1">&#39;hopping_i.in&#39;</span><span class="p">)</span>
            <span class="n">write_emat</span><span class="p">(</span><span class="n">emat_n</span><span class="p">,</span> <span class="s1">&#39;hopping_n.in&#39;</span><span class="p">)</span>
            <span class="n">write_config</span><span class="p">(</span>
                <span class="n">ed_solver</span><span class="o">=</span><span class="n">ed_solver</span><span class="p">,</span> <span class="n">num_val_orbs</span><span class="o">=</span><span class="n">ntot_v</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="n">neval</span><span class="p">,</span> <span class="n">nvector</span><span class="o">=</span><span class="n">nvector</span><span class="p">,</span> <span class="n">ncv</span><span class="o">=</span><span class="n">ncv</span><span class="p">,</span>
                <span class="n">idump</span><span class="o">=</span><span class="n">idump</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">min_ndim</span><span class="o">=</span><span class="n">min_ndim</span><span class="p">,</span> <span class="n">eigval_tol</span><span class="o">=</span><span class="n">eigval_tol</span>
            <span class="p">)</span>
            <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">ntot_v</span><span class="p">,</span> <span class="n">noccu_gs</span><span class="p">,</span> <span class="s2">&quot;fock_i.in&quot;</span><span class="p">)</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
        <span class="n">ed_fsolver</span><span class="p">(</span><span class="n">fcomm</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;eigvals.dat&#39;</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">eval_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">neval</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">eval_i</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">neval</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">neval</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;denmat.dat&#39;</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">nvector</span><span class="p">,</span> <span class="n">ntot_v</span><span class="p">,</span> <span class="n">ntot_v</span><span class="p">)</span>
        <span class="n">denmat</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eval_i</span><span class="p">,</span> <span class="n">denmat</span><span class="p">,</span> <span class="n">noccu_gs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown case of do_ed &quot;</span><span class="p">,</span> <span class="n">do_ed</span><span class="p">)</span></div>


<div class="viewcode-block" id="xas_siam_fort"><a class="viewcode-back" href="../../reference/solvers.html#edrixs.solvers.xas_siam_fort">[docs]</a><span class="k">def</span> <span class="nf">xas_siam_fort</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">shell_name</span><span class="p">,</span> <span class="n">nbath</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">gamma_c</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                  <span class="n">v_noccu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pol_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">num_gs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nkryl</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                  <span class="n">loc_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate XAS for single impurity Anderson model (SIAM) with Fortran solver.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    comm: MPI_comm</span>
<span class="sd">        MPI communicator.</span>
<span class="sd">    shell_name: tuple of two strings</span>
<span class="sd">        Names of valence and core shells. The 1st (2nd) string in the tuple is for the</span>
<span class="sd">        valence (core) shell.</span>

<span class="sd">        - The 1st string can only be &#39;s&#39;, &#39;p&#39;, &#39;t2g&#39;, &#39;d&#39;, &#39;f&#39;,</span>

<span class="sd">        - The 2nd string can be &#39;s&#39;, &#39;p&#39;, &#39;p12&#39;, &#39;p32&#39;, &#39;d&#39;, &#39;d32&#39;, &#39;d52&#39;,</span>
<span class="sd">          &#39;f&#39;, &#39;f52&#39;, &#39;f72&#39;.</span>

<span class="sd">        For example: shell_name=(&#39;d&#39;, &#39;p32&#39;) may indicate a :math:`L_3` edge transition from</span>
<span class="sd">        core :math:`2p_{3/2}` shell to valence :math:`3d` shell for Ni.</span>
<span class="sd">    nbath: int</span>
<span class="sd">        Number of bath sites.</span>
<span class="sd">    ominc: 1d float array</span>
<span class="sd">        Incident energy of photon.</span>
<span class="sd">    gamma_c: a float number or a 1d float array with the same shape as ominc.</span>
<span class="sd">        The core-hole life-time broadening factor. It can be a constant value</span>
<span class="sd">        or incident energy dependent.</span>
<span class="sd">    v_noccu: int</span>
<span class="sd">        Total occupancy of valence shells.</span>
<span class="sd">    thin: float number</span>
<span class="sd">        The incident angle of photon (in radian).</span>
<span class="sd">    phi: float number</span>
<span class="sd">        Azimuthal angle (in radian), defined with respect to the</span>
<span class="sd">        :math:`x`-axis of the local scattering axis: scatter_axis[:,0].</span>
<span class="sd">    pol_type: list of tuples</span>
<span class="sd">        Type of polarization, options can be:</span>

<span class="sd">        - (&#39;linear&#39;, alpha), linear polarization, where alpha is the angle between the</span>
<span class="sd">          polarization vector and the scattering plane in radians.</span>

<span class="sd">        - (&#39;left&#39;, 0), left circular polarization.</span>

<span class="sd">        - (&#39;right&#39;, 0), right circular polarization.</span>

<span class="sd">        - (&#39;isotropic&#39;, 0). isotropic polarization.</span>

<span class="sd">        It will set pol_type=[(&#39;isotropic&#39;, 0)] if not provided.</span>
<span class="sd">    num_gs: int</span>
<span class="sd">        Number of initial states used in XAS calculations.</span>
<span class="sd">    nkryl: int</span>
<span class="sd">        Maximum number of poles obtained.</span>
<span class="sd">    temperature: float number</span>
<span class="sd">        Temperature (in K) for boltzmann distribution.</span>
<span class="sd">    loc_axis: 3*3 float array</span>
<span class="sd">        The local axis with respect to which local orbitals are defined.</span>

<span class="sd">        - x: local_axis[:,0],</span>

<span class="sd">        - y: local_axis[:,1],</span>

<span class="sd">        - z: local_axis[:,2].</span>

<span class="sd">        It will be an identity matrix if not provided.</span>
<span class="sd">    scatter_axis: 3*3 float array</span>
<span class="sd">        The local axis defining the scattering geometry. The scattering plane is defined in</span>
<span class="sd">        the local :math:`zx`-plane.</span>

<span class="sd">        - local :math:`x`-axis: scatter_axis[:,0]</span>

<span class="sd">        - local :math:`y`-axis: scatter_axis[:,1]</span>

<span class="sd">        - local :math:`z`-axis: scatter_axis[:,2]</span>

<span class="sd">        It will be set to an identity matrix if not provided.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xas: 2d array, shape=(len(ominc), len(pol_type))</span>
<span class="sd">        The calculated XAS spectra. The first dimension is for ominc, and the second dimension</span>
<span class="sd">        if for different polarizations.</span>
<span class="sd">    poles: list of dict, shape=(len(pol_type), )</span>
<span class="sd">        The calculated XAS poles for different polarizations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.fedrixs</span> <span class="kn">import</span> <span class="n">xas_fsolver</span>

    <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
    <span class="n">fcomm</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">py2f</span><span class="p">()</span>

    <span class="n">v_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]</span>
    <span class="n">c_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p12&#39;</span><span class="p">,</span> <span class="s1">&#39;p32&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;d32&#39;</span><span class="p">,</span> <span class="s1">&#39;d52&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;f52&#39;</span><span class="p">,</span> <span class="s1">&#39;f72&#39;</span><span class="p">]</span>

    <span class="n">v_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">c_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">v_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of valence shell: &quot;</span><span class="p">,</span> <span class="n">v_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of core shell: &quot;</span><span class="p">,</span> <span class="n">c_name</span><span class="p">)</span>

    <span class="n">info_shell</span> <span class="o">=</span> <span class="n">info_atomic_shell</span><span class="p">()</span>
    <span class="n">v_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">v_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">c_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">c_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">ntot_v</span> <span class="o">=</span> <span class="n">v_norb</span> <span class="o">*</span> <span class="p">(</span><span class="n">nbath</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ntot</span> <span class="o">=</span> <span class="n">ntot_v</span> <span class="o">+</span> <span class="n">c_norb</span>
    <span class="k">if</span> <span class="n">pol_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pol_type</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;isotropic&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">loc_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">loc_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loc_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loc_axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scatter_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scatter_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scatter_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scatter_axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Running XAS ...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">write_config</span><span class="p">(</span><span class="n">num_val_orbs</span><span class="o">=</span><span class="n">ntot_v</span><span class="p">,</span> <span class="n">num_core_orbs</span><span class="o">=</span><span class="n">c_norb</span><span class="p">,</span>
                     <span class="n">num_gs</span><span class="o">=</span><span class="n">num_gs</span><span class="p">,</span> <span class="n">nkryl</span><span class="o">=</span><span class="n">nkryl</span><span class="p">)</span>
        <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">ntot_v</span><span class="p">,</span> <span class="n">v_noccu</span><span class="p">,</span> <span class="s2">&quot;fock_i.in&quot;</span><span class="p">)</span>
        <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">ntot_v</span><span class="p">,</span> <span class="n">v_noccu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;fock_n.in&quot;</span><span class="p">)</span>

    <span class="n">case</span> <span class="o">=</span> <span class="n">v_name</span> <span class="o">+</span> <span class="n">c_name</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">get_trans_oper</span><span class="p">(</span><span class="n">case</span><span class="p">)</span>
    <span class="n">npol</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">tmp_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npol</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">trans_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npol</span><span class="p">,</span> <span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="c1"># Transform the transition operators to global-xyz axis</span>
    <span class="c1"># dipolar transition</span>
    <span class="k">if</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">tmp_g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">loc_axis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="c1"># quadrupolar transition</span>
    <span class="k">elif</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">rmat_to_euler</span><span class="p">(</span><span class="n">loc_axis</span><span class="p">)</span>
        <span class="n">wignerD</span> <span class="o">=</span> <span class="n">get_wigner_dmat</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
        <span class="n">rotmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmat_r2c</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">wignerD</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tmat_r2c</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">))))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                <span class="n">tmp_g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rotmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Have NOT implemented this case: &quot;</span><span class="p">,</span> <span class="n">npol</span><span class="p">)</span>
    <span class="n">trans_mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="n">ntot_v</span><span class="p">:</span><span class="n">ntot</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_g</span>

    <span class="n">n_om</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ominc</span><span class="p">)</span>
    <span class="n">gamma_core</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_om</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">gamma_c</span><span class="p">):</span>
        <span class="n">gamma_core</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_om</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma_c</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gamma_core</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gamma_c</span>

    <span class="c1"># loop over different polarization</span>
    <span class="n">xas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_om</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pol_type</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">poles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">it</span><span class="p">,</span> <span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pol_type</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span> <span class="ow">or</span> <span class="n">pt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span> <span class="ow">or</span> <span class="n">pt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Loop over for polarization: &quot;</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">kvec</span> <span class="o">=</span> <span class="n">unit_wavevector</span><span class="p">(</span><span class="n">thin</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">)</span>
                <span class="n">polvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">pol</span> <span class="o">=</span> <span class="n">dipole_polvec_xas</span><span class="p">(</span><span class="n">thin</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Dipolar transition</span>
                    <span class="n">polvec</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">pol</span>
                <span class="k">if</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>  <span class="c1"># Quadrupolar transition</span>
                    <span class="n">polvec</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">quadrupole_polvec</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">kvec</span><span class="p">)</span>

                <span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">):</span>
                    <span class="n">trans</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">trans_mat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">polvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">write_emat</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s1">&#39;transop_xas.in&#39;</span><span class="p">)</span>

            <span class="c1"># call XAS solver in fedrixs</span>
            <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
            <span class="n">xas_fsolver</span><span class="p">(</span><span class="n">fcomm</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>

            <span class="n">file_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;xas_poles.&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_gs</span><span class="p">)]</span>
            <span class="n">pole_dict</span> <span class="o">=</span> <span class="n">read_poles_from_file</span><span class="p">(</span><span class="n">file_list</span><span class="p">)</span>
            <span class="n">poles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pole_dict</span><span class="p">)</span>
            <span class="n">xas</span><span class="p">[:,</span> <span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_spectra_from_poles</span><span class="p">(</span><span class="n">pole_dict</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="n">gamma_core</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;isotropic&#39;</span><span class="p">:</span>
            <span class="n">pole_dicts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Loop over for polarization: &quot;</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Isotropic, component: &quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">write_emat</span><span class="p">(</span><span class="n">trans_mat</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="s1">&#39;transop_xas.in&#39;</span><span class="p">)</span>

                <span class="c1"># call XAS solver in fedrixs</span>
                <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
                <span class="n">xas_fsolver</span><span class="p">(</span><span class="n">fcomm</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
                <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>

                <span class="n">file_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;xas_poles.&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_gs</span><span class="p">)]</span>
                <span class="n">pole_tmp</span> <span class="o">=</span> <span class="n">read_poles_from_file</span><span class="p">(</span><span class="n">file_list</span><span class="p">)</span>
                <span class="n">xas</span><span class="p">[:,</span> <span class="n">it</span><span class="p">]</span> <span class="o">+=</span> <span class="n">get_spectra_from_poles</span><span class="p">(</span><span class="n">pole_tmp</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="n">gamma_core</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>
                <span class="n">pole_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pole_tmp</span><span class="p">)</span>
            <span class="n">xas</span><span class="p">[:,</span> <span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="n">xas</span><span class="p">[:,</span> <span class="n">it</span><span class="p">]</span> <span class="o">/</span> <span class="n">npol</span>
            <span class="n">poles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merge_pole_dicts</span><span class="p">(</span><span class="n">pole_dicts</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown polarization type: &quot;</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xas</span><span class="p">,</span> <span class="n">poles</span></div>


<div class="viewcode-block" id="rixs_siam_fort"><a class="viewcode-back" href="../../reference/solvers.html#edrixs.solvers.rixs_siam_fort">[docs]</a><span class="k">def</span> <span class="nf">rixs_siam_fort</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">shell_name</span><span class="p">,</span> <span class="n">nbath</span><span class="p">,</span> <span class="n">ominc</span><span class="p">,</span> <span class="n">eloss</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">gamma_c</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">gamma_f</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                   <span class="n">v_noccu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">thout</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pol_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_gs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                   <span class="n">nkryl</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">linsys_max</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">linsys_tol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                   <span class="n">loc_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate RIXS for single impurity Anderson model with Fortran solver.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    comm: MPI_comm</span>
<span class="sd">        MPI communicator.</span>
<span class="sd">    shell_name: tuple of two strings</span>
<span class="sd">        Names of valence and core shells. The 1st (2nd) string in the tuple is for the</span>
<span class="sd">        valence (core) shell.</span>

<span class="sd">        - The 1st string can only be &#39;s&#39;, &#39;p&#39;, &#39;t2g&#39;, &#39;d&#39;, &#39;f&#39;,</span>

<span class="sd">        - The 2nd string can be &#39;s&#39;, &#39;p&#39;, &#39;p12&#39;, &#39;p32&#39;, &#39;d&#39;, &#39;d32&#39;, &#39;d52&#39;,</span>
<span class="sd">          &#39;f&#39;, &#39;f52&#39;, &#39;f72&#39;.</span>

<span class="sd">        For example: shell_name=(&#39;d&#39;, &#39;p32&#39;) may indicate a :math:`L_3` edge transition from</span>
<span class="sd">        core :math:`2p_{3/2}` shell to valence :math:`3d` shell for Ni.</span>
<span class="sd">    nbath: int</span>
<span class="sd">        Number of bath sites.</span>
<span class="sd">    ominc: 1d float array</span>
<span class="sd">        Incident energy of photon.</span>
<span class="sd">    eloss: 1d float array</span>
<span class="sd">        Energy loss.</span>
<span class="sd">    gamma_c: a float number or a 1d float array with same shape as ominc.</span>
<span class="sd">        The core-hole life-time broadening factor. It can be a constant value</span>
<span class="sd">        or incident energy dependent.</span>
<span class="sd">    gamma_f: a float number or a 1d float array with same shape as eloss.</span>
<span class="sd">        The final states life-time broadening factor. It can be a constant value</span>
<span class="sd">        or energy loss dependent.</span>
<span class="sd">    v_noccu: int</span>
<span class="sd">        Total occupancy of valence shells.</span>
<span class="sd">    thin: float number</span>
<span class="sd">        The incident angle of photon (in radian).</span>
<span class="sd">    thout: float number</span>
<span class="sd">        The scattered angle of photon (in radian).</span>
<span class="sd">    phi: float number</span>
<span class="sd">        Azimuthal angle (in radian), defined with respect to the</span>
<span class="sd">        :math:`x`-axis of scattering axis: scatter_axis[:,0].</span>
<span class="sd">    pol_type: list of 4-elements-tuples</span>
<span class="sd">        Type of polarizations. It has the following form:</span>

<span class="sd">        (str1, alpha, str2, beta)</span>

<span class="sd">        where, str1 (str2) can be &#39;linear&#39;, &#39;left&#39;, &#39;right&#39;, and alpha (beta) is</span>
<span class="sd">        the angle (in radians) between the linear polarization vector and the scattering plane.</span>

<span class="sd">        It will set pol_type=[(&#39;linear&#39;, 0, &#39;linear&#39;, 0)] if not provided.</span>
<span class="sd">    num_gs: int</span>
<span class="sd">        Number of initial states used in RIXS calculations.</span>
<span class="sd">    nkryl: int</span>
<span class="sd">        Maximum number of poles obtained.</span>
<span class="sd">    linsys_max: int</span>
<span class="sd">        Maximum iterations of solving linear equations.</span>
<span class="sd">    linsys_tol: float</span>
<span class="sd">        Convergence for solving linear equations.</span>
<span class="sd">    temperature: float number</span>
<span class="sd">        Temperature (in K) for boltzmann distribution.</span>
<span class="sd">    loc_axis: 3*3 float array</span>
<span class="sd">        The local axis with respect to which local orbitals are defined.</span>

<span class="sd">        - x: local_axis[:,0],</span>

<span class="sd">        - y: local_axis[:,1],</span>

<span class="sd">        - z: local_axis[:,2].</span>

<span class="sd">        It will be an identity matrix if not provided.</span>
<span class="sd">    scatter_axis: 3*3 float array</span>
<span class="sd">        The local axis defining the scattering geometry. The scattering plane is defined in</span>
<span class="sd">        the local :math:`zx`-plane.</span>

<span class="sd">        - local :math:`x`-axis: scatter_axis[:,0]</span>

<span class="sd">        - local :math:`y`-axis: scatter_axis[:,1]</span>

<span class="sd">        - local :math:`z`-axis: scatter_axis[:,2]</span>

<span class="sd">        It will be set to an identity matrix if not provided.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rixs: 3d float array, shape=(len(ominc), len(eloss), len(pol_type))</span>
<span class="sd">        The calculated RIXS spectra. The 1st dimension is for the incident energy,</span>
<span class="sd">        the 2nd dimension is for the energy loss and the 3rd dimension is for</span>
<span class="sd">        different polarizations.</span>
<span class="sd">    poles: 2d list of dict, shape=(len(ominc), len(pol_type))</span>
<span class="sd">        The calculated RIXS poles. The 1st dimension is for incident energy, and the</span>
<span class="sd">        2nd dimension is for different polarizations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.fedrixs</span> <span class="kn">import</span> <span class="n">rixs_fsolver</span>

    <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
    <span class="n">fcomm</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">py2f</span><span class="p">()</span>

    <span class="n">v_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]</span>
    <span class="n">c_name_options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p12&#39;</span><span class="p">,</span> <span class="s1">&#39;p32&#39;</span><span class="p">,</span> <span class="s1">&#39;t2g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;d32&#39;</span><span class="p">,</span> <span class="s1">&#39;d52&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;f52&#39;</span><span class="p">,</span> <span class="s1">&#39;f72&#39;</span><span class="p">]</span>
    <span class="n">v_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">c_name</span> <span class="o">=</span> <span class="n">shell_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">v_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of valence shell: &quot;</span><span class="p">,</span> <span class="n">v_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c_name_options</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;NOT supported type of core shell: &quot;</span><span class="p">,</span> <span class="n">c_name</span><span class="p">)</span>

    <span class="n">info_shell</span> <span class="o">=</span> <span class="n">info_atomic_shell</span><span class="p">()</span>
    <span class="n">v_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">v_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">c_norb</span> <span class="o">=</span> <span class="n">info_shell</span><span class="p">[</span><span class="n">c_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ntot_v</span> <span class="o">=</span> <span class="n">v_norb</span> <span class="o">*</span> <span class="p">(</span><span class="n">nbath</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ntot</span> <span class="o">=</span> <span class="n">ntot_v</span> <span class="o">+</span> <span class="n">c_norb</span>

    <span class="k">if</span> <span class="n">pol_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pol_type</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">loc_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">loc_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loc_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loc_axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scatter_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scatter_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scatter_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scatter_axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Running RIXS ...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">ntot_v</span><span class="p">,</span> <span class="n">v_noccu</span><span class="p">,</span> <span class="s2">&quot;fock_i.in&quot;</span><span class="p">)</span>
        <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">ntot_v</span><span class="p">,</span> <span class="n">v_noccu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;fock_n.in&quot;</span><span class="p">)</span>
        <span class="n">write_fock_dec_by_N</span><span class="p">(</span><span class="n">ntot_v</span><span class="p">,</span> <span class="n">v_noccu</span><span class="p">,</span> <span class="s2">&quot;fock_f.in&quot;</span><span class="p">)</span>

        <span class="n">case</span> <span class="o">=</span> <span class="n">v_name</span> <span class="o">+</span> <span class="n">c_name</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">get_trans_oper</span><span class="p">(</span><span class="n">case</span><span class="p">)</span>
        <span class="n">npol</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">tmp_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npol</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">trans_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npol</span><span class="p">,</span> <span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="c1"># Transform the transition operators to global-xyz axis</span>
        <span class="c1"># dipolar transition</span>
        <span class="k">if</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">tmp_g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">loc_axis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="c1"># quadrupolar transition</span>
        <span class="k">elif</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">rmat_to_euler</span><span class="p">(</span><span class="n">loc_axis</span><span class="p">)</span>
            <span class="n">wignerD</span> <span class="o">=</span> <span class="n">get_wigner_dmat</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
            <span class="n">rotmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmat_r2c</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">wignerD</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tmat_r2c</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">))))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                    <span class="n">tmp_g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rotmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Have NOT implemented this case: &quot;</span><span class="p">,</span> <span class="n">npol</span><span class="p">)</span>
        <span class="n">trans_mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">v_norb</span><span class="p">,</span> <span class="n">ntot_v</span><span class="p">:</span><span class="n">ntot</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_g</span>

    <span class="n">n_om</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ominc</span><span class="p">)</span>
    <span class="n">neloss</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eloss</span><span class="p">)</span>
    <span class="n">gamma_core</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_om</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">gamma_c</span><span class="p">):</span>
        <span class="n">gamma_core</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_om</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma_c</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gamma_core</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gamma_c</span>
    <span class="n">gamma_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">neloss</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">gamma_f</span><span class="p">):</span>
        <span class="n">gamma_final</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">neloss</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma_f</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gamma_final</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gamma_f</span>

    <span class="c1"># loop over different polarization</span>
    <span class="n">rixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_om</span><span class="p">,</span> <span class="n">neloss</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pol_type</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">poles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
    <span class="c1"># loop over different polarization</span>
    <span class="k">for</span> <span class="n">iom</span><span class="p">,</span> <span class="n">omega</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ominc</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">write_config</span><span class="p">(</span>
                <span class="n">num_val_orbs</span><span class="o">=</span><span class="n">ntot_v</span><span class="p">,</span> <span class="n">num_core_orbs</span><span class="o">=</span><span class="n">c_norb</span><span class="p">,</span>
                <span class="n">omega_in</span><span class="o">=</span><span class="n">omega</span><span class="p">,</span> <span class="n">gamma_in</span><span class="o">=</span><span class="n">gamma_core</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span>
                <span class="n">num_gs</span><span class="o">=</span><span class="n">num_gs</span><span class="p">,</span> <span class="n">nkryl</span><span class="o">=</span><span class="n">nkryl</span><span class="p">,</span> <span class="n">linsys_max</span><span class="o">=</span><span class="n">linsys_max</span><span class="p">,</span>
                <span class="n">linsys_tol</span><span class="o">=</span><span class="n">linsys_tol</span>
            <span class="p">)</span>
        <span class="n">poles_per_om</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># loop over polarization</span>
        <span class="k">for</span> <span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">jt</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pol_type</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Calculate RIXS for incident energy: &quot;</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edrixs &gt;&gt;&gt; Polarization: &quot;</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">polvec_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">polvec_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">ei</span><span class="p">,</span> <span class="n">ef</span> <span class="o">=</span> <span class="n">dipole_polvec_rixs</span><span class="p">(</span><span class="n">thin</span><span class="p">,</span> <span class="n">thout</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span>
                                            <span class="n">scatter_axis</span><span class="p">,</span> <span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">jt</span><span class="p">))</span>
                <span class="c1"># dipolar transition</span>
                <span class="k">if</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">polvec_i</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ei</span>
                    <span class="n">polvec_f</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ef</span>
                <span class="c1"># quadrupolar transition</span>
                <span class="k">elif</span> <span class="n">npol</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="n">ki</span> <span class="o">=</span> <span class="n">unit_wavevector</span><span class="p">(</span><span class="n">thin</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;in&#39;</span><span class="p">)</span>
                    <span class="n">kf</span> <span class="o">=</span> <span class="n">unit_wavevector</span><span class="p">(</span><span class="n">thout</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">scatter_axis</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)</span>
                    <span class="n">polvec_i</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">quadrupole_polvec</span><span class="p">(</span><span class="n">ei</span><span class="p">,</span> <span class="n">ki</span><span class="p">)</span>
                    <span class="n">polvec_f</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">quadrupole_polvec</span><span class="p">(</span><span class="n">ef</span><span class="p">,</span> <span class="n">kf</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Have NOT implemented this type of transition operators&quot;</span><span class="p">)</span>
                <span class="n">trans_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">trans_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntot</span><span class="p">,</span> <span class="n">ntot</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">):</span>
                    <span class="n">trans_i</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">trans_mat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">polvec_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">write_emat</span><span class="p">(</span><span class="n">trans_i</span><span class="p">,</span> <span class="s1">&#39;transop_rixs_i.in&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">):</span>
                    <span class="n">trans_f</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">trans_mat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">polvec_f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">write_emat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">trans_f</span><span class="p">)),</span> <span class="s1">&#39;transop_rixs_f.in&#39;</span><span class="p">)</span>

            <span class="c1"># call RIXS solver in fedrixs</span>
            <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
            <span class="n">rixs_fsolver</span><span class="p">(</span><span class="n">fcomm</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>

            <span class="n">file_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rixs_poles.&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_gs</span><span class="p">)]</span>
            <span class="n">pole_dict</span> <span class="o">=</span> <span class="n">read_poles_from_file</span><span class="p">(</span><span class="n">file_list</span><span class="p">)</span>
            <span class="n">poles_per_om</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pole_dict</span><span class="p">)</span>
            <span class="n">rixs</span><span class="p">[</span><span class="n">iom</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ip</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_spectra_from_poles</span><span class="p">(</span><span class="n">pole_dict</span><span class="p">,</span> <span class="n">eloss</span><span class="p">,</span>
                                                      <span class="n">gamma_final</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>

        <span class="n">poles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poles_per_om</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rixs</span><span class="p">,</span> <span class="n">poles</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, Brookhaven National Lab.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>