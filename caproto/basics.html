

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Writing Your Own Channel Access Client &mdash; caproto 0.5.2+0.g65eb636.dirty documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Core API Documentation" href="api.html" />
    <link rel="prev" title="Logging" href="loggers.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> caproto
          

          
          </a>

          
            
            
              <div class="version">
                0.5.2+0.g65eb636.dirty
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Install Caproto</a></li>
</ul>
<p class="caption"><span class="caption-text">EPICS Clients and Servers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="clients.html">Clients</a></li>
<li class="toctree-l1"><a class="reference internal" href="iocs.html">Input-Output Controllers (IOCs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l1"><a class="reference internal" href="servers.html">Servers</a></li>
<li class="toctree-l1"><a class="reference internal" href="shark.html">Shark (pcap/tcpdump parsing)</a></li>
<li class="toctree-l1"><a class="reference internal" href="loggers.html">Logging</a></li>
</ul>
<p class="caption"><span class="caption-text">Channel Access Sans I/O</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Writing Your Own Channel Access Client</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#channel-access-basics">Channel Access Basics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#registering-with-the-repeater">Registering with the Repeater</a></li>
<li class="toctree-l3"><a class="reference internal" href="#searching-for-a-channel">Searching for a Channel</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-a-channel">Creating a Channel</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reading-and-writing-values">Reading and Writing Values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#subscribing-to-events-updates">Subscribing to “Events” (Updates)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#closing-the-channel">Closing the Channel</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#simplify-bookkeeping-with-channels">Simplify Bookkeeping with Channels</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">Core API Documentation</a></li>
</ul>
<p class="caption"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://nsls-ii.github.io/caproto/bench/#/">Performance Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="protocol-compliance.html">Details of our Protocol Compliance for CA Nerds</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-notes.html">Release History</a></li>
<li class="toctree-l1"><a class="reference internal" href="containers.html">Caproto-in-a-box</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">caproto</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Writing Your Own Channel Access Client</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/basics.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="writing-your-own-channel-access-client">
<h1>Writing Your Own Channel Access Client<a class="headerlink" href="#writing-your-own-channel-access-client" title="Permalink to this headline">¶</a></h1>
<p>Caproto can be used to implement both Channel Access clients and servers. To
give a flavor for how the API works, we’ll demonstrate a simple, synchronous
client.</p>
<div class="section" id="channel-access-basics">
<h2>Channel Access Basics<a class="headerlink" href="#channel-access-basics" title="Permalink to this headline">¶</a></h2>
<p>A Channel Access client reads and writes values to <em>Channels</em> available from
servers on its network. It locates these servers using UDP broadcasts. It
communicates with an individual server via one or more TCP connections, which
it calls <em>Virtual Circuits</em>.</p>
<p>In this example, our client will talk to a example IOC provided by caproto,
but this same code could talk to any Channel Access server.</p>
<p>In a separate shell, start one of caproto’s demo IOCs.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ python3 -m caproto.ioc_examples.random_walk
PVs: <span class="o">[</span><span class="s1">&#39;random_walk:dt&#39;</span>, <span class="s1">&#39;random_walk:x&#39;</span><span class="o">]</span>
</pre></div>
</div>
<p>In a second separate shell, start a repeater process. You may see output like
this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ caproto-repeater
<span class="o">[</span>I <span class="m">18</span>:04:30.686 repeater:84<span class="o">]</span> Repeater is listening on <span class="m">0</span>.0.0.0:5065
</pre></div>
</div>
<p>or this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ caproto-repeater
<span class="o">[</span>I <span class="m">18</span>:04:08.790 repeater:189<span class="o">]</span> Another repeater is already running<span class="p">;</span> exiting.
</pre></div>
</div>
<p>Either is fine.</p>
<div class="section" id="registering-with-the-repeater">
<h3>Registering with the Repeater<a class="headerlink" href="#registering-with-the-repeater" title="Permalink to this headline">¶</a></h3>
<p>To begin, we need a socket configured for UDP broadcasting. Caproto provides a
convenient utility for doing this in a way that works on all platforms.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">caproto</span>

<span class="gp">In [2]: </span><span class="n">udp_sock</span> <span class="o">=</span> <span class="n">caproto</span><span class="o">.</span><span class="n">bcast_socket</span><span class="p">()</span>
</pre></div>
</div>
<p>A new Channel Access client is required to register itself with a Channel
Access <em>Repeater</em>.  (What a Repeater is <em>for</em> is not really important to our
story here. It’s an independent process that rebroadcasts incoming server
heartbeats to all clients on our host. It exists because old systems don’t
handle broadcasts properly.) To register, we must send a <em>request</em> to the
Repeater and receive a <em>response</em>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [3]: </span><span class="n">bytes_to_send</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00</span><span class="s1">&#39;</span>

<span class="gp">In [4]: </span><span class="n">udp_sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">bytes_to_send</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">5065</span><span class="p">))</span>
<span class="gh">Out[4]: </span><span class="go">16</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">data</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="n">udp_sock</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>

<span class="gp">In [6]: </span><span class="n">data</span>
<span class="gh">Out[6]: </span><span class="go">b&#39;\x00\x11\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x7f\x00\x00\x01&#39;</span>
</pre></div>
</div>
<p>Hurray it worked? Unless you can read Channel Access hex codes the way Neo
experiences the Matrix, you may want a better way. Caproto provides a higher
level of abstraction, <em>Commands</em>, so that we don’t need to work with raw bytes.
Let’s try this again using caproto.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Other sans-I/O libraries use the word <em>Event</em> for what we are calling a
<em>Command</em>. “Event” is an overloaded term in Channel Access, so we’re going
our own way here.</p>
</div>
<p>As above, create a fresh UDP socket configured for broadcasting.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [7]: </span><span class="kn">import</span> <span class="nn">caproto</span>

<span class="gp">In [8]: </span><span class="n">udp_sock</span> <span class="o">=</span> <span class="n">caproto</span><span class="o">.</span><span class="n">bcast_socket</span><span class="p">()</span>
</pre></div>
</div>
<p>Instantiate a caproto <a class="reference internal" href="api.html#caproto.Broadcaster" title="caproto.Broadcaster"><code class="xref py py-class docutils literal notranslate"><span class="pre">Broadcaster</span></code></a> and a command to broadcast — a
<a class="reference internal" href="api.html#caproto.RepeaterRegisterRequest" title="caproto.RepeaterRegisterRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">RepeaterRegisterRequest</span></code></a>.`</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [9]: </span><span class="n">b</span> <span class="o">=</span> <span class="n">caproto</span><span class="o">.</span><span class="n">Broadcaster</span><span class="p">(</span><span class="n">our_role</span><span class="o">=</span><span class="n">caproto</span><span class="o">.</span><span class="n">CLIENT</span><span class="p">)</span>

<span class="gp">In [10]: </span><span class="n">command</span> <span class="o">=</span> <span class="n">caproto</span><span class="o">.</span><span class="n">RepeaterRegisterRequest</span><span class="p">(</span><span class="s1">&#39;0.0.0.0&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Pass the command to our broadcaster’s <a class="reference internal" href="api.html#caproto.Broadcaster.send" title="caproto.Broadcaster.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Broadcaster.send()</span></code></a> method, which
does two things. It translates command objects into bytes, and it checks
them against the rules of the Channel Access protocol. The rules are encoded in
the Broadcaster’s internal state machine, which tracks the state of both the
client and the server. (It can serve as either.) If you try to send an illegal
command, it will raise <a class="reference internal" href="api.html#caproto.LocalProtocolError" title="caproto.LocalProtocolError"><code class="xref py py-class docutils literal notranslate"><span class="pre">LocalProtocolError</span></code></a>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [11]: </span><span class="n">bytes_to_send</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>

<span class="gp">In [12]: </span><span class="n">bytes_to_send</span>
<span class="gh">Out[12]: </span><span class="go">b&#39;\x00\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;</span>
</pre></div>
</div>
<p>Transport those bytes over the wire, using the same <code class="docutils literal notranslate"><span class="pre">udp_sock</span></code> we configured
above.  A quick comparison will show that these bytes are the same bytes we
spelled out manually before.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [13]: </span><span class="n">udp_sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">bytes_to_send</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">5065</span><span class="p">))</span>
<span class="gh">Out[13]: </span><span class="go">16</span>
</pre></div>
</div>
<p>Why do we need two steps here? Why doesn’t caproto just send the bytes for us?
Because it’s designed to support any socket API you might want to use —
synchronous (like this example), asynchronous, etc. Caproto does not care how
or when you send and receive the bytes. Its job is to make it easier to
compose outgoing messages, interpret incoming ones, and verify that the rules
of the protocol are obeyed by both peers.</p>
<p>Recall that we are in the process of registering our client with a Channel
Access Repeater and that we are expecting a response. As with sending,
receiving is a two-step process. First we read bytes from the socket and pass
them to the broadcaster.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [14]: </span><span class="n">bytes_received</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="n">udp_sock</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>

<span class="gp">In [15]: </span><span class="n">commands</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">bytes_received</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
</pre></div>
</div>
<p>The bytes have been parsed into command objects. Next, check them against the
Channel Access protocol.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [16]: </span><span class="n">b</span><span class="o">.</span><span class="n">process_commands</span><span class="p">(</span><span class="n">commands</span><span class="p">)</span>
</pre></div>
</div>
<p>When we call <a class="reference internal" href="api.html#caproto.Broadcaster.process_commands" title="caproto.Broadcaster.process_commands"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Broadcaster.process_commands()</span></code></a>, the Broadcaster does the
same thing is did for <a class="reference internal" href="api.html#caproto.Broadcaster.send" title="caproto.Broadcaster.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Broadcaster.send()</span></code></a> in reverse: if one of the
received commands is illegal, it raises <a class="reference internal" href="api.html#caproto.RemoteProtocolError" title="caproto.RemoteProtocolError"><code class="xref py py-class docutils literal notranslate"><span class="pre">RemoteProtocolError</span></code></a>.</p>
</div>
<div class="section" id="searching-for-a-channel">
<h3>Searching for a Channel<a class="headerlink" href="#searching-for-a-channel" title="Permalink to this headline">¶</a></h3>
<p>Say we’re looking for a channel (“Process Variable”) with a typically lyrical
EPICS name like <code class="xref py py-data docutils literal notranslate"><span class="pre">&quot;random_walk:dt&quot;</span></code>. Some server on our
network provides this channel.</p>
<p>The range of IP addresses to search is conventionally controlled by the
environment variables <code class="docutils literal notranslate"><span class="pre">EPICS_CA_ADDR_LIST</span></code> (a space-separated list of IP
addresses) and <code class="docutils literal notranslate"><span class="pre">EPICS_CA_AUTO_ADDR_LIST</span></code> (<code class="docutils literal notranslate"><span class="pre">yes</span></code> or <code class="docutils literal notranslate"><span class="pre">no</span></code>). Caproto
provides a convenience function <code class="xref py py-func docutils literal notranslate"><span class="pre">get_address_list()</span></code> for parsing these
variables, checking the available network interfaces if necessary, and
returning a list.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [17]: </span><span class="kn">import</span> <span class="nn">caproto</span>

<span class="gp">In [18]: </span><span class="n">hosts</span> <span class="o">=</span> <span class="n">caproto</span><span class="o">.</span><span class="n">get_address_list</span><span class="p">()</span>  <span class="c1"># example: [&#39;172.17.255.255&#39;]</span>
</pre></div>
</div>
<p>We need to broadcast a search request to the servers on our network and receive
a response. (In the event that multiple responses arrive, Channel Access
specifies that all but the first response should be ignored.) We follow the
same pattern as above, still using our broadcaster <code class="docutils literal notranslate"><span class="pre">b</span></code>, our socket
<code class="docutils literal notranslate"><span class="pre">udp_sock</span></code>, and some new caproto commands.</p>
<p>We need to announce which version of the protocol we are using and the name of
the channel we are seraching for. These two commands must be sent in the same
broadcast (UDP datagram), so we pass them to <a class="reference internal" href="api.html#caproto.Broadcaster.send" title="caproto.Broadcaster.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Broadcaster.send()</span></code></a> together.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [19]: </span><span class="n">name</span>  <span class="o">=</span> <span class="s2">&quot;random_walk:dt&quot;</span>

<span class="gp">In [20]: </span><span class="n">bytes_to_send</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">VersionRequest</span><span class="p">(</span><span class="n">priority</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="mi">13</span><span class="p">),</span>
<span class="gp">   ....: </span>                       <span class="n">caproto</span><span class="o">.</span><span class="n">SearchRequest</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="mi">13</span><span class="p">))</span>
<span class="gp">   ....: </span>

<span class="gp">In [21]: </span><span class="n">bytes_to_send</span>
<span class="gh">Out[21]: </span><span class="go">b&#39;\x00\x00\x00\x00\x00\x00\x00\r\x00\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x10\x00\x05\x00\r\x00\x00\x00\x00\x00\x00\x00\x00random_walk:dt\x00\x00&#39;</span>

<span class="gp">In [22]: </span><span class="k">for</span> <span class="n">host</span> <span class="ow">in</span> <span class="n">hosts</span><span class="p">:</span>
<span class="gp">   ....: </span>    <span class="n">udp_sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">bytes_to_send</span><span class="p">,</span> <span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">5064</span><span class="p">))</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<p>Our answer will arrive in a single datagram with multiple commands in it.</p>
<pre class="literal-block">In [23]: bytes_received, recv_address = udp_sock.recvfrom(1024)

In [24]: commands = b.recv(bytes_received, recv_address)

In [25]: version_response, search_response = commands

In [26]: version_response
Out[26]: VersionResponse(version=13)

In [27]: search_response
Out[27]: SearchResponse(port=55671, ip='255.255.255.255', cid=0, version=13)

In [28]: address = caproto.extract_address(search_response)

In [29]: address
Out[29]: ('127.0.0.1', 55671)</pre>
<p>Now we have the address of a server that has the channel we’re interested in.
Next, we’ll set aside the broadcaster and initiate TCP communication with this
particular server.</p>
</div>
<div class="section" id="creating-a-channel">
<h3>Creating a Channel<a class="headerlink" href="#creating-a-channel" title="Permalink to this headline">¶</a></h3>
<p>Create a TCP connection with the server at the <code class="docutils literal notranslate"><span class="pre">address</span></code> we found above.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [30]: </span><span class="kn">import</span> <span class="nn">socket</span>

<span class="gp">In [31]: </span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">create_connection</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
</pre></div>
</div>
<p>A <a class="reference internal" href="api.html#caproto.VirtualCircuit" title="caproto.VirtualCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">VirtualCircuit</span></code></a> plays the same role for a TCP connection as
the <a class="reference internal" href="api.html#caproto.Broadcaster" title="caproto.Broadcaster"><code class="xref py py-class docutils literal notranslate"><span class="pre">Broadcaster</span></code></a> played for UDP: we’ll use it to interpret
received bytes as commands and to ensure that incoming and outgoing bytes abide
by the protocol.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [32]: </span><span class="n">circuit</span> <span class="o">=</span> <span class="n">caproto</span><span class="o">.</span><span class="n">VirtualCircuit</span><span class="p">(</span><span class="n">our_role</span><span class="o">=</span><span class="n">caproto</span><span class="o">.</span><span class="n">CLIENT</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">address</span><span class="p">,</span>
<span class="gp">   ....: </span>                                 <span class="n">priority</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<p>We’ll use these convenience functions for what follows.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [33]: </span><span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="n">command</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="s2">&quot;Process a command in the VirtualCircuit and then transmit its bytes.&quot;</span>
<span class="gp">   ....: </span>    <span class="n">buffers_to_send</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="n">sock</span><span class="o">.</span><span class="n">sendmsg</span><span class="p">(</span><span class="n">buffers_to_send</span><span class="p">)</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [34]: </span><span class="k">def</span> <span class="nf">recv</span><span class="p">():</span>
<span class="gp">   ....: </span>    <span class="s2">&quot;Receive bytes; parse commands; process them in the VirtualCircuit.&quot;</span>
<span class="gp">   ....: </span>    <span class="n">bytes_received</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="n">commands</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">bytes_received</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">:</span>
<span class="gp">   ....: </span>        <span class="n">circuit</span><span class="o">.</span><span class="n">process_command</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="n">commands</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<p>We initialize the circuit by specifying our protocol version.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [35]: </span><span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">VersionRequest</span><span class="p">(</span><span class="n">priority</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="mi">13</span><span class="p">))</span>

<span class="gp">In [36]: </span><span class="n">recv</span><span class="p">()</span>
<span class="gh">Out[36]: </span><span class="go">deque([VersionResponse(version=13)])</span>
</pre></div>
</div>
<p>Optionally provide the host name and “client” name, which the server may use
to determine our read/write permissions on channels. (There is no
authentication in Channel Access; security has to be provided at the network
level.)</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [37]: </span><span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">HostNameRequest</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">))</span>

<span class="gp">In [38]: </span><span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">ClientNameRequest</span><span class="p">(</span><span class="s1">&#39;user&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Finally, create the channel and look at the responses.</p>
<pre class="literal-block">In [39]: cid = 1  # a client-specified unique ID for this Channel

In [40]: send(caproto.CreateChanRequest(name=name, cid=cid, version=13))

In [41]: commands = recv()

In [42]: access_response, create_chan_response = commands

In [43]: access_response
Out[43]: AccessRightsResponse(cid=1, access_rights=&lt;AccessRights.WRITE|READ: 3&gt;)

In [44]: create_chan_response
Out[44]: CreateChanResponse(data_type=&lt;ChannelType.DOUBLE: 6&gt;, data_count=1, cid=1, sid=0)</pre>
<p>Success! We now have a connection to the <code class="docutils literal notranslate"><span class="pre">random_walk:dt</span></code> channel. Next we’ll
read and write values.</p>
<p>Incidentally, we can reuse this same <code class="docutils literal notranslate"><span class="pre">circuit</span></code> and <code class="docutils literal notranslate"><span class="pre">sock</span></code> to connect to
other channels on the same server. In the commands that follow, we’ll use the
integer IDs <code class="docutils literal notranslate"><span class="pre">cid</span></code> (specified by our client in <code class="xref py py-class docutils literal notranslate"><span class="pre">CreateChanRequest</span></code>) and
<code class="docutils literal notranslate"><span class="pre">sid</span></code> (specified by the server in its <code class="xref py py-class docutils literal notranslate"><span class="pre">CreateChanResponse</span></code>) to specify
which channel we mean.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [45]: </span><span class="n">sid</span> <span class="o">=</span> <span class="n">create_chan_response</span><span class="o">.</span><span class="n">sid</span>
</pre></div>
</div>
<p>In the event of high traffic clogging the network, we can open up <em>multiple</em>
TCP connections to the same server, each with its own VirtualCircuit, and
designate them with different <em>priority</em> (specified in our
<a class="reference internal" href="api.html#caproto.VersionRequest" title="caproto.VersionRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">VersionRequest</span></code></a>). This why we need the concept of a VirtualCircuit:
there can be multiple VirtualCircuits between peers.</p>
</div>
<div class="section" id="reading-and-writing-values">
<h3>Reading and Writing Values<a class="headerlink" href="#reading-and-writing-values" title="Permalink to this headline">¶</a></h3>
<p>Read:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [46]: </span><span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">ReadNotifyRequest</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="n">create_chan_response</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span>
<span class="gp">   ....: </span>                               <span class="n">data_count</span><span class="o">=</span><span class="n">create_chan_response</span><span class="o">.</span><span class="n">data_count</span><span class="p">,</span>
<span class="gp">   ....: </span>                               <span class="n">sid</span><span class="o">=</span><span class="n">sid</span><span class="p">,</span>
<span class="gp">   ....: </span>                               <span class="n">ioid</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">   ....: </span>

<span class="gp">In [47]: </span><span class="n">recv</span><span class="p">()</span>
<span class="gh">Out[47]: </span><span class="go">deque([ReadNotifyResponse(data=array([3.]), data_type=&lt;ChannelType.DOUBLE: 6&gt;, data_count=1, status=CAStatusCode(name=&#39;ECA_NORMAL&#39;, code=0, code_with_severity=1, severity=&lt;CASeverity.SUCCESS: 1&gt;, success=1, defunct=False, description=&#39;Normal successful completion&#39;), ioid=1, metadata=None)])</span>
</pre></div>
</div>
<p>We may request a particular data type and element count; in the case we just
asked for the “native” data type and count that the server reported in its
<code class="xref py py-class docutils literal notranslate"><span class="pre">CreateChanResponse</span></code> above.</p>
<p>Write:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [48]: </span><span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">WriteNotifyRequest</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,),</span>
<span class="gp">   ....: </span>                                <span class="n">data_type</span><span class="o">=</span><span class="n">create_chan_response</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span>
<span class="gp">   ....: </span>                                <span class="n">data_count</span><span class="o">=</span><span class="n">create_chan_response</span><span class="o">.</span><span class="n">data_count</span><span class="p">,</span>
<span class="gp">   ....: </span>                                <span class="n">sid</span><span class="o">=</span><span class="n">sid</span><span class="p">,</span>
<span class="gp">   ....: </span>                                <span class="n">ioid</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">   ....: </span>

<span class="gp">In [49]: </span><span class="n">recv</span><span class="p">()</span>
<span class="gh">Out[49]: </span><span class="go">deque([WriteNotifyResponse(data_type=&lt;ChannelType.DOUBLE: 6&gt;, data_count=1, status=CAStatusCode(name=&#39;ECA_NORMAL&#39;, code=0, code_with_severity=1, severity=&lt;CASeverity.SUCCESS: 1&gt;, success=1, defunct=False, description=&#39;Normal successful completion&#39;), ioid=2)])</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">data</span></code> may be given as one of the following types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tuple</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> (if numpy is installed)</p></li>
<li><p>big-endian <code class="docutils literal notranslate"><span class="pre">array.array</span></code> (the somewhat rarely-used builtin array library)</p></li>
<li><p>big-endian bytes-like (<code class="docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="docutils literal notranslate"><span class="pre">bytearray</span></code>, <code class="docutils literal notranslate"><span class="pre">memoryview</span></code>)</p></li>
</ul>
<p>The command also accepts a <code class="docutils literal notranslate"><span class="pre">metadata</span></code> parameter for data types that include
metadata. See <a class="reference internal" href="api.html#payload-data-types"><span class="std std-ref">Payload Data Types</span></a> for details.</p>
</div>
<div class="section" id="subscribing-to-events-updates">
<h3>Subscribing to “Events” (Updates)<a class="headerlink" href="#subscribing-to-events-updates" title="Permalink to this headline">¶</a></h3>
<p>Ask the server to send responses every time the value of the Channel changes.
As with reading, above, we have the option of requesting a specific data type
or element count, but we’ll use the “native” parameters.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [50]: </span><span class="n">req</span> <span class="o">=</span> <span class="n">caproto</span><span class="o">.</span><span class="n">EventAddRequest</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="n">create_chan_response</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span>
<span class="gp">   ....: </span>                              <span class="n">data_count</span><span class="o">=</span><span class="n">create_chan_response</span><span class="o">.</span><span class="n">data_count</span><span class="p">,</span>
<span class="gp">   ....: </span>                              <span class="n">sid</span><span class="o">=</span><span class="n">sid</span><span class="p">,</span>
<span class="gp">   ....: </span>                              <span class="n">subscriptionid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="gp">   ....: </span>                              <span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">   ....: </span>

<span class="gp">In [51]: </span><span class="n">send</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
</pre></div>
</div>
<p>The server always sends at least one response with the current value at
subscription time.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [52]: </span><span class="n">recv</span><span class="p">()</span>
<span class="gh">Out[52]: </span><span class="go">deque([EventAddResponse(data=array([4.]), data_type=&lt;ChannelType.DOUBLE: 6&gt;, data_count=1, status=CAStatusCode(name=&#39;ECA_NORMAL&#39;, code=0, code_with_severity=1, severity=&lt;CASeverity.SUCCESS: 1&gt;, success=1, defunct=False, description=&#39;Normal successful completion&#39;), subscriptionid=0, metadata=None)])</span>
</pre></div>
</div>
<p>If the value changes, additional responses will come in. If multiple
subscriptions are in play at once over this circuit, we can use the
<code class="docutils literal notranslate"><span class="pre">subscriptionid</span></code> to match them to the right channel. We also use it to end
the subscription:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [53]: </span><span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">EventCancelRequest</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span>
<span class="gp">   ....: </span>                                <span class="n">sid</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">sid</span><span class="p">,</span>
<span class="gp">   ....: </span>                                <span class="n">subscriptionid</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">subscriptionid</span><span class="p">))</span>
<span class="gp">   ....: </span>

<span class="gp">In [54]: </span><span class="n">recv</span><span class="p">()</span>
<span class="gh">Out[54]: </span><span class="go">deque([EventAddResponse(data=(repr: tuple index out of range), data_type=&lt;ChannelType.DOUBLE: 6&gt;, data_count=1, status=(repr: 0), subscriptionid=0, metadata=(repr: tuple index out of range))])</span>
</pre></div>
</div>
</div>
<div class="section" id="closing-the-channel">
<h3>Closing the Channel<a class="headerlink" href="#closing-the-channel" title="Permalink to this headline">¶</a></h3>
<p>To clean up, close the Channel.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [55]: </span><span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">ClearChannelRequest</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">cid</span><span class="p">))</span>

<span class="gp">In [56]: </span><span class="n">recv</span><span class="p">()</span>
<span class="gh">Out[56]: </span><span class="go">deque([ClearChannelResponse(sid=0, cid=1)])</span>
</pre></div>
</div>
<p>If we are done with the circuit, close the socket too.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [57]: </span><span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="simplify-bookkeeping-with-channels">
<h2>Simplify Bookkeeping with Channels<a class="headerlink" href="#simplify-bookkeeping-with-channels" title="Permalink to this headline">¶</a></h2>
<p>In the example above, we handled a <a class="reference internal" href="api.html#caproto.VirtualCircuit" title="caproto.VirtualCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">VirtualCircuit</span></code></a> and several
different commands. The <a class="reference internal" href="api.html#caproto.VirtualCircuit" title="caproto.VirtualCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">VirtualCircuit</span></code></a> policed our adherence to the
Channel Access protocol by watching incoming and outgoing commands and tracking
the state of the circuit itself and the state(s) of the channel(s) on the
circuit. Internally, to facilitate this, it creates a <a class="reference internal" href="api.html#caproto.ClientChannel" title="caproto.ClientChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClientChannel</span></code></a>
object for each channel to encapsulate its state and stash bookkeeping details
like <code class="docutils literal notranslate"><span class="pre">cid</span></code> and <code class="docutils literal notranslate"><span class="pre">sid</span></code>.</p>
<p>Using these objects directly can help us juggle IDs and generate valid commands
more succinctly. This API is purely optional, and using it does not affect
the state machines.</p>
<p>See how much more succinct our example becomes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">### Create</span>
<span class="n">chan</span> <span class="o">=</span> <span class="n">caproto</span><span class="o">.</span><span class="n">ClientChannel</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">circuit</span><span class="p">)</span>
<span class="n">send</span><span class="p">(</span><span class="n">chan</span><span class="o">.</span><span class="n">version</span><span class="p">())</span>
<span class="n">recv</span><span class="p">()</span>
<span class="n">send</span><span class="p">(</span><span class="n">chan</span><span class="o">.</span><span class="n">host_name</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">),</span> <span class="n">chan</span><span class="o">.</span><span class="n">client_name</span><span class="p">(</span><span class="s1">&#39;user&#39;</span><span class="p">),</span> <span class="n">chan</span><span class="o">.</span><span class="n">create</span><span class="p">())</span>
<span class="n">recv</span><span class="p">()</span>

<span class="c1">### Read and Write</span>
<span class="n">send</span><span class="p">(</span><span class="n">chan</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
<span class="n">recv</span><span class="p">()</span>
<span class="n">send</span><span class="p">(</span><span class="n">chan</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="mi">4</span><span class="p">,)))</span>
<span class="n">recv</span><span class="p">()</span>

<span class="c1">### Subscribe and Unsubscribe</span>
<span class="n">send</span><span class="p">(</span><span class="n">chan</span><span class="o">.</span><span class="n">subscribe</span><span class="p">())</span>
<span class="n">recv</span><span class="p">()</span>
<span class="n">send</span><span class="p">(</span><span class="n">chan</span><span class="o">.</span><span class="n">unsubscribe</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="n">recv</span><span class="p">()</span>

<span class="c1">### Clear</span>
<span class="n">send</span><span class="p">(</span><span class="n">chan</span><span class="o">.</span><span class="n">clear</span><span class="p">())</span>
<span class="n">recv</span><span class="p">()</span>
</pre></div>
</div>
<p>Here is the equivalent, a condensed copy of our work from previous sections:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">### Create</span>
<span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">VersionRequest</span><span class="p">(</span><span class="n">priority</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="mi">13</span><span class="p">))</span>
<span class="n">recv</span><span class="p">()</span>
<span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">HostNameRequest</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">))</span>
<span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">ClientNameRequest</span><span class="p">(</span><span class="s1">&#39;user&#39;</span><span class="p">))</span>
<span class="n">cid</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># a client-specified unique ID for this Channel</span>
<span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">CreateChanRequest</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">cid</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="mi">13</span><span class="p">))</span>
<span class="n">commands</span> <span class="o">=</span> <span class="n">recv</span><span class="p">()</span>
<span class="n">access_response</span><span class="p">,</span> <span class="n">create_chan_response</span> <span class="o">=</span> <span class="n">commands</span>

<span class="c1">### Read and Write</span>
<span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">ReadNotifyRequest</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">data_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sid</span><span class="o">=</span><span class="n">sid</span><span class="p">,</span> <span class="n">ioid</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">recv</span><span class="p">()</span>
<span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">WriteNotifyRequest</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,),</span> <span class="n">data_type</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">data_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sid</span><span class="o">=</span><span class="n">sid</span><span class="p">,</span> <span class="n">ioid</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="n">recv</span><span class="p">()</span>

<span class="c1">### Subscribe and Unsubscribe</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">caproto</span><span class="o">.</span><span class="n">EventAddRequest</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="n">create_chan_response</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span>
                              <span class="n">data_count</span><span class="o">=</span><span class="n">create_chan_response</span><span class="o">.</span><span class="n">data_count</span><span class="p">,</span>
                              <span class="n">sid</span><span class="o">=</span><span class="n">sid</span><span class="p">,</span>
                              <span class="n">subscriptionid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                              <span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">send</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
<span class="n">recv</span><span class="p">()</span>
<span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">EventCancelRequest</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span>
                                <span class="n">sid</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">sid</span><span class="p">,</span>
                                <span class="n">subscriptionid</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">subscriptionid</span><span class="p">))</span>
<span class="n">recv</span><span class="p">()</span>

<span class="c1">### Clear</span>
<span class="n">send</span><span class="p">(</span><span class="n">caproto</span><span class="o">.</span><span class="n">ClearChannelRequest</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="n">cid</span><span class="p">))</span>
<span class="n">recv</span><span class="p">()</span>
</pre></div>
</div>
<p>Notice that the channel convenience methods like <code class="docutils literal notranslate"><span class="pre">chan.create()</span></code> don’t
actually <em>do</em> anything. We still have to <code class="docutils literal notranslate"><span class="pre">send</span></code> the command into the
VirtualCircuit and then send it over the socket. These are just easy ways to
generate valid commands — with auto-generated unique IDs filled in — which
you may or may not then choose to send. The state machines are not updated
until (unless) the command is actually sent.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="api.html" class="btn btn-neutral float-right" title="Core API Documentation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="loggers.html" class="btn btn-neutral float-left" title="Logging" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017, Daniel Allan

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>