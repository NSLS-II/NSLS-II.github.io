

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Threading Client &mdash; caproto 0.4.2+0.g334679b.dirty documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Pyepics-Compatible Client" href="pyepics-compat-client.html" />
    <link rel="prev" title="Synchronous Client" href="sync-client.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> caproto
          

          
          </a>

          
            
            
              <div class="version">
                0.4.2+0.g334679b.dirty
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Install Caproto</a></li>
</ul>
<p class="caption"><span class="caption-text">EPICS Clients and Servers</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="clients.html">Clients</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="command-line-client.html">Command-Line Client</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync-client.html">Synchronous Client</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Threading Client</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tutorial">Tutorial</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#connect">Connect</a></li>
<li class="toctree-l4"><a class="reference internal" href="#read">Read</a></li>
<li class="toctree-l4"><a class="reference internal" href="#write">Write</a></li>
<li class="toctree-l4"><a class="reference internal" href="#subscribe-monitor">Subscribe (“Monitor”)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#batched-requests">Batched Requests</a></li>
<li class="toctree-l4"><a class="reference internal" href="#go-idle">Go Idle</a></li>
<li class="toctree-l4"><a class="reference internal" href="#canceling-searches">Canceling Searches</a></li>
<li class="toctree-l4"><a class="reference internal" href="#events-off-and-on">Events Off and On</a></li>
<li class="toctree-l4"><a class="reference internal" href="#server-health-check">Server Health Check</a></li>
<li class="toctree-l4"><a class="reference internal" href="#logs-for-debugging">Logs for Debugging</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#api-documentation">API Documentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pyepics-compat-client.html">Pyepics-Compatible Client</a></li>
<li class="toctree-l2"><a class="reference internal" href="async-clients.html">Asynchronous Clients</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="iocs.html">Input-Output Controllers (IOCs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="mock-records.html">Mock Records</a></li>
<li class="toctree-l1"><a class="reference internal" href="servers.html">Servers</a></li>
<li class="toctree-l1"><a class="reference internal" href="shark.html">Shark (pcap/tcpdump parsing)</a></li>
<li class="toctree-l1"><a class="reference internal" href="loggers.html">Logging</a></li>
</ul>
<p class="caption"><span class="caption-text">Channel Access Sans I/O</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="basics.html">Writing Your Own Channel Access Client</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">Core API Documentation</a></li>
</ul>
<p class="caption"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://nsls-ii.github.io/caproto/bench/#/">Performance Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="protocol-compliance.html">Details of our Protocol Compliance for CA Nerds</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-notes.html">Release History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">caproto</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="clients.html">Clients</a> &raquo;</li>
        
      <li>Threading Client</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/threading-client.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="threading-client">
<h1>Threading Client<a class="headerlink" href="#threading-client" title="Permalink to this headline">¶</a></h1>
<p>The threading client is a high-performance client that uses Python’s built-in
threading module to manage concurrency.</p>
<div class="section" id="tutorial">
<h2>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h2>
<p>In a separate shell, start one of caproto’s demo IOCs.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ python3 -m caproto.ioc_examples.random_walk
PVs: <span class="o">[</span><span class="s1">&#39;random_walk:dt&#39;</span>, <span class="s1">&#39;random_walk:x&#39;</span><span class="o">]</span>
</pre></div>
</div>
<div class="section" id="connect">
<h3>Connect<a class="headerlink" href="#connect" title="Permalink to this headline">¶</a></h3>
<p>Now, in Python we will talk to it using caproto’s threading client. Start by
creating a <a class="reference internal" href="#caproto.threading.client.Context" title="caproto.threading.client.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">caproto.threading.client</span> <span class="kn">import</span> <span class="n">Context</span>

<span class="gp">In [2]: </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">Context</span><span class="p">()</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#caproto.threading.client.Context" title="caproto.threading.client.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> object caches connections, manages automatic
re-connection, and tracks the state of connections in progress.
We can use it to request new connections. Formulating requests for many PVs in
a large batch is efficient. In this example we’ll just ask for two PVs.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [3]: </span><span class="n">x</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">get_pvs</span><span class="p">(</span><span class="s1">&#39;random_walk:x&#39;</span><span class="p">,</span> <span class="s1">&#39;random_walk:dt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#caproto.threading.client.Context.get_pvs" title="caproto.threading.client.Context.get_pvs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Context.get_pvs()</span></code></a>  accepts an arbitrary number of PV names and
immediately returns a collection of <a class="reference internal" href="#caproto.threading.client.PV" title="caproto.threading.client.PV"><code class="xref py py-class docutils literal notranslate"><span class="pre">PV</span></code></a> objects representing each name.
In a background thread, the Context searches for an EPICS server that provides
that PV name and then connects to it. The PV object displays its connection
state:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">dt</span>
<span class="gh">Out[4]: </span><span class="go">&lt;PV name=&#39;random_walk:dt&#39; priority=0 (searching....)&gt;</span>
</pre></div>
</div>
<p>The Context displays aggregate information about the state of all connections.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">ctx</span>
<span class="gh">Out[5]: </span><span class="go">&lt;Context searches_pending=0 circuits=0 pvs=2 idle=0&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="read">
<h3>Read<a class="headerlink" href="#read" title="Permalink to this headline">¶</a></h3>
<p>Now, to read a PV:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [6]: </span><span class="n">res</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="gp">In [7]: </span><span class="n">res</span>
<span class="gh">Out[7]: </span><span class="go">ReadNotifyResponse(data=array([1.]), data_type=&lt;ChannelType.DOUBLE: 6&gt;, data_count=1, status=CAStatusCode(name=&#39;ECA_NORMAL&#39;, code=0, code_with_severity=1, severity=&lt;CASeverity.SUCCESS: 1&gt;, success=1, defunct=False, description=&#39;Normal successful completion&#39;), ioid=0, metadata=None)</span>
</pre></div>
</div>
<p>This object is a human-friendly representation of the server’s response. The
raw bytes of that response are:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="nb">bytes</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="gh">Out[8]: </span><span class="go">b&#39;\x00\x0f\x00\x08\x00\x06\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00?\xf0\x00\x00\x00\x00\x00\x00&#39;</span>
</pre></div>
</div>
<p>Access particular fields in the response using attribute (“dot”) access on <code class="docutils literal notranslate"><span class="pre">res</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [9]: </span><span class="n">res</span><span class="o">.</span><span class="n">data</span>
<span class="gh">Out[9]: </span><span class="go">array([1.])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>Performance Note</strong></p>
<p>The underlying metadata and data are stored in efficient, contiguous-memory
data structures.</p>
<pre class="literal-block">
In [10]: res.header  # a ctypes.BigEndianStructure
Out[10]: MessageHeader(command=15, payload_size=8, data_type=6, data_count=1, parameter1=1, parameter2=0)

In [11]: res.buffers  # a collection of one or more buffers
Out[11]: (b'', &lt;memory at 0x7fb91cf4a048&gt;)
</pre>
<p class="last">They were received directly from the socket into these structure with no
intermediate copies. Accessing the <code class="docutils literal notranslate"><span class="pre">res.data</span></code> — which returns a
<code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="docutils literal notranslate"><span class="pre">array.array</span></code> — provides a view onto that same
memory with no copying (if the data was received from the socket all at
once) or one copy (if the data bridged multiple receipts).</p>
</div>
</div>
<div class="section" id="write">
<h3>Write<a class="headerlink" href="#write" title="Permalink to this headline">¶</a></h3>
<p>Let us set the value to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [12]: </span><span class="n">dt</span><span class="o">.</span><span class="n">write</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gh">Out[12]: </span><span class="go">WriteNotifyResponse(data_type=&lt;ChannelType.DOUBLE: 6&gt;, data_count=1, status=CAStatusCode(name=&#39;ECA_NORMAL&#39;, code=0, code_with_severity=1, severity=&lt;CASeverity.SUCCESS: 1&gt;, success=1, defunct=False, description=&#39;Normal successful completion&#39;), ioid=1)</span>
</pre></div>
</div>
<p>By default, we send <code class="docutils literal notranslate"><span class="pre">WriteNotifyResponse</span></code>, wait for a response, and return
it. There are a couple other ways we can handle writes:</p>
<ul>
<li><p class="first">Return immediately, not asking for or waiting for a response.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dt</span><span class="o">.</span><span class="n">write</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">wait</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Return immediately, not waiting for a response, but handing the response
(when it arrived) to some callback function, processed on a background
thread.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;got a response:&#39;</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>

<span class="n">dt</span><span class="o">.</span><span class="n">write</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">wait</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
<p>See the <a class="reference internal" href="#caproto.threading.client.PV.write" title="caproto.threading.client.PV.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PV.write()</span></code></a> for more.</p>
</div>
<div class="section" id="subscribe-monitor">
<h3>Subscribe (“Monitor”)<a class="headerlink" href="#subscribe-monitor" title="Permalink to this headline">¶</a></h3>
<p>Let us now monitor a channel. The server updates the <code class="docutils literal notranslate"><span class="pre">random_walk:x</span></code> channel
periodically at some period set by <code class="docutils literal notranslate"><span class="pre">random_walk:dt</span></code>. We can subscribe to
updates and fan them out to one or more user-defined callback functions.
First, we define a <a class="reference internal" href="#caproto.threading.client.Subscription" title="caproto.threading.client.Subscription"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subscription</span></code></a>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [13]: </span><span class="n">sub</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">subscribe</span><span class="p">()</span>
</pre></div>
</div>
<p>Next, we define a callback function, a function that will be called whenever
the server sends an update. It must accept one positional argument.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [14]: </span><span class="n">responses</span> <span class="o">=</span> <span class="p">[]</span>

<span class="gp">In [15]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="n">responses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<p>We register this function with <code class="docutils literal notranslate"><span class="pre">sub</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [16]: </span><span class="n">token</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">token</span></code> is just an integer which we can use to remove <code class="docutils literal notranslate"><span class="pre">f</span></code> later. We can
define a second callback:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [17]: </span><span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>

<span class="gp">In [18]: </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<p>and add it to the same subscription, putting no additional load on the network.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [19]: </span><span class="n">sub</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gh">Out[19]: </span><span class="go">1</span>
</pre></div>
</div>
<p>After some time has passed, we will have accumulated some responses.</p>
<pre class="literal-block">
In [20]: len(responses)
Out[20]: 6

In [21]: values
Out[21]: 
[-0.718946047003153,
 -0.9551428026499711,
 -0.7092825560251779,
 -0.052477216809301286,
 -0.9668567477407037,
 -0.449003288563121]
</pre>
<p>At any point we can remove a specific callback function:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [22]: </span><span class="n">sub</span><span class="o">.</span><span class="n">remove_callback</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
</pre></div>
</div>
<p>or clear all the callbacks on a subscription:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [23]: </span><span class="n">sub</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</pre></div>
</div>
<p>In order to minimize load on the network, a <a class="reference internal" href="#caproto.threading.client.Subscription" title="caproto.threading.client.Subscription"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subscription</span></code></a> waits to
request updates from the server until the first user callback is added. Thus,
the first callback added by the user is guaranteed to get the first response
received from the server. If all user callbacks are later removed, either
explicitly (via <code class="docutils literal notranslate"><span class="pre">remove_callback</span></code> or <code class="docutils literal notranslate"><span class="pre">clear</span></code>) or implicitly via Python
garbage collection, the Subscription automatically cancels future updates from
the server.  If a callback is then later added, the Subscription silently
re-initiates updates. All of this is transparent to the user.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The callback registry in <a class="reference internal" href="#caproto.threading.client.Subscription" title="caproto.threading.client.Subscription"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subscription</span></code></a>  only holds weak references
to the user callback functions. If there are no other references to the
function, it will be silently garbage collected and removed. Therefore,
constructions like this do not work:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sub</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="k">lambda</span> <span class="n">response</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
</pre></div>
</div>
<p>The lambda function will be promptly garbage collected by Python and
removed from <code class="docutils literal notranslate"><span class="pre">sub</span></code> by caproto. To avoid that, make a reference before
passing the function to <a class="reference internal" href="#caproto.threading.client.Subscription.add_callback" title="caproto.threading.client.Subscription.add_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Subscription.add_callback()</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cb</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">response</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="n">sub</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
</pre></div>
</div>
<p>This can be surprising, but it is a standard approach for avoiding the
accidental costly accumulation of abandoned callbacks.</p>
<p class="last">This pitfall does not apply to callbacks passed to <a class="reference internal" href="#caproto.threading.client.PV.read" title="caproto.threading.client.PV.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PV.read()</span></code></a> and
<a class="reference internal" href="#caproto.threading.client.PV.write" title="caproto.threading.client.PV.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PV.write()</span></code></a> (or <a class="reference internal" href="#caproto.threading.client.Batch.read" title="caproto.threading.client.Batch.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Batch.read()</span></code></a> and <a class="reference internal" href="#caproto.threading.client.Batch.write" title="caproto.threading.client.Batch.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Batch.write()</span></code></a>) because
those are single-shot callbacks that do not persist beyond their first use.</p>
</div>
</div>
<div class="section" id="batched-requests">
<h3>Batched Requests<a class="headerlink" href="#batched-requests" title="Permalink to this headline">¶</a></h3>
<p>Batching requests is efficient, and it sets up the server to perform these
operations as closely-spaced in time as possible, within the limits of the
protocol. Python’s <code class="docutils literal notranslate"><span class="pre">with</span></code> syntax provides a natural way to specify a batch of
requests — reads, writes, or a mixture of both — and execute them upon exit
from the <code class="docutils literal notranslate"><span class="pre">with</span></code> block.</p>
<p>Suppose we had a list of <code class="docutils literal notranslate"><span class="pre">PV</span></code> objects, <code class="docutils literal notranslate"><span class="pre">pvs</span></code>, and we want to request
readings in bulk. We can use a callback function to stash readings in a
dictionary as they arrive.</p>
<p>For convenience we’ll demonstrate this using the two PVs we have handy —
<code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">dt</span></code> — but an unlimited number may be used.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [24]: </span><span class="n">pvs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">dt</span><span class="p">]</span>

<span class="gp">In [25]: </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="gp">In [26]: </span><span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>

<span class="gp">In [27]: </span><span class="k">def</span> <span class="nf">stash_result</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="n">results</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<p>Now we’ll use the <a class="reference internal" href="#caproto.threading.client.Batch" title="caproto.threading.client.Batch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Batch</span></code></a> context:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [28]: </span><span class="kn">from</span> <span class="nn">caproto.threading.client</span> <span class="kn">import</span> <span class="n">Batch</span>

<span class="gp">In [29]: </span><span class="k">with</span> <span class="n">Batch</span><span class="p">()</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
<span class="gp">   ....: </span>    <span class="k">for</span> <span class="n">pv</span> <span class="ow">in</span> <span class="n">pvs</span><span class="p">:</span>
<span class="gp">   ....: </span>        <span class="n">b</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">stash_result</span><span class="p">,</span> <span class="n">pv</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<p>The requests will be sent in large batches (over the PVs’ respective circuits)
upon exiting the <code class="docutils literal notranslate"><span class="pre">with</span></code> block. The responses will be processed on a
background thread. As the responses come in, the <code class="docutils literal notranslate"><span class="pre">results</span></code> dictionary will be
updated.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [30]: </span><span class="n">results</span>
<span class="gh">Out[30]: </span><span class="go">{&#39;random_walk:x&#39;: array([-0.44900329]), &#39;random_walk:dt&#39;: array([1.])}</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#caproto.threading.client.Batch" title="caproto.threading.client.Batch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Batch</span></code></a> for more.</p>
</div>
<div class="section" id="go-idle">
<h3>Go Idle<a class="headerlink" href="#go-idle" title="Permalink to this headline">¶</a></h3>
<p>Once created, PVs are cached for the lifetime of the <a class="reference internal" href="#caproto.threading.client.Context" title="caproto.threading.client.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> and
returned again to the user if a PV with the same name and priority is
requested. In order to reduce the load on the network, a PV can be temporarily
made “idle” (disconnected). It will silently, automatically reconnect the next
time it is used.</p>
<pre class="literal-block">
In [31]: x
Out[31]: &lt;PV name='random_walk:x' priority=0 address=('127.0.0.1', 55393), circuit_state=States.CONNECTED, channel_state=States.CONNECTED&gt;

In [32]: x.go_idle()

In [33]: x
Out[33]: &lt;PV name='random_walk:x' priority=0 (idle)&gt;

In [34]: x.read()
Out[34]: ReadNotifyResponse(data=array([-0.44900329]), data_type=&lt;ChannelType.DOUBLE: 6&gt;, data_count=1, status=CAStatusCode(name='ECA_NORMAL', code=0, code_with_severity=1, severity=&lt;CASeverity.SUCCESS: 1&gt;, success=1, defunct=False, description='Normal successful completion'), ioid=4, metadata=None)

In [35]: x
Out[35]: &lt;PV name='random_walk:x' priority=0 address=('127.0.0.1', 55393), circuit_state=States.CONNECTED, channel_state=States.CONNECTED&gt;
</pre>
<p>Notice that when the PV was read it automatically reconnected, requiring no
action from the user.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">go_idle()</span></code> method is merely a <em>request</em> and is not guaranteed to have
any effect. If a PV has active subscriptions, it will ignore the request: it
must stay active to continue servicing user callbacks. Therefore, it is safe
call <code class="docutils literal notranslate"><span class="pre">go_idle()</span></code> on any PV at any time, knowing that the PV will decline to
disconnect if it is being actively used and that, if it is currently unused, it
will transparently reconnect the next time it is used.</p>
</div>
<div class="section" id="canceling-searches">
<h3>Canceling Searches<a class="headerlink" href="#canceling-searches" title="Permalink to this headline">¶</a></h3>
<p>All unanswered searches are retried repeatedly, with decreasing frequency,
forever. Each new call to <a class="reference internal" href="#caproto.threading.client.Context.get_pvs" title="caproto.threading.client.Context.get_pvs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_pvs()</span></code></a> causes all unanswered
searches to be retried at least once immediately. This can generate unwanted
network traffic. To fully cancel a search that is never expected to complete,
access the method <a class="reference internal" href="#caproto.threading.client.SharedBroadcaster.cancel" title="caproto.threading.client.SharedBroadcaster.cancel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SharedBroadcaster.cancel</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ctx</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">cancel</span><span class="p">(</span><span class="s1">&#39;some typo-ed PV name, for example&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>As the name suggests, it is possible to construct multiple Contexts that
share one SharedBroadcaster. In that scenario, notice that canceling the
search will affect all contexts using the SharedBroadcaster.</p>
</div>
<div class="section" id="events-off-and-on">
<h3>Events Off and On<a class="headerlink" href="#events-off-and-on" title="Permalink to this headline">¶</a></h3>
<p>If a given circuit produces updates faster than a client can process them, the
client can suspend subscriptions on that circuit. This will causes the server
to discard all backlogged updates and all new updates during the period of
supsension. When the client reactives subscriptions, it will immediate receive
the most recent update and then any future updates.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">circuit_manager</span><span class="o">.</span><span class="n">events_off</span><span class="p">()</span>
<span class="o">...</span>
<span class="n">x</span><span class="o">.</span><span class="n">circuit_manager</span><span class="o">.</span><span class="n">events_on</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="server-health-check">
<span id="id1"></span><h3>Server Health Check<a class="headerlink" href="#server-health-check" title="Permalink to this headline">¶</a></h3>
<p>To check how much time has passed (in seconds) since each known server was last
heard from, use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ctx</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">time_since_last_heard</span><span class="p">()</span>
</pre></div>
</div>
<p>As a convenience, check on the server connected to a specific PV using:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">time_since_last_heard</span><span class="p">()</span>
</pre></div>
</div>
<p>See the <a class="reference internal" href="#caproto.threading.client.SharedBroadcaster.time_since_last_heard" title="caproto.threading.client.SharedBroadcaster.time_since_last_heard"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SharedBroadcaster.time_since_last_heard()</span></code></a> API documentation below
for details.</p>
</div>
<div class="section" id="logs-for-debugging">
<span id="threading-loggers"></span><h3>Logs for Debugging<a class="headerlink" href="#logs-for-debugging" title="Permalink to this headline">¶</a></h3>
<p>Caproto uses Python’s logging framework, which enables sophisticated log
management. For more information and copy/paste-able examples, see
<a class="reference internal" href="loggers.html#loggers"><span class="std std-ref">Logging</span></a>.</p>
</div>
</div>
<div class="section" id="api-documentation">
<h2>API Documentation<a class="headerlink" href="#api-documentation" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="caproto.threading.client.Context">
<em class="property">class </em><code class="descclassname">caproto.threading.client.</code><code class="descname">Context</code><span class="sig-paren">(</span><em>broadcaster=None</em>, <em>*</em>, <em>timeout=2</em>, <em>host_name=None</em>, <em>client_name=None</em>, <em>max_workers=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#Context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.Context" title="Permalink to this definition">¶</a></dt>
<dd><p>Encapsulates the state and connections of a client</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>broadcaster</strong> <span class="classifier-delimiter">:</span> <span class="classifier">SharedBroadcaster, optional</span></dt>
<dd><p class="first last">If None is specified, a fresh one is instantiated.</p>
</dd>
<dt><strong>timeout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number or None, optional</span></dt>
<dd><p class="first last">Number of seconds before a CaprotoTimeoutError is raised. This default
can be overridden at the PV level or for any given operation. If unset,
the default is 2 seconds. If None, never timeout. A global timeout can
be specified via an environment variable <code class="docutils literal notranslate"><span class="pre">CAPROTO_DEFAULT_TIMEOUT</span></code>.</p>
</dd>
<dt><strong>host_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string, optional</span></dt>
<dd><p class="first last">uses value of <code class="docutils literal notranslate"><span class="pre">socket.gethostname()</span></code> by default</p>
</dd>
<dt><strong>client_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string, optional</span></dt>
<dd><p class="first last">uses value of <code class="docutils literal notranslate"><span class="pre">getpass.getuser()</span></code> by default</p>
</dd>
<dt><strong>max_workers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer, optional</span></dt>
<dd><p class="first last">Number of worker threaders <em>per VirtualCircuit</em> for executing user
callbacks. Default is 1. For any number of workers, workers will
receive updates in the order which they are received from the server.
That is, work on each update will <em>begin</em> in sequential order.
Work-scheduling internal to the user callback is outside caproto’s
control. If the number of workers is set to greater than 1, the work on
each update may not <em>finish</em> in a deterministic order. For example, if
workers are writing lines into a file, the only way to guarantee that
the lines are ordered properly is to use only one worker. If ordering
matters for your application, think carefully before increasing this
value from 1.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="caproto.threading.client.Context.get_pvs">
<code class="descname">get_pvs</code><span class="sig-paren">(</span><em>self</em>, <em>*names</em>, <em>priority=0</em>, <em>connection_state_callback=None</em>, <em>access_rights_callback=None</em>, <em>timeout=&lt;object object at 0x7fb9247a9740&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#Context.get_pvs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.Context.get_pvs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of PV objects.</p>
<p>These objects may not be connected at first. Channel creation occurs on
a background thread.</p>
<p>PVs are uniquely defined by their name and priority. If a PV with the
same name and priority is requested twice, the same (cached) object is
returned. Any callbacks included here are added to added alongside any
existing ones.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>*names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">strings</span></dt>
<dd><p class="first last">any number of PV names</p>
</dd>
<dt><strong>priority</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Used by the server to triage subscription responses when under high
load. 0 is lowest; 99 is highest.</p>
</dd>
<dt><strong>connection_state_callback</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">Expected signature: <code class="docutils literal notranslate"><span class="pre">f(pv,</span> <span class="pre">state)</span></code> where <code class="docutils literal notranslate"><span class="pre">pv</span></code> is the instance
of <code class="docutils literal notranslate"><span class="pre">PV</span></code> whose state has changed and <code class="docutils literal notranslate"><span class="pre">state</span></code> is a string</p>
</dd>
<dt><strong>access_rights_callback</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">Expected signature: <code class="docutils literal notranslate"><span class="pre">f(pv,</span> <span class="pre">access_rights)</span></code> where <code class="docutils literal notranslate"><span class="pre">pv</span></code> is the
instance of <code class="docutils literal notranslate"><span class="pre">PV</span></code> whose state has changed and <code class="docutils literal notranslate"><span class="pre">access_rights</span></code> is
a member of the caproto <code class="docutils literal notranslate"><span class="pre">AccessRights</span></code> enum</p>
</dd>
<dt><strong>timeout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number or None, optional</span></dt>
<dd><p class="first last">Number of seconds before a CaprotoTimeoutError is raised. This
default can be overridden for any specific operation. By default,
fall back to the default timeout set by the Context. If None, never
timeout.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="caproto.threading.client.PV">
<em class="property">class </em><code class="descclassname">caproto.threading.client.</code><code class="descname">PV</code><span class="sig-paren">(</span><em>name</em>, <em>priority</em>, <em>context</em>, <em>connection_state_callback</em>, <em>access_rights_callback</em>, <em>timeout</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#PV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.PV" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents one PV, specified by a name and priority.</p>
<p>This object may exist prior to connection and persists across any
subsequent re-connections.</p>
<p>This object should never be instantiated directly by user code; rather it
should be created by calling the <code class="docutils literal notranslate"><span class="pre">get_pvs</span></code> method on a <code class="docutils literal notranslate"><span class="pre">Context</span></code>
object.</p>
<dl class="method">
<dt id="caproto.threading.client.PV.go_idle">
<code class="descname">go_idle</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#PV.go_idle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.PV.go_idle" title="Permalink to this definition">¶</a></dt>
<dd><p>Request to clear this Channel to reduce load on client and server.</p>
<p>A new Channel will be automatically, silently created the next time any
method requiring a connection is called. Thus, this saves some memory
in exchange for making the next request a bit slower, as it has to
redo the handshake with the server first.</p>
<p>If there are any subscriptions with callbacks, this request will be
ignored. If the PV is in the process of connecting, this request will
be ignored.  If there are any actions in progress (read, write) this
request will be processed when they are complete.</p>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.PV.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>self</em>, <em>*</em>, <em>wait=True</em>, <em>callback=None</em>, <em>timeout=&lt;object object at 0x7fb9247a9750&gt;</em>, <em>data_type=None</em>, <em>data_count=None</em>, <em>notify=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#PV.read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.PV.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Request a fresh reading.</p>
<p>Can do one or both of:
- Block while waiting for the response, and return it.
- Pass the response to callback, with or without blocking.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>wait</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">If True (default) block until a matching response is
received from the server. Raises CaprotoTimeoutError if that
response is not received within the time specified by the <cite>timeout</cite>
parameter.</p>
</dd>
<dt><strong>callback</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable or None</span></dt>
<dd><p class="first last">Called with the response as its argument when received.</p>
</dd>
<dt><strong>timeout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number or None, optional</span></dt>
<dd><p class="first last">Seconds to wait before a CaprotoTimeoutError is raised. Default is
<code class="docutils literal notranslate"><span class="pre">PV.timeout</span></code>, which falls back to <code class="docutils literal notranslate"><span class="pre">PV.context.timeout</span></code> if not
set. If None, never timeout.</p>
</dd>
<dt><strong>data_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘native’, ‘status’, ‘time’, ‘graphic’, ‘control’} or ChannelType or int ID, optional</span></dt>
<dd><p class="first last">Request specific data type or a class of data types, matched to the
channel’s native data type. Default is Channel’s native data type.</p>
</dd>
<dt><strong>data_count</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer, optional</span></dt>
<dd><p class="first last">Requested number of values. Default is the channel’s native data
count.</p>
</dd>
<dt><strong>notify: boolean, optional</strong></dt>
<dd><p class="first last">Send a <code class="docutils literal notranslate"><span class="pre">ReadNotifyRequest</span></code> instead of a <code class="docutils literal notranslate"><span class="pre">ReadRequest</span></code>. True by
default.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.PV.subscribe">
<code class="descname">subscribe</code><span class="sig-paren">(</span><em>self</em>, <em>data_type=None</em>, <em>data_count=None</em>, <em>low=0.0</em>, <em>high=0.0</em>, <em>to=0.0</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#PV.subscribe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.PV.subscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a new subscription to which user callback may be added.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘native’, ‘status’, ‘time’, ‘graphic’, ‘control’} or ChannelType or int ID, optional</span></dt>
<dd><p class="first last">Request specific data type or a class of data types, matched to the
channel’s native data type. Default is Channel’s native data type.</p>
</dd>
<dt><strong>data_count</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer, optional</span></dt>
<dd><p class="first last">Requested number of values. Default is the channel’s native data
count.</p>
</dd>
<dt><strong>low, high, to</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">deprecated by Channel Access, not yet implemented by caproto</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">SubscriptionType, optional</span></dt>
<dd><p class="first last">Subscribe to selective updates.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>subscription</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Subscription</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Define a subscription.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">subscribe</span><span class="p">()</span>
</pre></div>
</div>
<p>Add a user callback. The subscription will be transparently activated
(i.e. an <code class="docutils literal notranslate"><span class="pre">EventAddRequest</span></code> will be sent) when the first user callback
is added.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="n">my_func</span><span class="p">)</span>
</pre></div>
</div>
<p>Multiple callbacks may be added to the same subscription.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="n">another_func</span><span class="p">)</span>
</pre></div>
</div>
<p>See the docstring for <a class="reference internal" href="#caproto.threading.client.Subscription" title="caproto.threading.client.Subscription"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subscription</span></code></a> for more.</p>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.PV.time_since_last_heard">
<code class="descname">time_since_last_heard</code><span class="sig-paren">(</span><em>self</em>, <em>timeout=&lt;object object at 0x7fb9247a9750&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#PV.time_since_last_heard"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.PV.time_since_last_heard" title="Permalink to this definition">¶</a></dt>
<dd><p>Seconds since last message from the server that provides this channel.</p>
<p>The time is reset to 0 whenever we receive a TCP message related to
user activity <em>or</em> a Beacon. Servers are expected to send Beacons at
regular intervals. If we do not receive either a Beacon or TCP message,
we initiate an Echo over TCP, to which the server is expected to
promptly respond.</p>
<p>Therefore, the time reported here should not much exceed
<code class="docutils literal notranslate"><span class="pre">EPICS_CA_CONN_TMO</span></code> (default 30 seconds unless overriden by that
environment variable) if the server is healthy.</p>
<p>If the server fails to send a Beacon on schedule <em>and</em> fails to reply to
an Echo, the server is assumed dead. A warning is issued, and all PVs
are disconnected to initiate a reconnection attempt.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>timeout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number or None, optional</span></dt>
<dd><p class="first last">Seconds to wait before a CaprotoTimeoutError is raised. Default is
<code class="docutils literal notranslate"><span class="pre">PV.timeout</span></code>, which falls back to <code class="docutils literal notranslate"><span class="pre">PV.context.timeout</span></code> if not
set. If None, never timeout.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="caproto.threading.client.PV.timeout">
<code class="descname">timeout</code><a class="headerlink" href="#caproto.threading.client.PV.timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Effective default timeout.</p>
<p>Valid values are:
* CONTEXT_DEFAULT_TIMEOUT (fall back to Context.timeout)
* a floating-point number
* None (never timeout)</p>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.PV.unsubscribe_all">
<code class="descname">unsubscribe_all</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#PV.unsubscribe_all"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.PV.unsubscribe_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear all subscriptions. (Remove all user callbacks from them.)</p>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.PV.wait_for_connection">
<code class="descname">wait_for_connection</code><span class="sig-paren">(</span><em>self</em>, <em>*</em>, <em>timeout=&lt;object object at 0x7fb9247a9750&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#PV.wait_for_connection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.PV.wait_for_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for this PV to be connected.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>timeout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number or None, optional</span></dt>
<dd><p class="first last">Seconds to wait before a CaprotoTimeoutError is raised. Default is
<code class="docutils literal notranslate"><span class="pre">PV.timeout</span></code>, which falls back to <code class="docutils literal notranslate"><span class="pre">PV.context.timeout</span></code> if not
set. If None, never timeout.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.PV.wait_for_search">
<code class="descname">wait_for_search</code><span class="sig-paren">(</span><em>self</em>, <em>*</em>, <em>timeout=&lt;object object at 0x7fb9247a9750&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#PV.wait_for_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.PV.wait_for_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for this PV to be found.</p>
<p>This does not wait for the PV’s Channel to be created; it merely waits
for an address (and a VirtualCircuit) to be assigned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>timeout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number or None, optional</span></dt>
<dd><p class="first last">Seconds to wait before a CaprotoTimeoutError is raised. Default is
<code class="docutils literal notranslate"><span class="pre">PV.timeout</span></code>, which falls back to Context.timeout if not set. If
None, never timeout.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.PV.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>self</em>, <em>data</em>, <em>*</em>, <em>wait=True</em>, <em>callback=None</em>, <em>timeout=&lt;object object at 0x7fb9247a9750&gt;</em>, <em>notify=None</em>, <em>data_type=None</em>, <em>data_count=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#PV.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.PV.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a new value. Optionally, request confirmation from the server.</p>
<p>Can do one or both of:
- Block while waiting for the response, and return it.
- Pass the response to callback, with or without blocking.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, int, or float or any Iterable of these</span></dt>
<dd><p class="first last">Value(s) to write.</p>
</dd>
<dt><strong>wait</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">If True (default) block until a matching WriteNotifyResponse is
received from the server. Raises CaprotoTimeoutError if that
response is not received within the time specified by the <cite>timeout</cite>
parameter.</p>
</dd>
<dt><strong>callback</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable or None</span></dt>
<dd><p class="first last">Called with the WriteNotifyResponse as its argument when received.</p>
</dd>
<dt><strong>timeout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number or None, optional</span></dt>
<dd><p class="first last">Seconds to wait before a CaprotoTimeoutError is raised. Default is
<code class="docutils literal notranslate"><span class="pre">PV.timeout</span></code>, which falls back to <code class="docutils literal notranslate"><span class="pre">PV.context.timeout</span></code> if not
set. If None, never timeout.</p>
</dd>
<dt><strong>notify</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean or None</span></dt>
<dd><p class="first last">If None (default), set to True if wait=True or callback is set.
Can be manually set to True or False. Will raise ValueError if set
to False while wait=True or callback is set.</p>
</dd>
<dt><strong>data_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘native’, ‘status’, ‘time’, ‘graphic’, ‘control’} or ChannelType or int ID, optional</span></dt>
<dd><p class="first last">Write specific data type or a class of data types, matched to the
channel’s native data type. Default is Channel’s native data type.</p>
</dd>
<dt><strong>data_count</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer, optional</span></dt>
<dd><p class="first last">Requested number of values. Default is the channel’s native data
count.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="caproto.threading.client.Subscription">
<em class="property">class </em><code class="descclassname">caproto.threading.client.</code><code class="descname">Subscription</code><span class="sig-paren">(</span><em>pv</em>, <em>data_type</em>, <em>data_count</em>, <em>low</em>, <em>high</em>, <em>to</em>, <em>mask</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#Subscription"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.Subscription" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents one subscription, specified by a PV and configurational parameters</p>
<p>It may fan out to zero, one, or multiple user-registered callback
functions.</p>
<p>This object should never be instantiated directly by user code; rather
it should be made by calling the <code class="docutils literal notranslate"><span class="pre">subscribe()</span></code> method on a <code class="docutils literal notranslate"><span class="pre">PV</span></code> object.</p>
<dl class="method">
<dt id="caproto.threading.client.Subscription.add_callback">
<code class="descname">add_callback</code><span class="sig-paren">(</span><em>self</em>, <em>func</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#Subscription.add_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.Subscription.add_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback to receive responses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">Expected signature: <code class="docutils literal notranslate"><span class="pre">func(response)</span></code></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>token</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Integer token that can be passed to <a class="reference internal" href="#caproto.threading.client.Subscription.remove_callback" title="caproto.threading.client.Subscription.remove_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove_callback()</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.Subscription.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#Subscription.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.Subscription.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all callbacks.</p>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.Subscription.remove_callback">
<code class="descname">remove_callback</code><span class="sig-paren">(</span><em>self</em>, <em>token</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#Subscription.remove_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.Subscription.remove_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove callback using token that was returned by <a class="reference internal" href="#caproto.threading.client.Subscription.add_callback" title="caproto.threading.client.Subscription.add_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_callback()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>token</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Token returned by <a class="reference internal" href="#caproto.threading.client.Subscription.add_callback" title="caproto.threading.client.Subscription.add_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_callback()</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="caproto.threading.client.Batch">
<em class="property">class </em><code class="descclassname">caproto.threading.client.</code><code class="descname">Batch</code><span class="sig-paren">(</span><em>timeout=2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#Batch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.Batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Accumulate requests and then issue them all in batch.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>timeout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number or None</span></dt>
<dd><p class="first last">Number of seconds to wait before ignoring late responses. Default
is 2.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Read some PVs in batch and stash the readings in a dictionary as they
come in.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">stash_result</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">results</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Batch</span><span class="p">()</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">pv</span> <span class="ow">in</span> <span class="n">pvs</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">b</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">stash_result</span><span class="p">,</span> <span class="n">pv</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
<span class="gp">... </span>    <span class="c1"># The requests are sent upon exiting this &#39;with&#39; block.</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">results</span></code> dictionary will be populated as responses come in.</p>
<dl class="method">
<dt id="caproto.threading.client.Batch.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>self</em>, <em>pv</em>, <em>callback</em>, <em>data_type=None</em>, <em>data_count=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#Batch.read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.Batch.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Request a fresh reading as part of a batched request.</p>
<p>Notice that, unlike <a class="reference internal" href="#caproto.threading.client.PV.read" title="caproto.threading.client.PV.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PV.read()</span></code></a>, the callback is required. (There
is no other way to get the result back from a batched read.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PV</span></dt>
<dd></dd>
<dt><strong>callback</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">Expected signature: <code class="docutils literal notranslate"><span class="pre">f(response)</span></code></p>
</dd>
<dt><strong>data_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘native’, ‘status’, ‘time’, ‘graphic’, ‘control’} or ChannelType or int ID, optional</span></dt>
<dd><p class="first last">Request specific data type or a class of data types, matched to the
channel’s native data type. Default is Channel’s native data type.</p>
</dd>
<dt><strong>data_count</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer, optional</span></dt>
<dd><p class="first last">Requested number of values. Default is the channel’s native data
count.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.Batch.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>self</em>, <em>pv</em>, <em>data</em>, <em>callback=None</em>, <em>data_type=None</em>, <em>data_count=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#Batch.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.Batch.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a new value as part of a batched request.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PV</span></dt>
<dd></dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, int, or float or any Iterable of these</span></dt>
<dd><p class="first last">Value(s) to write.</p>
</dd>
<dt><strong>callback</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">Expected signature: <code class="docutils literal notranslate"><span class="pre">f(response)</span></code></p>
</dd>
<dt><strong>data_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘native’, ‘status’, ‘time’, ‘graphic’, ‘control’} or ChannelType or int ID, optional</span></dt>
<dd><p class="first last">Request specific data type or a class of data types, matched to the
channel’s native data type. Default is Channel’s native data type.</p>
</dd>
<dt><strong>data_count</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer, optional</span></dt>
<dd><p class="first last">Requested number of values. Default is the channel’s native data
count.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<p>The following are internal components. There API may change in the future.</p>
<dl class="class">
<dt id="caproto.threading.client.VirtualCircuitManager">
<em class="property">class </em><code class="descclassname">caproto.threading.client.</code><code class="descname">VirtualCircuitManager</code><span class="sig-paren">(</span><em>context</em>, <em>circuit</em>, <em>selector</em>, <em>timeout=2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#VirtualCircuitManager"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.VirtualCircuitManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Encapsulates a VirtualCircuit, a TCP socket, and additional state</p>
<p>This object should never be instantiated directly by user code. It is used
internally by the Context. Its methods may be touched by user code, but
this is rarely necessary.</p>
<dl class="method">
<dt id="caproto.threading.client.VirtualCircuitManager.events_off">
<code class="descname">events_off</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#VirtualCircuitManager.events_off"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.VirtualCircuitManager.events_off" title="Permalink to this definition">¶</a></dt>
<dd><p>Suspend updates to all subscriptions on this circuit.</p>
<p>This may be useful if the server produces updates faster than the
client can processs them.</p>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.VirtualCircuitManager.events_on">
<code class="descname">events_on</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#VirtualCircuitManager.events_on"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.VirtualCircuitManager.events_on" title="Permalink to this definition">¶</a></dt>
<dd><p>Reactive updates to all subscriptions on this circuit.</p>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.VirtualCircuitManager.received">
<code class="descname">received</code><span class="sig-paren">(</span><em>self</em>, <em>bytes_recv</em>, <em>address</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#VirtualCircuitManager.received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.VirtualCircuitManager.received" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive and process and next command from the virtual circuit.</p>
<p>This will be run on the recv thread</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="caproto.threading.client.SharedBroadcaster">
<em class="property">class </em><code class="descclassname">caproto.threading.client.</code><code class="descname">SharedBroadcaster</code><span class="sig-paren">(</span><em>*</em>, <em>registration_retry_time=10.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#SharedBroadcaster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.SharedBroadcaster" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="caproto.threading.client.SharedBroadcaster.cancel">
<code class="descname">cancel</code><span class="sig-paren">(</span><em>self</em>, <em>*names</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#SharedBroadcaster.cancel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.SharedBroadcaster.cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel searches for these names.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>*names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">strings</span></dt>
<dd><p class="first last">any number of PV names</p>
</dd>
<dt><strong>Any PV instances that were awaiting these results will be stuck until</strong></dt>
<dd></dd>
<dt><strong>:meth:`get_pvs` is called again.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.SharedBroadcaster.get_cached_search_result">
<code class="descname">get_cached_search_result</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>*</em>, <em>threshold=10.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#SharedBroadcaster.get_cached_search_result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.SharedBroadcaster.get_cached_search_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns address if found, raises KeyError if missing or stale.</p>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.SharedBroadcaster.received">
<code class="descname">received</code><span class="sig-paren">(</span><em>self</em>, <em>bytes_recv</em>, <em>address</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#SharedBroadcaster.received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.SharedBroadcaster.received" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive and process and next command broadcasted over UDP.</p>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.SharedBroadcaster.search">
<code class="descname">search</code><span class="sig-paren">(</span><em>self</em>, <em>results_queue</em>, <em>names</em>, <em>*</em>, <em>timeout=2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#SharedBroadcaster.search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.SharedBroadcaster.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for PV names.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">results_queue</span></code> will receive <code class="docutils literal notranslate"><span class="pre">(address,</span> <span class="pre">names)</span></code> (the address of
a server and a list of name(s) that it has) when results are received.</p>
<p>If a cached result is already known, it will be put immediately into
<code class="docutils literal notranslate"><span class="pre">results_queue</span></code> from this thread during this method’s execution.</p>
<p>If not, a SearchRequest will be sent from another thread. If necessary,
the request will be re-sent periodically. When a matching response is
received (by yet another thread) <code class="docutils literal notranslate"><span class="pre">(address,</span> <span class="pre">names)</span></code> will be put into
the <code class="docutils literal notranslate"><span class="pre">results_queue</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.SharedBroadcaster.search_now">
<code class="descname">search_now</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#SharedBroadcaster.search_now"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.SharedBroadcaster.search_now" title="Permalink to this definition">¶</a></dt>
<dd><p>Force the Broadcaster to reissue all unanswered search requests now.</p>
<p>Left to its own devices, the Broadcaster will do this at regular
intervals automatically. This method is intended primarily for
debugging and should not be needed in normal use.</p>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.SharedBroadcaster.send">
<code class="descname">send</code><span class="sig-paren">(</span><em>self</em>, <em>port</em>, <em>*commands</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#SharedBroadcaster.send"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.SharedBroadcaster.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a command and transport it over the UDP socket.</p>
</dd></dl>

<dl class="method">
<dt id="caproto.threading.client.SharedBroadcaster.time_since_last_heard">
<code class="descname">time_since_last_heard</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/caproto/threading/client.html#SharedBroadcaster.time_since_last_heard"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#caproto.threading.client.SharedBroadcaster.time_since_last_heard" title="Permalink to this definition">¶</a></dt>
<dd><p>Map each known server address to seconds since its last message.</p>
<p>The time is reset to 0 whenever we receive a TCP message related to
user activity <em>or</em> a Beacon. Servers are expected to send Beacons at
regular intervals. If we do not receive either a Beacon or TCP message,
we initiate an Echo over TCP, to which the server is expected to
promptly respond.</p>
<p>Therefore, the time reported here should not much exceed
<code class="docutils literal notranslate"><span class="pre">EPICS_CA_CONN_TMO</span></code> (default 30 seconds unless overriden by that
environment variable) if the server is healthy.</p>
<p>If the server fails to send a Beacon on schedule <em>and</em> fails to reply to
an Echo, the server is assumed dead. A warning is issued, and all PVs
are disconnected to initiate a reconnection attempt.</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pyepics-compat-client.html" class="btn btn-neutral float-right" title="Pyepics-Compatible Client" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="sync-client.html" class="btn btn-neutral float-left" title="Synchronous Client" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Daniel Allan

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>