

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>caproto.threading.client &mdash; caproto 0.5.2+13.gce8a146.dirty documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> caproto
          

          
          </a>

          
            
            
              <div class="version">
                0.5.2+13.gce8a146.dirty
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Install Caproto</a></li>
</ul>
<p class="caption"><span class="caption-text">EPICS Clients and Servers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../clients.html">Clients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../iocs.html">Input-Output Controllers (IOCs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../records.html">Records</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../servers.html">Servers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../shark.html">Shark (pcap/tcpdump parsing)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../loggers.html">Logging</a></li>
</ul>
<p class="caption"><span class="caption-text">Channel Access Sans I/O</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html">Writing Your Own Channel Access Client</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">Core API Documentation</a></li>
</ul>
<p class="caption"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://nsls-ii.github.io/caproto/bench/#/">Performance Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../protocol-compliance.html">Details of our Protocol Compliance for CA Nerds</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release-notes.html">Release History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../containers.html">Caproto-in-a-box</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">caproto</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>caproto.threading.client</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for caproto.threading.client</h1><div class="highlight"><pre>
<span></span><span class="c1"># Regarding threads...</span>
<span class="c1"># The SharedBroadcaster has:</span>
<span class="c1"># - UDP socket SelectorThread</span>
<span class="c1"># - UDP command processing</span>
<span class="c1"># - forever retrying search requests for disconnected PV</span>
<span class="c1"># The Context has:</span>
<span class="c1"># - process search results</span>
<span class="c1"># - TCP socket SelectorThread</span>
<span class="c1"># - restart subscriptions</span>
<span class="c1"># The VirtualCircuit has:</span>
<span class="c1"># - ThreadPoolExecutor for processing user callbacks on read, write, subscribe</span>
<span class="kn">import</span> <span class="nn">array</span>
<span class="kn">import</span> <span class="nn">concurrent.futures</span>
<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">getpass</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">selectors</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span><span class="p">,</span> <span class="n">Empty</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">Signature</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">import</span> <span class="nn">caproto</span> <span class="k">as</span> <span class="nn">ca</span>
<span class="kn">from</span> <span class="nn">.._constants</span> <span class="kn">import</span> <span class="p">(</span><span class="n">MAX_ID</span><span class="p">,</span> <span class="n">STALE_SEARCH_EXPIRATION</span><span class="p">,</span>
                          <span class="n">SEARCH_MAX_DATAGRAM_BYTES</span><span class="p">,</span> <span class="n">RESPONSIVENESS_TIMEOUT</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.._utils</span> <span class="kn">import</span> <span class="p">(</span><span class="n">adapt_old_callback_signature</span><span class="p">,</span>
                      <span class="n">batch_requests</span><span class="p">,</span> <span class="n">CaprotoError</span><span class="p">,</span> <span class="n">ThreadsafeCounter</span><span class="p">,</span>
                      <span class="n">socket_bytes_available</span><span class="p">,</span> <span class="n">CaprotoTimeoutError</span><span class="p">,</span>
                      <span class="n">CaprotoTypeError</span><span class="p">,</span> <span class="n">CaprotoRuntimeError</span><span class="p">,</span> <span class="n">CaprotoValueError</span><span class="p">,</span>
                      <span class="n">CaprotoKeyError</span><span class="p">,</span> <span class="n">CaprotoNetworkError</span><span class="p">,</span> <span class="n">safe_getsockname</span><span class="p">)</span>


<span class="n">ch_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;caproto.ch&#39;</span><span class="p">)</span>
<span class="n">search_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;caproto.bcast.search&#39;</span><span class="p">)</span>


<span class="n">CIRCUIT_DEATH_ATTEMPTS</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c1"># sentinels used as default values for arguments</span>
<span class="n">CONTEXT_DEFAULT_TIMEOUT</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="n">PV_DEFAULT_TIMEOUT</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="n">GLOBAL_DEFAULT_TIMEOUT</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CAPROTO_DEFAULT_TIMEOUT&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DeadCircuitError</span><span class="p">(</span><span class="n">CaprotoError</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">def</span> <span class="nf">ensure_connected</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PV</span><span class="p">):</span>
            <span class="n">pv</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Subscription</span><span class="p">):</span>
            <span class="n">pv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CaprotoTypeError</span><span class="p">(</span><span class="s2">&quot;ensure_connected is intended to decorate &quot;</span>
                                   <span class="s2">&quot;methods of PV and Subscription.&quot;</span><span class="p">)</span>
        <span class="c1"># timeout may be decremented during disconnection-retry loops below.</span>
        <span class="c1"># Keep a copy of the original &#39;raw_timeout&#39; for use in error messages.</span>
        <span class="n">raw_timeout</span> <span class="o">=</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;timeout&#39;</span><span class="p">,</span> <span class="n">pv</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">deadline</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span>
        <span class="k">with</span> <span class="n">pv</span><span class="o">.</span><span class="n">_in_use</span><span class="p">:</span>
            <span class="c1"># If needed, reconnect. Do this inside the lock so that we don&#39;t</span>
            <span class="c1"># try to do this twice. (No other threads that need this lock</span>
            <span class="c1"># can proceed until the connection is ready anyway!)</span>
            <span class="k">if</span> <span class="n">pv</span><span class="o">.</span><span class="n">_idle</span><span class="p">:</span>
                <span class="c1"># The Context should have been maintaining a working circuit</span>
                <span class="c1"># for us while this was idle. We just need to re-create the</span>
                <span class="c1"># Channel.</span>
                <span class="n">ready</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">circuit_ready</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ready</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">CaprotoTimeoutError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pv</span><span class="si">}</span><span class="s2"> could not connect within &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">raw_timeout</span><span class="p">)</span><span class="si">:</span><span class="s2">.3</span><span class="si">}</span><span class="s2">-second timeout.&quot;</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">pv</span><span class="o">.</span><span class="n">component_lock</span><span class="p">:</span>
                    <span class="n">cm</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">circuit_manager</span>
                    <span class="n">cid</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">new_channel_id</span><span class="p">()</span>
                    <span class="n">chan</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">ClientChannel</span><span class="p">(</span><span class="n">pv</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">circuit</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">cid</span><span class="p">)</span>
                    <span class="n">cm</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan</span>
                    <span class="n">cm</span><span class="o">.</span><span class="n">pvs</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span> <span class="o">=</span> <span class="n">pv</span>
                    <span class="n">pv</span><span class="o">.</span><span class="n">circuit_manager</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">chan</span><span class="o">.</span><span class="n">create</span><span class="p">(),</span> <span class="n">extra</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;pv&#39;</span><span class="p">:</span> <span class="n">pv</span><span class="o">.</span><span class="n">name</span><span class="p">})</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_idle</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># increment the usage at the very end in case anything</span>
            <span class="c1"># goes wrong in the block of code above this.</span>
            <span class="n">pv</span><span class="o">.</span><span class="n">_usages</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">CIRCUIT_DEATH_ATTEMPTS</span><span class="p">):</span>
                <span class="c1"># On each iteration, subtract the time we already spent on any</span>
                <span class="c1"># previous attempts.</span>
                <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">timeout</span> <span class="o">=</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
                <span class="n">ready</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">channel_ready</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ready</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">CaprotoTimeoutError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pv</span><span class="si">}</span><span class="s2"> could not connect within &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">raw_timeout</span><span class="p">)</span><span class="si">:</span><span class="s2">.3</span><span class="si">}</span><span class="s2">-second timeout.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">timeout</span> <span class="o">=</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;timeout&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">timeout</span>

                <span class="n">cm</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">circuit_manager</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">DeadCircuitError</span><span class="p">:</span>
                    <span class="c1"># Something in func tried operate on the circuit after</span>
                    <span class="c1"># it died. The context will automatically build us a</span>
                    <span class="c1"># new circuit. Try again.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Caught DeadCircuitError. &#39;</span>
                                   <span class="s1">&#39;Retrying </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">except</span> <span class="ne">TimeoutError</span><span class="p">:</span>
                    <span class="c1"># The circuit may have died after func was done calling</span>
                    <span class="c1"># methods on it but before we received some response we</span>
                    <span class="c1"># were expecting. The context will automatically build</span>
                    <span class="c1"># us a new circuit. Try again.</span>
                    <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">dead</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Caught TimeoutError due to dead &#39;</span>
                                       <span class="s1">&#39;circuit. &#39;</span>
                                       <span class="s1">&#39;Retrying </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="c1"># The circuit is fine -- this is a real error.</span>
                    <span class="k">raise</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">pv</span><span class="o">.</span><span class="n">_in_use</span><span class="p">:</span>
                <span class="n">pv</span><span class="o">.</span><span class="n">_usages</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">pv</span><span class="o">.</span><span class="n">_in_use</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">inner</span>


<span class="k">class</span> <span class="nc">ThreadingClientException</span><span class="p">(</span><span class="n">CaprotoError</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">DisconnectedError</span><span class="p">(</span><span class="n">ThreadingClientException</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">ContextDisconnectedError</span><span class="p">(</span><span class="n">ThreadingClientException</span><span class="p">):</span>
    <span class="o">...</span>


<span class="n">AUTOMONITOR_MAXLENGTH</span> <span class="o">=</span> <span class="mi">65536</span>
<span class="n">TIMEOUT</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">EVENT_ADD_BATCH_MAX_BYTES</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span>
<span class="n">MIN_RETRY_SEARCHES_INTERVAL</span> <span class="o">=</span> <span class="mf">0.03</span>
<span class="n">MAX_RETRY_SEARCHES_INTERVAL</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">SEARCH_RETIREMENT_AGE</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">60</span>
<span class="n">RETRY_RETIRED_SEARCHES_INTERVAL</span> <span class="o">=</span> <span class="mi">60</span>
<span class="n">RESTART_SUBS_PERIOD</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">STR_ENC</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;CAPROTO_STRING_ENCODING&#39;</span><span class="p">,</span> <span class="s1">&#39;latin-1&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SelectorThread</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is used internally by the Context and the VirtualCircuitManager.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thread</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># set by the `start` method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">DefaultSelector</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_register_event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_socket_map_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakValueDictionary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket_to_id</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_register_sockets</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># {socket: object_id}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unregister_sockets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_object_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_socket_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Stop the selector if the parent goes out of scope</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">running</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Selector thread is running&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

        <span class="c1"># In case we&#39;re waiting for the first socket to be added:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_register_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">CaprotoRuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot be restarted once stopped.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">name</span><span class="o">=</span><span class="s1">&#39;selector&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_socket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">target_obj</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_socket_map_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sock</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket_to_id</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CaprotoValueError</span><span class="p">(</span><span class="s1">&#39;Socket already added&#39;</span><span class="p">)</span>

            <span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># assumption: only one sock per object</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_object_id</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_object_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_obj</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">socket_to_id</span><span class="p">[</span><span class="n">sock</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_object_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_register_sockets</span><span class="p">[</span><span class="n">sock</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_object_id</span>
            <span class="n">weakref</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">target_obj</span><span class="p">,</span>
                             <span class="k">lambda</span> <span class="n">sock</span><span class="o">=</span><span class="n">sock</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">))</span>
            <span class="c1"># self.log.debug(&#39;Socket %s was added (obj %s)&#39;, sock, target_obj)</span>

    <span class="k">def</span> <span class="nf">remove_socket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_socket_map_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sock</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket_to_id</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">obj_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket_to_id</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">obj_id</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">received</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># removed before it was even added...</span>
                <span class="c1"># self.log.debug(&#39;Socket %s was removed before it was added &#39;</span>
                <span class="c1">#              &#39;(obj = %s)&#39;, sock, obj)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_register_sockets</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># self.log.debug(&#39;Socket %s was removed &#39;</span>
                <span class="c1">#              &#39;(obj = %s)&#39;, sock, obj)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unregister_sockets</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Selector poll loop&#39;&#39;&#39;</span>
        <span class="n">avail_buf</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_socket_map_lock</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sock</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unregister_sockets</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_socket_count</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unregister_sockets</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unregister_sockets</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">sock</span><span class="p">,</span> <span class="n">obj_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_register_sockets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">selectors</span><span class="o">.</span><span class="n">EVENT_READ</span><span class="p">,</span>
                                           <span class="n">data</span><span class="o">=</span><span class="n">obj_id</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_socket_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_register_sockets</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_register_sockets</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_socket_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_register_event</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_register_event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="k">continue</span>

            <span class="n">events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_socket_map_lock</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unregister_sockets</span><span class="p">:</span>
                    <span class="c1"># some sockets may be affected here; try again</span>
                    <span class="k">continue</span>

                <span class="n">object_and_socket</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">data</span><span class="p">],</span> <span class="n">key</span><span class="o">.</span><span class="n">fileobj</span><span class="p">)</span>
                                     <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">events</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">obj</span><span class="p">,</span> <span class="n">sock</span> <span class="ow">in</span> <span class="n">object_and_socket</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sock</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unregister_sockets</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># TODO: consider thread pool for recv and command_loop</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">bytes_available</span> <span class="o">=</span> <span class="n">socket_bytes_available</span><span class="p">(</span>
                        <span class="n">sock</span><span class="p">,</span> <span class="n">available_buffer</span><span class="o">=</span><span class="n">avail_buf</span><span class="p">)</span>
                    <span class="n">bytes_recv</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="n">bytes_available</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ex</span><span class="o">.</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">errno</span><span class="o">.</span><span class="n">EAGAIN</span><span class="p">:</span>
                        <span class="c1"># register as a disconnection</span>
                        <span class="n">obj</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Removing </span><span class="si">%s</span><span class="s1"> due to </span><span class="si">%s</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span>
                                      <span class="n">ex</span><span class="o">.</span><span class="n">errno</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remove_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Let objects handle disconnection by return value</span>
                    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">received</span><span class="p">(</span><span class="n">bytes_recv</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ca</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
                        <span class="n">obj</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Removing </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%s</span><span class="s1"> after DISCONNECTED &#39;</span>
                                      <span class="s1">&#39;return value&#39;</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remove_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
                        <span class="c1"># TODO: consider adding specific DISCONNECTED instead</span>
                        <span class="c1"># of b&#39;&#39; sent to disconnected sockets</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sock</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_DGRAM</span><span class="p">:</span>
                        <span class="n">obj</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span>
                            <span class="s1">&#39;UDP socket for </span><span class="si">%s</span><span class="s1"> failed on receipt of &#39;</span>
                            <span class="s1">&#39;new data: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">obj</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span>
                            <span class="s1">&#39;Removing </span><span class="si">%s</span><span class="s1"> due to an internal error on receipt of &#39;</span>
                            <span class="s1">&#39;new data: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remove_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>


<div class="viewcode-block" id="SharedBroadcaster"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.SharedBroadcaster">[docs]</a><span class="k">class</span> <span class="nc">SharedBroadcaster</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">registration_retry_time</span><span class="o">=</span><span class="mf">10.0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        A broadcaster client which can be shared among multiple Contexts</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        registration_retry_time : float, optional</span>
<span class="sd">            The time, in seconds, between attempts made to register with the</span>
<span class="sd">            repeater. Default is 10.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">environ</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">get_environment_variables</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ca_server_port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;EPICS_CA_SERVER_PORT&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">udp_sock</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">bcast_socket</span><span class="p">()</span>
        <span class="c1"># Must bind or getsocketname() will raise on Windows.</span>
        <span class="c1"># See https://github.com/caproto/caproto/issues/514.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">udp_sock</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_search_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_retry_unanswered_searches_thread</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># This Event ensures that we send a registration request before our</span>
        <span class="c1"># first search request.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_searching_enabled</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="c1"># This Event lets us nudge the search thread when the user asks for new</span>
        <span class="c1"># PVs (via Context.get_pvs).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_search_now</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">search_results</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># map name to (time, address)</span>
        <span class="c1"># map search id (cid) to [name, queue, last_search_time, retirement_deadline]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unanswered_searches</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server_protocol_versions</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># map address to protocol version</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_id_counter</span> <span class="o">=</span> <span class="n">ThreadsafeCounter</span><span class="p">(</span>
            <span class="n">initial_value</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MAX_ID</span><span class="p">),</span>
            <span class="n">dont_clash_with</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unanswered_searches</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakSet</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">Broadcaster</span><span class="p">(</span><span class="n">our_role</span><span class="o">=</span><span class="n">ca</span><span class="o">.</span><span class="n">CLIENT</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">client_address</span> <span class="o">=</span> <span class="n">safe_getsockname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">udp_sock</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">LoggerAdapter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">log</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;role&#39;</span><span class="p">:</span> <span class="s1">&#39;CLIENT&#39;</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">LoggerAdapter</span><span class="p">(</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;caproto.bcast.search&#39;</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;role&#39;</span><span class="p">:</span> <span class="s1">&#39;CLIENT&#39;</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_bundle_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_beacon</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_beacon_interval</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># an event to tear down and clean up the broadcaster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">SelectorThread</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">add_socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">udp_sock</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_command_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">command_loop</span><span class="p">,</span>
                                                <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;command&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_command_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_for_unresponsive_servers_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_for_unresponsive_servers</span><span class="p">,</span>
            <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;check_for_unresponsive_servers&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_for_unresponsive_servers_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_registration_retry_time</span> <span class="o">=</span> <span class="n">registration_retry_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_registration_last_sent</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Always attempt registration on initialization, but allow failures</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_register</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Broadcaster registration failed on init&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_should_attempt_registration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;Whether or not a registration attempt should be tried&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">udp_sock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">registered</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_registration_retry_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">since_last_attempt</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_registration_last_sent</span>
        <span class="k">if</span> <span class="n">since_last_attempt</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_registration_retry_time</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_register</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;Send a registration request to the repeater&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_registration_last_sent</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
        <span class="n">command</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">register</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">ca</span><span class="o">.</span><span class="n">EPICS_CA2_PORT</span><span class="p">,</span> <span class="n">command</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_searching_enabled</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">new_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id_counter</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listener</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retry_unanswered_searches_thread</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_retry_unanswered_searches_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span>
                    <span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_retry_unanswered_searches</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;retry&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_retry_unanswered_searches_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">listener</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listener</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">listener</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">udp_sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">remove_socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">udp_sock</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">udp_sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">udp_sock</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_close_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">search_results</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_registration_last_sent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_searching_enabled</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">wait</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_command_thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_retry_unanswered_searches_thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<div class="viewcode-block" id="SharedBroadcaster.send"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.SharedBroadcaster.send">[docs]</a>    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">*</span><span class="n">commands</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process a command and transport it over the UDP socket.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bytes_to_send</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="o">*</span><span class="n">commands</span><span class="p">)</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;role&#39;</span><span class="p">:</span> <span class="s1">&#39;CLIENT&#39;</span><span class="p">,</span>
                <span class="s1">&#39;our_address&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">client_address</span><span class="p">,</span>
                <span class="s1">&#39;direction&#39;</span><span class="p">:</span> <span class="s1">&#39;---&gt;&gt;&gt;&#39;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">host</span> <span class="ow">in</span> <span class="n">ca</span><span class="o">.</span><span class="n">get_address_list</span><span class="p">():</span>
            <span class="k">if</span> <span class="s1">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">host</span><span class="p">:</span>
                <span class="n">host</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">port_as_str</span> <span class="o">=</span> <span class="n">host</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
                <span class="n">specified_port</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">port_as_str</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">specified_port</span> <span class="o">=</span> <span class="n">port</span>
            <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;their_address&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">specified_port</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> commands </span><span class="si">%d</span><span class="s1">B&#39;</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">commands</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">bytes_to_send</span><span class="p">),</span> <span class="n">extra</span><span class="o">=</span><span class="n">tags</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">udp_sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">bytes_to_send</span><span class="p">,</span> <span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">specified_port</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CaprotoNetworkError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ex</span><span class="si">}</span><span class="s1"> while sending </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bytes_to_send</span><span class="p">)</span><span class="si">}</span><span class="s1"> bytes to &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">host</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">specified_port</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">ex</span></div>

<div class="viewcode-block" id="SharedBroadcaster.get_cached_search_result"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.SharedBroadcaster.get_cached_search_result">[docs]</a>    <span class="k">def</span> <span class="nf">get_cached_search_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                                 <span class="n">threshold</span><span class="o">=</span><span class="n">STALE_SEARCH_EXPIRATION</span><span class="p">):</span>
        <span class="s1">&#39;Returns address if found, raises KeyError if missing or stale.&#39;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_lock</span><span class="p">:</span>
            <span class="n">address</span><span class="p">,</span> <span class="n">timestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_results</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="c1"># this block of code is only to re-fresh the time found on</span>
        <span class="c1"># any PVs.  If we can find any context which has any circuit which</span>
        <span class="c1"># has any channel talking to this PV name then it is not stale so</span>
        <span class="c1"># re-up the timestamp to now.</span>
        <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">-</span> <span class="n">timestamp</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="c1"># TODO this is very inefficient</span>
            <span class="k">for</span> <span class="n">context</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">circuit_managers</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">connected</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">cm</span><span class="o">.</span><span class="n">all_created_pvnames</span><span class="p">:</span>
                        <span class="c1"># A valid connection exists in one of our clients, so</span>
                        <span class="c1"># ignore the stale result status</span>
                        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_lock</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">search_results</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">())</span>
                        <span class="c1"># TODO verify that addr matches address</span>
                        <span class="k">return</span> <span class="n">address</span>

            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_lock</span><span class="p">:</span>
                <span class="c1"># Clean up expired result.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">search_results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">CaprotoKeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s1">: stale search result&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">address</span></div>

<div class="viewcode-block" id="SharedBroadcaster.search"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.SharedBroadcaster.search">[docs]</a>    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results_queue</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search for PV names.</span>

<span class="sd">        The ``results_queue`` will receive ``(address, names)`` (the address of</span>
<span class="sd">        a server and a list of name(s) that it has) when results are received.</span>

<span class="sd">        If a cached result is already known, it will be put immediately into</span>
<span class="sd">        ``results_queue`` from this thread during this method&#39;s execution.</span>

<span class="sd">        If not, a SearchRequest will be sent from another thread. If necessary,</span>
<span class="sd">        the request will be re-sent periodically. When a matching response is</span>
<span class="sd">        received (by yet another thread) ``(address, names)`` will be put into</span>
<span class="sd">        the ``results_queue``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_should_attempt_registration</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_register</span><span class="p">()</span>

        <span class="n">new_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_id</span>
        <span class="n">unanswered_searches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unanswered_searches</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_lock</span><span class="p">:</span>
            <span class="c1"># We have have already searched for these names recently.</span>
            <span class="c1"># Filter `pv_names` down to a subset, `needs_search`.</span>
            <span class="n">needs_search</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">use_cached_search</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">address</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cached_search_result</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">needs_search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">use_cached_search</span><span class="p">[</span><span class="n">address</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">address</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">use_cached_search</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">results_queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">address</span><span class="p">,</span> <span class="n">names</span><span class="p">))</span>

            <span class="c1"># Generate search_ids and stash them on Context state so they can</span>
            <span class="c1"># be used to match SearchResponses with SearchRequests.</span>
            <span class="n">search_ids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Search requests that are past their retirement deadline with no</span>
            <span class="c1"># results will be searched for less frequently.</span>
            <span class="n">retirement_deadline</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">+</span> <span class="n">SEARCH_RETIREMENT_AGE</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">needs_search</span><span class="p">:</span>
                <span class="n">search_id</span> <span class="o">=</span> <span class="n">new_id</span><span class="p">()</span>
                <span class="n">search_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">search_id</span><span class="p">)</span>
                <span class="c1"># The value is a list because we mutate it to update the</span>
                <span class="c1"># retirement deadline sometimes.</span>
                <span class="n">unanswered_searches</span><span class="p">[</span><span class="n">search_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">results_queue</span><span class="p">,</span>
                                                  <span class="mi">0</span><span class="p">,</span> <span class="n">retirement_deadline</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_search_now</span><span class="o">.</span><span class="n">set</span><span class="p">()</span></div>

<div class="viewcode-block" id="SharedBroadcaster.cancel"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.SharedBroadcaster.cancel">[docs]</a>    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cancel searches for these names.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *names : strings</span>
<span class="sd">            any number of PV names</span>

<span class="sd">        Any PV instances that were awaiting these results will be stuck until</span>
<span class="sd">        :meth:`get_pvs` is called again.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_lock</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">search_id</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unanswered_searches</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">unanswered_searches</span><span class="p">[</span><span class="n">search_id</span><span class="p">]</span></div>

<div class="viewcode-block" id="SharedBroadcaster.search_now"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.SharedBroadcaster.search_now">[docs]</a>    <span class="k">def</span> <span class="nf">search_now</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Force the Broadcaster to reissue all unanswered search requests now.</span>

<span class="sd">        Left to its own devices, the Broadcaster will do this at regular</span>
<span class="sd">        intervals automatically. This method is intended primarily for</span>
<span class="sd">        debugging and should not be needed in normal use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_search_now</span><span class="o">.</span><span class="n">set</span><span class="p">()</span></div>

<div class="viewcode-block" id="SharedBroadcaster.received"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.SharedBroadcaster.received">[docs]</a>    <span class="k">def</span> <span class="nf">received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bytes_recv</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
        <span class="s2">&quot;Receive and process and next command broadcasted over UDP.&quot;</span>
        <span class="k">if</span> <span class="n">bytes_recv</span><span class="p">:</span>
            <span class="n">commands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">bytes_recv</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">commands</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">command_bundle_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">commands</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span></div>

    <span class="k">def</span> <span class="nf">command_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Receive commands in &#39;bundles&#39; (corresponding to the contents of one</span>
        <span class="c1"># UDP datagram). Match SearchResponses to their SearchRequests, and</span>
        <span class="c1"># put (address, (name1, name2, name3, ...)) into a queue. The receiving</span>
        <span class="c1"># end of that queue is held by Context._process_search_results.</span>

        <span class="c1"># Save doing a &#39;self&#39; lookup in the inner loop.</span>
        <span class="n">search_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_results</span>
        <span class="n">server_protocol_versions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">server_protocol_versions</span>
        <span class="n">unanswered_searches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unanswered_searches</span>
        <span class="n">queues</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">results_by_cid</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Broadcaster command loop is running.&#39;</span><span class="p">)</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">commands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">command_bundle_queue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Empty</span><span class="p">:</span>
                <span class="c1"># By restarting the loop, we will first check that we are not</span>
                <span class="c1"># supposed to shut down the thread before we go back to</span>
                <span class="c1"># waiting on the queue again.</span>
                <span class="k">continue</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">process_commands</span><span class="p">(</span><span class="n">commands</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ca</span><span class="o">.</span><span class="n">CaprotoError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Broadcaster command error&#39;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="n">ex</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">queues</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;role&#39;</span><span class="p">:</span> <span class="s1">&#39;CLIENT&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;our_address&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">client_address</span><span class="p">,</span>
                    <span class="s1">&#39;direction&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&lt;&lt;---&#39;</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">Beacon</span><span class="p">):</span>
                    <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
                    <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="n">command</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">command</span><span class="o">.</span><span class="n">server_port</span><span class="p">)</span>
                    <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;their_address&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">address</span>
                    <span class="k">if</span> <span class="n">address</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_beacon</span><span class="p">:</span>
                        <span class="c1"># We made a new friend!</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Watching Beacons from </span><span class="si">%s</span><span class="s2">:</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                                                  <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">tags</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_new_server_found</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">interval</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_beacon</span><span class="p">[</span><span class="n">address</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">interval</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_beacon_interval</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">:</span>
                            <span class="c1"># Beacons are arriving *faster*? The server at this</span>
                            <span class="c1"># address may have restarted.</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                                <span class="s2">&quot;Beacon anomaly: </span><span class="si">%s</span><span class="s2">:</span><span class="si">%d</span><span class="s2"> may have restarted.&quot;</span><span class="p">,</span>
                                <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">tags</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_new_server_found</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">last_beacon_interval</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">last_beacon</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">now</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">VersionResponse</span><span class="p">):</span>
                    <span class="c1"># Per the specification, in CA &lt; 4.11, VersionResponse does</span>
                    <span class="c1"># not include minor version number (it is always 0) and is</span>
                    <span class="c1"># interpreted as an echo command that carries no data.</span>
                    <span class="c1"># Version exchange is performed immediately after channel</span>
                    <span class="c1"># creation.</span>
                    <span class="k">if</span> <span class="n">command</span><span class="o">.</span><span class="n">version</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s2">&quot;Server is speaking some protocol version &quot;</span>
                            <span class="s2">&quot;older than 4.11. It will not report a &quot;</span>
                            <span class="s2">&quot;specific version until a channel is created. &quot;</span>
                            <span class="s2">&quot;Quality of support is unknown.&quot;</span><span class="p">)</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">SearchResponse</span><span class="p">):</span>
                    <span class="n">cid</span> <span class="o">=</span> <span class="n">command</span><span class="o">.</span><span class="n">cid</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_lock</span><span class="p">:</span>
                            <span class="n">name</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">unanswered_searches</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="c1"># This is a redundant response, which the EPICS</span>
                        <span class="c1"># spec tells us to ignore. (The first responder</span>
                        <span class="c1"># to a given request wins.)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">_</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results_by_cid</span> <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cid</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_lock</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">search_results</span><span class="p">:</span>
                                    <span class="n">accepted_address</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">search_results</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                                    <span class="n">new_address</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">extract_address</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">new_address</span> <span class="o">!=</span> <span class="n">accepted_address</span><span class="p">:</span>
                                        <span class="n">search_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                                            <span class="s2">&quot;PV </span><span class="si">%s</span><span class="s2"> with cid </span><span class="si">%d</span><span class="s2"> found on multiple &quot;</span>
                                            <span class="s2">&quot;servers. Accepted address is </span><span class="si">%s</span><span class="s2">:</span><span class="si">%d</span><span class="s2">. &quot;</span>
                                            <span class="s2">&quot;Also found on </span><span class="si">%s</span><span class="s2">:</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                                            <span class="n">name</span><span class="p">,</span> <span class="n">cid</span><span class="p">,</span> <span class="o">*</span><span class="n">accepted_address</span><span class="p">,</span> <span class="o">*</span><span class="n">new_address</span><span class="p">,</span>
                                            <span class="n">extra</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;pv&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
                                                   <span class="s1">&#39;their_address&#39;</span><span class="p">:</span> <span class="n">accepted_address</span><span class="p">,</span>
                                                   <span class="s1">&#39;our_address&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">client_address</span><span class="p">})</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">results_by_cid</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cid</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
                        <span class="n">address</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">extract_address</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
                        <span class="n">queues</span><span class="p">[</span><span class="n">queue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                        <span class="c1"># Cache this to save time on future searches.</span>
                        <span class="c1"># (Entries expire after STALE_SEARCH_EXPIRATION.)</span>
                        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_lock</span><span class="p">:</span>
                            <span class="n">search_results</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">now</span><span class="p">)</span>
                        <span class="n">server_protocol_versions</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">command</span><span class="o">.</span><span class="n">version</span>
            <span class="c1"># Send the search results to the Contexts that asked for</span>
            <span class="c1"># them. This is probably more general than is has to be but</span>
            <span class="c1"># I&#39;m playing it safe for now.</span>
            <span class="k">if</span> <span class="n">queues</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">queue</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">queues</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">address</span><span class="p">,</span> <span class="n">names</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Broadcaster command loop has exited.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_new_server_found</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Bring all the unanswered seraches out of retirement</span>
        <span class="c1"># to see if we have a new match.</span>
        <span class="n">retirement_deadline</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">+</span> <span class="n">SEARCH_RETIREMENT_AGE</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_lock</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unanswered_searches</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="c1"># give new age-out deadline</span>
                <span class="n">item</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">retirement_deadline</span>

<div class="viewcode-block" id="SharedBroadcaster.time_since_last_heard"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.SharedBroadcaster.time_since_last_heard">[docs]</a>    <span class="k">def</span> <span class="nf">time_since_last_heard</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map each known server address to seconds since its last message.</span>

<span class="sd">        The time is reset to 0 whenever we receive a TCP message related to</span>
<span class="sd">        user activity *or* a Beacon. Servers are expected to send Beacons at</span>
<span class="sd">        regular intervals. If we do not receive either a Beacon or TCP message,</span>
<span class="sd">        we initiate an Echo over TCP, to which the server is expected to</span>
<span class="sd">        promptly respond.</span>

<span class="sd">        Therefore, the time reported here should not much exceed</span>
<span class="sd">        ``EPICS_CA_CONN_TMO`` (default 30 seconds unless overriden by that</span>
<span class="sd">        environment variable) if the server is healthy.</span>

<span class="sd">        If the server fails to send a Beacon on schedule *and* fails to reply to</span>
<span class="sd">        an Echo, the server is assumed dead. A warning is issued, and all PVs</span>
<span class="sd">        are disconnected to initiate a reconnection attempt.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">address</span><span class="p">:</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span> <span class="k">for</span> <span class="n">address</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_heard</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>

    <span class="k">def</span> <span class="nf">_check_for_unresponsive_servers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Broadcaster check for unresponsive servers loop is running.&#39;</span><span class="p">)</span>

        <span class="n">MARGIN</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># extra time (seconds) allowed between Beacons</span>
        <span class="n">checking</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># map address to deadline for check to resolve</span>
        <span class="n">servers</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">WeakSet</span><span class="p">)</span>  <span class="c1"># map address to VirtualCircuitManagers</span>
        <span class="n">last_heard</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># map address to time of last response</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_heard</span> <span class="o">=</span> <span class="n">last_heard</span>

        <span class="c1"># Make locals to save getattr lookups in the loop.</span>
        <span class="n">last_beacon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_beacon</span>
        <span class="n">listeners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="n">servers</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">last_heard</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>

            <span class="c1"># We are interested in identifying servers that we have not heard</span>
            <span class="c1"># from since some time cutoff in the past.</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;EPICS_CA_CONN_TMO&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">MARGIN</span><span class="p">)</span>

            <span class="c1"># Map each server address to VirtualCircuitManagers connected to</span>
            <span class="c1"># that address, across all Contexts (&quot;listeners&quot;).</span>
            <span class="k">for</span> <span class="n">listener</span> <span class="ow">in</span> <span class="n">listeners</span><span class="p">:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">circuit_manager</span> <span class="ow">in</span> <span class="n">listener</span><span class="o">.</span><span class="n">circuit_managers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">servers</span><span class="p">[</span><span class="n">address</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">circuit_manager</span><span class="p">)</span>

            <span class="c1"># When is the last time we heard from each server, either via a</span>
            <span class="c1"># Beacon or from TCP packets related to user activity or any</span>
            <span class="c1"># circuit?</span>
            <span class="k">for</span> <span class="n">address</span><span class="p">,</span> <span class="n">circuit_managers</span> <span class="ow">in</span> <span class="n">servers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">last_tcp_receipt</span> <span class="o">=</span> <span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">last_tcp_receipt</span> <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="n">circuit_managers</span><span class="p">)</span>
                <span class="n">last_heard</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">last_beacon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                           <span class="o">*</span><span class="n">last_tcp_receipt</span><span class="p">))</span>

                <span class="c1"># If is has been too long --- and if we aren&#39;t already checking</span>
                <span class="c1"># on this server --- try to prompt a response over TCP by</span>
                <span class="c1"># sending an EchoRequest.</span>
                <span class="k">if</span> <span class="n">last_heard</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cutoff</span> <span class="ow">and</span> <span class="n">address</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">checking</span><span class="p">:</span>
                    <span class="c1"># Record that we are checking on this address and set a</span>
                    <span class="c1"># deadline for a response.</span>
                    <span class="n">checking</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">RESPONSIVENESS_TIMEOUT</span>
                    <span class="n">tags</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;role&#39;</span><span class="p">:</span> <span class="s1">&#39;CLIENT&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;their_address&#39;</span><span class="p">:</span> <span class="n">address</span><span class="p">,</span>
                            <span class="s1">&#39;our_address&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">client_address</span><span class="p">,</span>
                            <span class="s1">&#39;direction&#39;</span><span class="p">:</span> <span class="s1">&#39;---&gt;&gt;&gt;&#39;</span><span class="p">}</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s2">&quot;Missed Beacons from </span><span class="si">%s</span><span class="s2">:</span><span class="si">%d</span><span class="s2">. Sending EchoRequest to &quot;</span>
                        <span class="s2">&quot;check that server is responsive.&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">tags</span><span class="p">)</span>
                    <span class="c1"># Send on all circuits. One might be less backlogged</span>
                    <span class="c1"># with queued commands than the others and thus able to</span>
                    <span class="c1"># respond faster. In the majority of cases there will only</span>
                    <span class="c1"># be one circuit per server anyway, so this is a minor</span>
                    <span class="c1"># distinction.</span>
                    <span class="k">for</span> <span class="n">circuit_manager</span> <span class="ow">in</span> <span class="n">circuit_managers</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">circuit_manager</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">ca</span><span class="o">.</span><span class="n">EchoRequest</span><span class="p">())</span>
                        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                            <span class="c1"># Send failed. Server is likely dead, but we&#39;ll</span>
                            <span class="c1"># catch that shortly; no need to handle it</span>
                            <span class="c1"># specially here.</span>
                            <span class="k">pass</span>

            <span class="c1"># Check to see if any of our ongoing checks have resolved or</span>
            <span class="c1"># failed to resolve within the allowed response window.</span>
            <span class="k">for</span> <span class="n">address</span><span class="p">,</span> <span class="n">deadline</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">checking</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">last_heard</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">:</span>
                    <span class="c1"># It&#39;s alive!</span>
                    <span class="n">checking</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">deadline</span> <span class="o">&lt;</span> <span class="n">now</span><span class="p">:</span>
                    <span class="c1"># No circuit connected to the server at this address has</span>
                    <span class="c1"># sent Beacons or responded to the EchoRequest. We assume</span>
                    <span class="c1"># it is unresponsive. The EPICS specification says the</span>
                    <span class="c1"># behavior is undefined at this point. We choose to</span>
                    <span class="c1"># disconnect all circuits from that server so that PVs can</span>
                    <span class="c1"># attempt to connect to a new server, such as a failover</span>
                    <span class="c1"># backup.</span>
                    <span class="k">for</span> <span class="n">circuit_manager</span> <span class="ow">in</span> <span class="n">servers</span><span class="p">[</span><span class="n">address</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">circuit_manager</span><span class="o">.</span><span class="n">connected</span><span class="p">:</span>
                            <span class="n">circuit_manager</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                                <span class="s2">&quot;Server at </span><span class="si">%s</span><span class="s2">:</span><span class="si">%d</span><span class="s2"> is unresponsive. &quot;</span>
                                <span class="s2">&quot;Disconnecting circuit manager </span><span class="si">%r</span><span class="s2">. PVs will &quot;</span>
                                <span class="s2">&quot;automatically begin attempting to reconnect &quot;</span>
                                <span class="s2">&quot;to a responsive server.&quot;</span><span class="p">,</span>
                                <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="n">circuit_manager</span><span class="p">)</span>
                            <span class="n">circuit_manager</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span>
                    <span class="n">checking</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
                <span class="c1"># else:</span>
                <span class="c1">#     # We are still waiting to give the server time to respond</span>
                <span class="c1">#     # to the EchoRequest.</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Broadcaster check for unresponsive servers loop has exited.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_retry_unanswered_searches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Periodically (re-)send a SearchRequest for all unanswered searches.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Each time new searches are added, the self._search_now Event is set,</span>
        <span class="c1"># and we reissue *all* unanswered searches.</span>
        <span class="c1">#</span>
        <span class="c1"># We then frequently retry the unanswered searches that are younger</span>
        <span class="c1"># than SEARCH_RETIREMENT_AGE, backing off from an interval of</span>
        <span class="c1"># MIN_RETRY_SEARCHES_INTERVAL to MAX_RETRY_SEARCHES_INTERVAL. The</span>
        <span class="c1"># interval is reset to MIN_RETRY_SEARCHES_INTERVAL each time new</span>
        <span class="c1"># searches are added.</span>
        <span class="c1">#</span>
        <span class="c1"># For the searches older than SEARCH_RETIREMENT_AGE, we adopt a slower</span>
        <span class="c1"># period to minimize network traffic. We only resend every</span>
        <span class="c1"># RETRY_RETIRED_SEARCHES_INTERVAL or, again, whenever new searches</span>
        <span class="c1"># are added.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Broadcaster search-retry thread has started.&#39;</span><span class="p">)</span>
        <span class="n">time_to_check_on_retirees</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">+</span> <span class="n">RETRY_RETIRED_SEARCHES_INTERVAL</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="n">MIN_RETRY_SEARCHES_INTERVAL</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_searching_enabled</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TimeoutError</span><span class="p">:</span>
                <span class="c1"># Here we go check on self._close_event before waiting again.</span>
                <span class="k">continue</span>

            <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>

            <span class="c1"># filter to just things that need to go out</span>
            <span class="k">def</span> <span class="nf">_construct_search_requests</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">search_id</span><span class="p">,</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">ca</span><span class="o">.</span><span class="n">SearchRequest</span><span class="p">(</span><span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">search_id</span><span class="p">,</span>
                                           <span class="n">ca</span><span class="o">.</span><span class="n">DEFAULT_PROTOCOL_VERSION</span><span class="p">)</span>
                    <span class="c1"># reset the last time this was sent</span>
                    <span class="n">it</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>

            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_lock</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">time_to_check_on_retirees</span><span class="p">:</span>
                    <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unanswered_searches</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                    <span class="n">time_to_check_on_retirees</span> <span class="o">+=</span> <span class="n">RETRY_RETIRED_SEARCHES_INTERVAL</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Skip over searches that haven&#39;t gotten any results in</span>
                    <span class="c1"># SEARCH_RETIREMENT_AGE.</span>
                    <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">search_id</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">search_id</span><span class="p">,</span> <span class="n">it</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unanswered_searches</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                                 <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">))</span>

            <span class="c1"># only send requests who we last sent at least interval in the past</span>
            <span class="n">resend_deadline</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">interval</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sid</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">sid</span><span class="p">,</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">items</span> <span class="k">if</span> <span class="n">it</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">resend_deadline</span><span class="p">]</span>
            <span class="n">requests</span> <span class="o">=</span> <span class="n">_construct_search_requests</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_searching_enabled</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">items</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">search_log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Sending </span><span class="si">%d</span><span class="s1"> SearchRequests&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>

            <span class="n">version_req</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">VersionRequest</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">DEFAULT_PROTOCOL_VERSION</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">batch_requests</span><span class="p">(</span><span class="n">requests</span><span class="p">,</span>
                                        <span class="n">SEARCH_MAX_DATAGRAM_BYTES</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">version_req</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ca_server_port</span><span class="p">,</span>
                          <span class="n">version_req</span><span class="p">,</span>
                          <span class="o">*</span><span class="n">batch</span><span class="p">)</span>

            <span class="n">wait_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">interval</span> <span class="o">-</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>
            <span class="c1"># Double the interval for the next loop.</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">interval</span><span class="p">,</span> <span class="n">MAX_RETRY_SEARCHES_INTERVAL</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_now</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">wait_time</span><span class="p">):</span>
                <span class="c1"># New searches have been requested. Reset the interval between</span>
                <span class="c1"># subseqent searches and force a check on the &quot;retirees&quot;.</span>
                <span class="n">time_to_check_on_retirees</span> <span class="o">=</span> <span class="n">t</span>
                <span class="n">interval</span> <span class="o">=</span> <span class="n">MIN_RETRY_SEARCHES_INTERVAL</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_search_now</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Broadcaster search-retry thread has exited.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selector</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span></div>


<div class="viewcode-block" id="Context"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.Context">[docs]</a><span class="k">class</span> <span class="nc">Context</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encapsulates the state and connections of a client</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    broadcaster : SharedBroadcaster, optional</span>
<span class="sd">        If None is specified, a fresh one is instantiated.</span>
<span class="sd">    timeout : number or None, optional</span>
<span class="sd">        Number of seconds before a CaprotoTimeoutError is raised. This default</span>
<span class="sd">        can be overridden at the PV level or for any given operation. If unset,</span>
<span class="sd">        the default is 2 seconds. If None, never timeout. A global timeout can</span>
<span class="sd">        be specified via an environment variable ``CAPROTO_DEFAULT_TIMEOUT``.</span>
<span class="sd">    host_name : string, optional</span>
<span class="sd">        uses value of ``socket.gethostname()`` by default</span>
<span class="sd">    client_name : string, optional</span>
<span class="sd">        uses value of ``getpass.getuser()`` by default</span>
<span class="sd">    max_workers : integer, optional</span>
<span class="sd">        Number of worker threaders *per VirtualCircuit* for executing user</span>
<span class="sd">        callbacks. Default is 1. For any number of workers, workers will</span>
<span class="sd">        receive updates in the order which they are received from the server.</span>
<span class="sd">        That is, work on each update will *begin* in sequential order.</span>
<span class="sd">        Work-scheduling internal to the user callback is outside caproto&#39;s</span>
<span class="sd">        control. If the number of workers is set to greater than 1, the work on</span>
<span class="sd">        each update may not *finish* in a deterministic order. For example, if</span>
<span class="sd">        workers are writing lines into a file, the only way to guarantee that</span>
<span class="sd">        the lines are ordered properly is to use only one worker. If ordering</span>
<span class="sd">        matters for your application, think carefully before increasing this</span>
<span class="sd">        value from 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">broadcaster</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                 <span class="n">timeout</span><span class="o">=</span><span class="n">GLOBAL_DEFAULT_TIMEOUT</span><span class="p">,</span>
                 <span class="n">host_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">client_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">broadcaster</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">broadcaster</span> <span class="o">=</span> <span class="n">SharedBroadcaster</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span> <span class="o">=</span> <span class="n">broadcaster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="k">if</span> <span class="n">host_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">host_name</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">host_name</span> <span class="o">=</span> <span class="n">host_name</span>
        <span class="k">if</span> <span class="n">client_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">client_name</span> <span class="o">=</span> <span class="n">getpass</span><span class="o">.</span><span class="n">getuser</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_workers</span> <span class="o">=</span> <span class="n">max_workers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">client_name</span> <span class="o">=</span> <span class="n">client_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">LoggerAdapter</span><span class="p">(</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;caproto.ctx&#39;</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;role&#39;</span><span class="p">:</span> <span class="s1">&#39;CLIENT&#39;</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pv_cache_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">circuit_managers</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># keyed on ((host, port), priority)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock_during_get_circuit_manager</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pvs</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># (name, priority) -&gt; pv</span>
        <span class="c1"># name -&gt; set of pvs  --- with varied priority</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pvs_needing_circuits</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">add_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_search_results_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
        <span class="c1"># an event to close and clean up the whole context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subscriptions_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subscriptions_to_activate</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activate_subscriptions_now</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_search_results_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_process_search_results_loop</span><span class="p">,</span>
            <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;search&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_search_results_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_activate_subscriptions_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_activate_subscriptions</span><span class="p">,</span>
            <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;activate_subscriptions&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_activate_subscriptions_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">SelectorThread</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_disconnected</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&lt;Context &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;searches_pending=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">unanswered_searches</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;circuits=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit_managers</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;pvs=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvs</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;idle=</span><span class="si">{</span><span class="nb">len</span><span class="p">([</span><span class="mi">1</span> <span class="k">for</span> <span class="n">pv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvs</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">pv</span><span class="o">.</span><span class="n">_idle</span><span class="p">])</span><span class="si">}</span><span class="s2">&gt;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="Context.get_pvs"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.Context.get_pvs">[docs]</a>    <span class="k">def</span> <span class="nf">get_pvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">connection_state_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">access_rights_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">timeout</span><span class="o">=</span><span class="n">CONTEXT_DEFAULT_TIMEOUT</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of PV objects.</span>

<span class="sd">        These objects may not be connected at first. Channel creation occurs on</span>
<span class="sd">        a background thread.</span>

<span class="sd">        PVs are uniquely defined by their name and priority. If a PV with the</span>
<span class="sd">        same name and priority is requested twice, the same (cached) object is</span>
<span class="sd">        returned. Any callbacks included here are added to added alongside any</span>
<span class="sd">        existing ones.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *names : strings</span>
<span class="sd">            any number of PV names</span>
<span class="sd">        priority : integer</span>
<span class="sd">            Used by the server to triage subscription responses when under high</span>
<span class="sd">            load. 0 is lowest; 99 is highest.</span>
<span class="sd">        connection_state_callback : callable</span>
<span class="sd">            Expected signature: ``f(pv, state)`` where ``pv`` is the instance</span>
<span class="sd">            of ``PV`` whose state has changed and ``state`` is a string</span>
<span class="sd">        access_rights_callback : callable</span>
<span class="sd">            Expected signature: ``f(pv, access_rights)`` where ``pv`` is the</span>
<span class="sd">            instance of ``PV`` whose state has changed and ``access_rights`` is</span>
<span class="sd">            a member of the caproto ``AccessRights`` enum</span>
<span class="sd">        timeout : number or None, optional</span>
<span class="sd">            Number of seconds before a CaprotoTimeoutError is raised. This</span>
<span class="sd">            default can be overridden for any specific operation. By default,</span>
<span class="sd">            fall back to the default timeout set by the Context. If None, never</span>
<span class="sd">            timeout.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_disconnected</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ContextDisconnectedError</span><span class="p">(</span><span class="s2">&quot;This Context is no longer usable.&quot;</span><span class="p">)</span>
        <span class="n">pvs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of all PV objects to return</span>
        <span class="n">names_to_search</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># subset of names that we need to search for</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv_cache_lock</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">pv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvs</span><span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">priority</span><span class="p">)]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">pv</span> <span class="o">=</span> <span class="n">PV</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
                    <span class="n">names_to_search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pvs</span><span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">priority</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pv</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pvs_needing_circuits</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">connection_state_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pv</span><span class="o">.</span><span class="n">connection_state_callback</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span>
                    <span class="n">connection_state_callback</span><span class="p">,</span> <span class="n">run</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">access_rights_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pv</span><span class="o">.</span><span class="n">access_rights_callback</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span>
                    <span class="n">access_rights_callback</span><span class="p">,</span> <span class="n">run</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">pvs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>

        <span class="c1"># TODO: potential bug?</span>
        <span class="c1"># if callback is quick, is there a chance downstream listeners may</span>
        <span class="c1"># never receive notification?</span>

        <span class="c1"># Ask the Broadcaster to search for every PV for which we do not</span>
        <span class="c1"># already have an instance. It might already have a cached search</span>
        <span class="c1"># result, but that is the concern of broadcaster.search.</span>
        <span class="k">if</span> <span class="n">names_to_search</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_search_results_queue</span><span class="p">,</span>
                                    <span class="n">names_to_search</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pvs</span></div>

    <span class="k">def</span> <span class="nf">reconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="c1"># We will reuse the same PV object but use a new cid.</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pvs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv_cache_lock</span><span class="p">:</span>
                <span class="n">pv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">pvs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="c1"># If there is a cached search result for this name, expire it.</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">_search_lock</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">search_results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv_cache_lock</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pvs_needing_circuits</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_search_results_queue</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_search_results_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Receive (address, (name1, name2, ...)). The sending side of this</span>
        <span class="c1"># queue is held by SharedBroadcaster.command_loop.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Context search-results processing loop has &#39;</span>
                       <span class="s1">&#39;started.&#39;</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">address</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_results_queue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Empty</span><span class="p">:</span>
                <span class="c1"># By restarting the loop, we will first check that we are not</span>
                <span class="c1"># supposed to shut down the thread before we go back to</span>
                <span class="c1"># waiting on the queue again.</span>
                <span class="k">continue</span>

            <span class="n">channels_grouped_by_circuit</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="c1"># Assign each PV a VirtualCircuitManager for managing a socket</span>
            <span class="c1"># and tracking circuit state, as well as a ClientChannel for</span>
            <span class="c1"># tracking channel state.</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="n">search_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Connecting </span><span class="si">%s</span><span class="s1"> on circuit with </span><span class="si">%s</span><span class="s1">:</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span>
                                    <span class="n">extra</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;pv&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
                                           <span class="s1">&#39;their_address&#39;</span><span class="p">:</span> <span class="n">address</span><span class="p">,</span>
                                           <span class="s1">&#39;our_address&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">client_address</span><span class="p">,</span>
                                           <span class="s1">&#39;direction&#39;</span><span class="p">:</span> <span class="s1">&#39;---&gt;&gt;&gt;&#39;</span><span class="p">,</span>
                                           <span class="s1">&#39;role&#39;</span><span class="p">:</span> <span class="s1">&#39;CLIENT&#39;</span><span class="p">})</span>
                <span class="c1"># There could be multiple PVs with the same name and</span>
                <span class="c1"># different priority. That is what we are looping over</span>
                <span class="c1"># here. There could also be NO PVs with this name that need</span>
                <span class="c1"># a circuit, because we could be receiving a duplicate</span>
                <span class="c1"># search response (which we are supposed to ignore).</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv_cache_lock</span><span class="p">:</span>
                    <span class="n">pvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvs_needing_circuits</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">pv</span> <span class="ow">in</span> <span class="n">pvs</span><span class="p">:</span>
                    <span class="c1"># Get (make if necessary) a VirtualCircuitManager. This</span>
                    <span class="c1"># is where TCP socket creation happens.</span>
                    <span class="n">cm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit_manager</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">pv</span><span class="o">.</span><span class="n">priority</span><span class="p">)</span>
                    <span class="n">circuit</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">circuit</span>

                    <span class="n">pv</span><span class="o">.</span><span class="n">circuit_manager</span> <span class="o">=</span> <span class="n">cm</span>
                    <span class="c1"># TODO: NOTE: we are not following the suggestion to</span>
                    <span class="c1"># use the same cid as in the search. This simplifies</span>
                    <span class="c1"># things between the broadcaster and Context.</span>
                    <span class="n">cid</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">new_channel_id</span><span class="p">()</span>
                    <span class="n">chan</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">ClientChannel</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">circuit</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="n">cid</span><span class="p">)</span>
                    <span class="n">cm</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan</span>
                    <span class="n">cm</span><span class="o">.</span><span class="n">pvs</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span> <span class="o">=</span> <span class="n">pv</span>
                    <span class="n">channels_grouped_by_circuit</span><span class="p">[</span><span class="n">cm</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
                    <span class="n">pv</span><span class="o">.</span><span class="n">circuit_ready</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

            <span class="c1"># Initiate channel creation with the server.</span>
            <span class="k">for</span> <span class="n">cm</span><span class="p">,</span> <span class="n">channels</span> <span class="ow">in</span> <span class="n">channels_grouped_by_circuit</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">commands</span> <span class="o">=</span> <span class="p">[</span><span class="n">chan</span><span class="o">.</span><span class="n">create</span><span class="p">()</span> <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">cm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="o">*</span><span class="n">commands</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">dead</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Circuit died while we were trying &quot;</span>
                                       <span class="s2">&quot;to create the channel. We will &quot;</span>
                                       <span class="s2">&quot;keep attempting this until it &quot;</span>
                                       <span class="s2">&quot;works.&quot;</span><span class="p">)</span>
                        <span class="c1"># When the Context creates a new circuit, we will end</span>
                        <span class="c1"># up here again. No big deal.</span>
                        <span class="k">continue</span>
                    <span class="k">raise</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Context search-results processing thread has exited.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_circuit_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">priority</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a VirtualCircuitManager for this address, priority. (It manages</span>
<span class="sd">        a caproto.VirtualCircuit and a TCP socket.)</span>

<span class="sd">        Make a new one if necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock_during_get_circuit_manager</span><span class="p">:</span>
            <span class="n">cm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit_managers</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">address</span><span class="p">,</span> <span class="n">priority</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cm</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cm</span><span class="o">.</span><span class="n">dead</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                <span class="n">version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">server_protocol_versions</span><span class="p">[</span><span class="n">address</span><span class="p">]</span>
                <span class="n">circuit</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">VirtualCircuit</span><span class="p">(</span>
                    <span class="n">our_role</span><span class="o">=</span><span class="n">ca</span><span class="o">.</span><span class="n">CLIENT</span><span class="p">,</span>
                    <span class="n">address</span><span class="o">=</span><span class="n">address</span><span class="p">,</span>
                    <span class="n">priority</span><span class="o">=</span><span class="n">priority</span><span class="p">,</span>
                    <span class="n">protocol_version</span><span class="o">=</span><span class="n">version</span><span class="p">)</span>
                <span class="n">cm</span> <span class="o">=</span> <span class="n">VirtualCircuitManager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">circuit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">circuit_managers</span><span class="p">[(</span><span class="n">address</span><span class="p">,</span> <span class="n">priority</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cm</span>
            <span class="k">return</span> <span class="n">cm</span>

    <span class="k">def</span> <span class="nf">_activate_subscriptions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">subscriptions_lock</span><span class="p">:</span>
                <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subscriptions_to_activate</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">subscriptions_to_activate</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">cm</span><span class="p">,</span> <span class="n">subs</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">requests</span><span class="p">():</span>
                    <span class="s2">&quot;Yield EventAddRequest commands.&quot;</span>
                    <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">subs</span><span class="p">:</span>
                        <span class="n">command</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">compose_command</span><span class="p">()</span>
                        <span class="c1"># compose_command() returns None if this</span>
                        <span class="c1"># Subscription is inactive (meaning there are no</span>
                        <span class="c1"># user callbacks attached). It will send an</span>
                        <span class="c1"># EventAddRequest on its own if/when the user does</span>
                        <span class="c1"># add any callbacks, so we can skip it here.</span>
                        <span class="k">if</span> <span class="n">command</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">command</span>

                <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">batch_requests</span><span class="p">(</span><span class="n">requests</span><span class="p">(),</span>
                                            <span class="n">EVENT_ADD_BATCH_MAX_BYTES</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">cm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="o">*</span><span class="n">batch</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">dead</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Circuit died while we were &quot;</span>
                                           <span class="s2">&quot;trying to activate &quot;</span>
                                           <span class="s2">&quot;subscriptions. We will &quot;</span>
                                           <span class="s2">&quot;keep attempting this until it &quot;</span>
                                           <span class="s2">&quot;works.&quot;</span><span class="p">)</span>
                        <span class="c1"># When the Context creates a new circuit, we will</span>
                        <span class="c1"># end up here again. No big deal.</span>
                        <span class="k">break</span>

            <span class="n">wait_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">RESTART_SUBS_PERIOD</span> <span class="o">-</span>
                                <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">activate_subscriptions_now</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">wait_time</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">activate_subscriptions_now</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Context restart-subscriptions thread exiting&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_disconnected</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
            <span class="c1"># disconnect any circuits we have</span>
            <span class="n">circuits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit_managers</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">total_circuits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">circuits</span><span class="p">)</span>
            <span class="n">disconnected</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">circuit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">circuits</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">circuit</span><span class="o">.</span><span class="n">connected</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Disconnecting circuit </span><span class="si">%d</span><span class="s1">/</span><span class="si">%d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                                   <span class="n">idx</span><span class="p">,</span> <span class="n">total_circuits</span><span class="p">,</span> <span class="n">circuit</span><span class="p">)</span>
                    <span class="n">circuit</span><span class="o">.</span><span class="n">_disconnected</span><span class="p">(</span><span class="n">reconnect</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">disconnected</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">disconnected</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;All circuits disconnected&#39;</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Remove from Broadcaster.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">remove_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="c1"># clear any state about circuits and search results</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Clearing circuit managers&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">circuit_managers</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

            <span class="c1"># disconnect the underlying state machine</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">remove_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Stopping SelectorThread of the context&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">wait</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_process_search_results_thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_activate_subscriptions_thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Context disconnection complete&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="n">wait</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="o">...</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selector</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">circuit_managers</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="VirtualCircuitManager"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.VirtualCircuitManager">[docs]</a><span class="k">class</span> <span class="nc">VirtualCircuitManager</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encapsulates a VirtualCircuit, a TCP socket, and additional state</span>

<span class="sd">    This object should never be instantiated directly by user code. It is used</span>
<span class="sd">    internally by the Context. Its methods may be touched by user code, but</span>
<span class="sd">    this is rarely necessary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;context&#39;</span><span class="p">,</span> <span class="s1">&#39;circuit&#39;</span><span class="p">,</span> <span class="s1">&#39;channels&#39;</span><span class="p">,</span> <span class="s1">&#39;ioids&#39;</span><span class="p">,</span> <span class="s1">&#39;_ioid_counter&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;subscriptions&#39;</span><span class="p">,</span> <span class="s1">&#39;_ready&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;socket&#39;</span><span class="p">,</span> <span class="s1">&#39;selector&#39;</span><span class="p">,</span> <span class="s1">&#39;pvs&#39;</span><span class="p">,</span> <span class="s1">&#39;all_created_pvnames&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;dead&#39;</span><span class="p">,</span> <span class="s1">&#39;process_queue&#39;</span><span class="p">,</span> <span class="s1">&#39;processing&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_subscriptionid_counter&#39;</span><span class="p">,</span> <span class="s1">&#39;user_callback_executor&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;last_tcp_receipt&#39;</span><span class="p">,</span> <span class="s1">&#39;__weakref__&#39;</span><span class="p">,</span> <span class="s1">&#39;_tags&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">circuit</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">TIMEOUT</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span> <span class="o">=</span> <span class="n">circuit</span>  <span class="c1"># a caproto.VirtualCircuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># map cid to Channel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pvs</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># map cid to PV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ioids</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># map ioid to Channel and info dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subscriptions</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># map subscriptionid to Subscription</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">selector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_callback_executor</span> <span class="o">=</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span>
            <span class="n">max_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">max_workers</span><span class="p">,</span>
            <span class="n">thread_name_prefix</span><span class="o">=</span><span class="s1">&#39;user-callback-executor&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_tcp_receipt</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># keep track of all PV names that are successfully connected to within</span>
        <span class="c1"># this circuit. This is to be cleared upon disconnection:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_created_pvnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dead</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ioid_counter</span> <span class="o">=</span> <span class="n">ThreadsafeCounter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subscriptionid_counter</span> <span class="o">=</span> <span class="n">ThreadsafeCounter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>

        <span class="c1"># Connect.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">ca</span><span class="o">.</span><span class="n">SERVER</span><span class="p">]</span> <span class="ow">is</span> <span class="n">ca</span><span class="o">.</span><span class="n">IDLE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">create_connection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_KEEPALIVE</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">TCP_NODELAY</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">our_address</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()</span>
            <span class="c1"># This dict is passed to the loggers.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;their_address&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                          <span class="s1">&#39;our_address&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">our_address</span><span class="p">,</span>
                          <span class="s1">&#39;direction&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&lt;&lt;---&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;role&#39;</span><span class="p">:</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">our_role</span><span class="p">)}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">add_socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">ca</span><span class="o">.</span><span class="n">VersionRequest</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">priority</span><span class="p">,</span>
                                        <span class="n">ca</span><span class="o">.</span><span class="n">DEFAULT_PROTOCOL_VERSION</span><span class="p">),</span>
                      <span class="n">ca</span><span class="o">.</span><span class="n">HostNameRequest</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">host_name</span><span class="p">),</span>
                      <span class="n">ca</span><span class="o">.</span><span class="n">ClientNameRequest</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">client_name</span><span class="p">),</span>
                      <span class="n">extra</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tags</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CaprotoRuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot connect. States are </span><span class="si">{}</span><span class="s2"> &quot;</span>
                                      <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">states</span><span class="p">))</span>
        <span class="c1"># Old versions of the protocol do not send a VersionResponse at TCP</span>
        <span class="c1"># connection time, so set this Event manually rather than waiting for</span>
        <span class="c1"># it to be set by receipt of a VersionResponse.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">server_protocol_versions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">address</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="n">ready</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ready</span><span class="p">:</span>
            <span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">address</span>
            <span class="k">raise</span> <span class="n">CaprotoTimeoutError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Circuit with server at </span><span class="si">{</span><span class="n">host</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">port</span><span class="si">}</span><span class="s2"> &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;did not connect within &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span><span class="si">:</span><span class="s2">.3</span><span class="si">}</span><span class="s2">-second timeout.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&lt;VirtualCircuitManager circuit=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;pvs=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvs</span><span class="p">)</span><span class="si">}</span><span class="s2"> ioids=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ioids</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;subscriptions=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subscriptions</span><span class="p">)</span><span class="si">}</span><span class="s2">&gt;&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">ca</span><span class="o">.</span><span class="n">CLIENT</span><span class="p">]</span> <span class="ow">is</span> <span class="n">ca</span><span class="o">.</span><span class="n">CONNECTED</span>

    <span class="k">def</span> <span class="nf">_socket_send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffers_to_send</span><span class="p">):</span>
        <span class="s1">&#39;Send a list of buffers over the socket&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">sendmsg</span><span class="p">(</span><span class="n">buffers_to_send</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BlockingIOError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ca</span><span class="o">.</span><span class="n">SendAllRetry</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">commands</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Turn the crank: inform the VirtualCircuit that these commands will</span>
        <span class="c1"># be send, and convert them to buffers.</span>
        <span class="n">buffers_to_send</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="o">*</span><span class="n">commands</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">extra</span><span class="p">)</span>
        <span class="c1"># Send bytes over the wire using some caproto utilities.</span>
        <span class="n">ca</span><span class="o">.</span><span class="n">send_all</span><span class="p">(</span><span class="n">buffers_to_send</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_socket_send</span><span class="p">)</span>

<div class="viewcode-block" id="VirtualCircuitManager.received"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.VirtualCircuitManager.received">[docs]</a>    <span class="k">def</span> <span class="nf">received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bytes_recv</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Receive and process and next command from the virtual circuit.</span>

<span class="sd">        This will be run on the recv thread&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_tcp_receipt</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
        <span class="n">commands</span><span class="p">,</span> <span class="n">num_bytes_needed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">bytes_recv</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_command</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">bytes_recv</span><span class="p">:</span>
            <span class="c1"># Tell the selector to remove our socket</span>
            <span class="k">return</span> <span class="n">ca</span><span class="o">.</span><span class="n">DISCONNECTED</span>
        <span class="k">return</span> <span class="n">num_bytes_needed</span></div>

<div class="viewcode-block" id="VirtualCircuitManager.events_off"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.VirtualCircuitManager.events_off">[docs]</a>    <span class="k">def</span> <span class="nf">events_off</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Suspend updates to all subscriptions on this circuit.</span>

<span class="sd">        This may be useful if the server produces updates faster than the</span>
<span class="sd">        client can processs them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">ca</span><span class="o">.</span><span class="n">EventsOffRequest</span><span class="p">())</span></div>

<div class="viewcode-block" id="VirtualCircuitManager.events_on"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.VirtualCircuitManager.events_on">[docs]</a>    <span class="k">def</span> <span class="nf">events_on</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reactive updates to all subscriptions on this circuit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">ca</span><span class="o">.</span><span class="n">EventsOnRequest</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">_process_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">process_command</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ca</span><span class="o">.</span><span class="n">CaprotoError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="s1">&#39;channel&#39;</span><span class="p">):</span>
                <span class="n">channel</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">channel</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Invalid command </span><span class="si">%s</span><span class="s1"> for Channel </span><span class="si">%s</span><span class="s1"> in state </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                                 <span class="n">command</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">states</span><span class="p">,</span>
                                 <span class="n">exc_info</span><span class="o">=</span><span class="n">ex</span><span class="p">)</span>
                <span class="c1"># channel exceptions are not fatal</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Invalid command </span><span class="si">%s</span><span class="s1"> for VirtualCircuit </span><span class="si">%s</span><span class="s1"> in &#39;</span>
                               <span class="s1">&#39;state </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">states</span><span class="p">,</span>
                               <span class="n">exc_info</span><span class="o">=</span><span class="n">ex</span><span class="p">)</span>
                <span class="c1"># circuit exceptions are fatal; exit the loop</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span>
                <span class="k">return</span>

        <span class="n">tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span>
        <span class="k">if</span> <span class="n">command</span> <span class="ow">is</span> <span class="n">ca</span><span class="o">.</span><span class="n">DISCONNECTED</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_disconnected</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="p">(</span><span class="n">ca</span><span class="o">.</span><span class="n">VersionResponse</span><span class="p">,)):</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected</span>  <span class="c1"># double check that the state machine agrees</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="p">(</span><span class="n">ca</span><span class="o">.</span><span class="n">ReadNotifyResponse</span><span class="p">,</span>
                                  <span class="n">ca</span><span class="o">.</span><span class="n">ReadResponse</span><span class="p">,</span>
                                  <span class="n">ca</span><span class="o">.</span><span class="n">WriteNotifyResponse</span><span class="p">)):</span>
            <span class="n">ioid_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ioids</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">command</span><span class="o">.</span><span class="n">ioid</span><span class="p">)</span>
            <span class="n">deadline</span> <span class="o">=</span> <span class="n">ioid_info</span><span class="p">[</span><span class="s1">&#39;deadline&#39;</span><span class="p">]</span>
            <span class="n">pv</span> <span class="o">=</span> <span class="n">ioid_info</span><span class="p">[</span><span class="s1">&#39;pv&#39;</span><span class="p">]</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="n">tags</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;pv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="n">deadline</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">deadline</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Ignoring late response with ioid=</span><span class="si">%d</span><span class="s2"> regarding &quot;</span>
                                 <span class="s2">&quot;PV named </span><span class="si">%s</span><span class="s2"> because &quot;</span>
                                 <span class="s2">&quot;it arrived </span><span class="si">%.3f</span><span class="s2"> seconds after the deadline &quot;</span>
                                 <span class="s2">&quot;specified by the timeout.&quot;</span><span class="p">,</span> <span class="n">command</span><span class="o">.</span><span class="n">ioid</span><span class="p">,</span>
                                 <span class="n">pv</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">-</span> <span class="n">deadline</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="n">event</span> <span class="o">=</span> <span class="n">ioid_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;event&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">event</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If PV.read() or PV.write() are waiting on this response,</span>
                <span class="c1"># they hold a reference to ioid_info. We will use that to</span>
                <span class="c1"># provide the response to them and then set the Event that they</span>
                <span class="c1"># are waiting on.</span>
                <span class="n">ioid_info</span><span class="p">[</span><span class="s1">&#39;response&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">command</span>
                <span class="n">event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">ioid_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;callback&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">user_callback_executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="n">command</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">EventAddResponse</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subscriptions</span><span class="p">[</span><span class="n">command</span><span class="o">.</span><span class="n">subscriptionid</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># This subscription has been removed. We assume that this</span>
                <span class="c1"># response was in flight before the server processed our</span>
                <span class="c1"># unsubscription.</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This method submits jobs to the Contexts&#39;s</span>
                <span class="c1"># ThreadPoolExecutor for user callbacks.</span>
                <span class="n">sub</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
                <span class="n">tags</span> <span class="o">=</span> <span class="n">tags</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;pv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">pv</span><span class="o">.</span><span class="n">name</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">AccessRightsResponse</span><span class="p">):</span>
            <span class="n">pv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvs</span><span class="p">[</span><span class="n">command</span><span class="o">.</span><span class="n">cid</span><span class="p">]</span>
            <span class="n">pv</span><span class="o">.</span><span class="n">access_rights_changed</span><span class="p">(</span><span class="n">command</span><span class="o">.</span><span class="n">access_rights</span><span class="p">)</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="n">tags</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;pv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">name</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">EventCancelResponse</span><span class="p">):</span>
            <span class="c1"># TODO Any way to add the pv name to tags here?</span>
            <span class="o">...</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">CreateChanResponse</span><span class="p">):</span>
            <span class="n">pv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvs</span><span class="p">[</span><span class="n">command</span><span class="o">.</span><span class="n">cid</span><span class="p">]</span>
            <span class="n">chan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">command</span><span class="o">.</span><span class="n">cid</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_created_pvnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pv</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">pv</span><span class="o">.</span><span class="n">component_lock</span><span class="p">:</span>
                <span class="n">pv</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">chan</span>
                <span class="n">pv</span><span class="o">.</span><span class="n">channel_ready</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
            <span class="n">pv</span><span class="o">.</span><span class="n">connection_state_changed</span><span class="p">(</span><span class="s1">&#39;connected&#39;</span><span class="p">,</span> <span class="n">chan</span><span class="p">)</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="n">tags</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;pv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">name</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="p">(</span><span class="n">ca</span><span class="o">.</span><span class="n">ServerDisconnResponse</span><span class="p">,</span>
                                  <span class="n">ca</span><span class="o">.</span><span class="n">ClearChannelResponse</span><span class="p">)):</span>
            <span class="n">pv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvs</span><span class="p">[</span><span class="n">command</span><span class="o">.</span><span class="n">cid</span><span class="p">]</span>
            <span class="n">pv</span><span class="o">.</span><span class="n">connection_state_changed</span><span class="p">(</span><span class="s1">&#39;disconnected&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="n">tags</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;pv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">name</span>
            <span class="c1"># NOTE: pv remains valid until server goes down</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">EchoResponse</span><span class="p">):</span>
            <span class="c1"># The important effect here is that it will have updated</span>
            <span class="c1"># self.last_tcp_receipt when the bytes flowed through</span>
            <span class="c1"># self.received.</span>
            <span class="o">...</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">Message</span><span class="p">):</span>
            <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;bytesize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">tags</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_disconnected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">reconnect</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># Ensure that this method is idempotent.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dead</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;their_address&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">address</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Virtual circuit with address </span><span class="si">%s</span><span class="s1">:</span><span class="si">%d</span><span class="s1"> has disconnected.&#39;</span><span class="p">,</span>
                       <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">tags</span><span class="p">)</span>
        <span class="c1"># Update circuit state. This will be reflected on all PVs, which</span>
        <span class="c1"># continue to hold a reference to this disconnected circuit.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvs</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">pv</span><span class="o">.</span><span class="n">channel_ready</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">pv</span><span class="o">.</span><span class="n">circuit_ready</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dead</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ioid_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ioids</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># Un-block any calls to PV.read() or PV.write() that are waiting on</span>
            <span class="c1"># responses that we now know will never arrive. They will check on</span>
            <span class="c1"># circuit health and raise appropriately.</span>
            <span class="n">event</span> <span class="o">=</span> <span class="n">ioid_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;event&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">event</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">_search_lock</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_created_pvnames</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">search_results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">all_created_pvnames</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvs</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">pv</span><span class="o">.</span><span class="n">connection_state_changed</span><span class="p">(</span><span class="s1">&#39;disconnected&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Remove VirtualCircuitManager from Context.</span>
        <span class="c1"># This will cause all future calls to Context.get_circuit_manager()</span>
        <span class="c1"># to create a fresh VirtualCiruit and VirtualCircuitManager.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">circuit_managers</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Clean up the socket if it has not yet been cleared:</span>
        <span class="n">sock</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">remove_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sock</span><span class="o">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SHUT_WR</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">tags</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;their_address&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">address</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">reconnect</span><span class="p">:</span>
            <span class="c1"># Kick off attempt to reconnect all PVs via fresh circuit(s).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Kicking off reconnection attempts for </span><span class="si">%d</span><span class="s1"> PVs &#39;</span>
                           <span class="s1">&#39;disconnected from </span><span class="si">%s</span><span class="s1">:</span><span class="si">%d</span><span class="s1">....&#39;</span><span class="p">,</span>
                           <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">),</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">tags</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">reconnect</span><span class="p">(((</span><span class="n">chan</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">chan</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">priority</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Not attempting reconnection&#39;</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">tags</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Shutting down ThreadPoolExecutor for user callbacks&quot;</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">tags</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_callback_executor</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_disconnected</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Circuit manager disconnected by user&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_disconnected</span><span class="p">(</span><span class="n">reconnect</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span></div>


<div class="viewcode-block" id="PV"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.PV">[docs]</a><span class="k">class</span> <span class="nc">PV</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents one PV, specified by a name and priority.</span>

<span class="sd">    This object may exist prior to connection and persists across any</span>
<span class="sd">    subsequent re-connections.</span>

<span class="sd">    This object should never be instantiated directly by user code; rather it</span>
<span class="sd">    should be created by calling the ``get_pvs`` method on a ``Context``</span>
<span class="sd">    object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;priority&#39;</span><span class="p">,</span> <span class="s1">&#39;context&#39;</span><span class="p">,</span> <span class="s1">&#39;_circuit_manager&#39;</span><span class="p">,</span> <span class="s1">&#39;_channel&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;circuit_ready&#39;</span><span class="p">,</span> <span class="s1">&#39;channel_ready&#39;</span><span class="p">,</span> <span class="s1">&#39;access_rights&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;access_rights_callback&#39;</span><span class="p">,</span> <span class="s1">&#39;subscriptions&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;command_bundle_queue&#39;</span><span class="p">,</span> <span class="s1">&#39;component_lock&#39;</span><span class="p">,</span> <span class="s1">&#39;_idle&#39;</span><span class="p">,</span> <span class="s1">&#39;_in_use&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_usages&#39;</span><span class="p">,</span> <span class="s1">&#39;connection_state_callback&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_timeout&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;__weakref__&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">connection_state_callback</span><span class="p">,</span>
                 <span class="n">access_rights_callback</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These must be instantiated by a Context, never directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">access_rights</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will be overwritten with AccessRights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">LoggerAdapter</span><span class="p">(</span><span class="n">ch_logger</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;pv&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;role&#39;</span><span class="p">:</span> <span class="s1">&#39;CLIENT&#39;</span><span class="p">})</span>
        <span class="c1"># Use this lock whenever we touch circuit_manager or channel.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">component_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">circuit_ready</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_ready</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection_state_callback</span> <span class="o">=</span> <span class="n">CallbackHandler</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">access_rights_callback</span> <span class="o">=</span> <span class="n">CallbackHandler</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span> <span class="o">=</span> <span class="n">timeout</span>

        <span class="k">if</span> <span class="n">connection_state_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connection_state_callback</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span>
                <span class="n">connection_state_callback</span><span class="p">,</span> <span class="n">run</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">access_rights_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">access_rights_callback</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span>
                <span class="n">access_rights_callback</span><span class="p">,</span> <span class="n">run</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_circuit_manager</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_channel</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subscriptions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_idle</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_in_use</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Condition</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_usages</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Effective default timeout.</span>

<span class="sd">        Valid values are:</span>
<span class="sd">        * CONTEXT_DEFAULT_TIMEOUT (fall back to Context.timeout)</span>
<span class="sd">        * a floating-point number</span>
<span class="sd">        * None (never timeout)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span> <span class="ow">is</span> <span class="n">CONTEXT_DEFAULT_TIMEOUT</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">timeout</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span>

    <span class="nd">@timeout</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">circuit_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit_manager</span>

    <span class="nd">@circuit_manager</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">circuit_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_circuit_manager</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">channel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_channel</span>

    <span class="nd">@channel</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_channel</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">access_rights_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rights</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">access_rights</span> <span class="o">=</span> <span class="n">rights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">access_rights_callback</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rights</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connection_state_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;connection state changed to </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection_state_callback</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;disconnected&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subscriptions</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">with</span> <span class="n">sub</span><span class="o">.</span><span class="n">callback_lock</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sub</span><span class="o">.</span><span class="n">callbacks</span><span class="p">:</span>
                        <span class="n">sub</span><span class="o">.</span><span class="n">needs_reactivation</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;connected&#39;</span><span class="p">:</span>
            <span class="n">cm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit_manager</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">context</span>
            <span class="k">with</span> <span class="n">ctx</span><span class="o">.</span><span class="n">subscriptions_lock</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subscriptions</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">with</span> <span class="n">sub</span><span class="o">.</span><span class="n">callback_lock</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">sub</span><span class="o">.</span><span class="n">needs_reactivation</span><span class="p">:</span>
                            <span class="n">ctx</span><span class="o">.</span><span class="n">subscriptions_to_activate</span><span class="p">[</span><span class="n">cm</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>
                            <span class="n">sub</span><span class="o">.</span><span class="n">needs_reactivation</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idle</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;(idle)&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit_manager</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit_manager</span><span class="o">.</span><span class="n">dead</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;(searching....)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;address=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit_manager</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">address</span><span class="si">}</span><span class="s2">, &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;circuit_state=&quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit_manager</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">ca</span><span class="o">.</span><span class="n">CLIENT</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">:</span>
                <span class="n">state</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;, channel_state=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">ca</span><span class="o">.</span><span class="n">CLIENT</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">state</span> <span class="o">+=</span> <span class="s2">&quot; (creating...)&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;PV name=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> priority=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">priority</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span>
        <span class="k">if</span> <span class="n">channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">channel</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">ca</span><span class="o">.</span><span class="n">CLIENT</span><span class="p">]</span> <span class="ow">is</span> <span class="n">ca</span><span class="o">.</span><span class="n">CONNECTED</span>

<div class="viewcode-block" id="PV.wait_for_search"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.PV.wait_for_search">[docs]</a>    <span class="k">def</span> <span class="nf">wait_for_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">PV_DEFAULT_TIMEOUT</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wait for this PV to be found.</span>

<span class="sd">        This does not wait for the PV&#39;s Channel to be created; it merely waits</span>
<span class="sd">        for an address (and a VirtualCircuit) to be assigned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timeout : number or None, optional</span>
<span class="sd">            Seconds to wait before a CaprotoTimeoutError is raised. Default is</span>
<span class="sd">            ``PV.timeout``, which falls back to Context.timeout if not set. If</span>
<span class="sd">            None, never timeout.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="n">PV_DEFAULT_TIMEOUT</span><span class="p">:</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit_ready</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CaprotoTimeoutError</span><span class="p">(</span><span class="s2">&quot;No servers responded to a search for a &quot;</span>
                                      <span class="s2">&quot;channel named </span><span class="si">{!r}</span><span class="s2"> within </span><span class="si">{:.3}</span><span class="s2">-second &quot;</span>
                                      <span class="s2">&quot;timeout.&quot;</span>
                                      <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">timeout</span><span class="p">)))</span></div>

<div class="viewcode-block" id="PV.wait_for_connection"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.PV.wait_for_connection">[docs]</a>    <span class="nd">@ensure_connected</span>
    <span class="k">def</span> <span class="nf">wait_for_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">PV_DEFAULT_TIMEOUT</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wait for this PV to be connected.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timeout : number or None, optional</span>
<span class="sd">            Seconds to wait before a CaprotoTimeoutError is raised. Default is</span>
<span class="sd">            ``PV.timeout``, which falls back to ``PV.context.timeout`` if not</span>
<span class="sd">            set. If None, never timeout.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="PV.go_idle"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.PV.go_idle">[docs]</a>    <span class="k">def</span> <span class="nf">go_idle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Request to clear this Channel to reduce load on client and server.</span>

<span class="sd">        A new Channel will be automatically, silently created the next time any</span>
<span class="sd">        method requiring a connection is called. Thus, this saves some memory</span>
<span class="sd">        in exchange for making the next request a bit slower, as it has to</span>
<span class="sd">        redo the handshake with the server first.</span>

<span class="sd">        If there are any subscriptions with callbacks, this request will be</span>
<span class="sd">        ignored. If the PV is in the process of connecting, this request will</span>
<span class="sd">        be ignored.  If there are any actions in progress (read, write) this</span>
<span class="sd">        request will be processed when they are complete.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subscriptions</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sub</span><span class="o">.</span><span class="n">callbacks</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_use</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_ready</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                <span class="k">return</span>
            <span class="c1"># Wait until no other methods that employ @self.ensure_connected</span>
            <span class="c1"># are in process.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_use</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_usages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1"># No other threads are using the connection, and we are holding the</span>
            <span class="c1"># self._in_use Condition&#39;s lock, so we can safely close the</span>
            <span class="c1"># connection. The next thread to acquire the lock will re-connect</span>
            <span class="c1"># after it acquires the lock.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">channel_ready</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">circuit_manager</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">clear</span><span class="p">(),</span>
                                          <span class="n">extra</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;pv&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">})</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="c1"># the socket is dead-dead, do nothing</span>
                <span class="o">...</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_idle</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="PV.read"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.PV.read">[docs]</a>    <span class="nd">@ensure_connected</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">timeout</span><span class="o">=</span><span class="n">PV_DEFAULT_TIMEOUT</span><span class="p">,</span>
             <span class="n">data_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">notify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Request a fresh reading.</span>

<span class="sd">        Can do one or both of:</span>
<span class="sd">        - Block while waiting for the response, and return it.</span>
<span class="sd">        - Pass the response to callback, with or without blocking.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wait : boolean</span>
<span class="sd">            If True (default) block until a matching response is</span>
<span class="sd">            received from the server. Raises CaprotoTimeoutError if that</span>
<span class="sd">            response is not received within the time specified by the `timeout`</span>
<span class="sd">            parameter.</span>
<span class="sd">        callback : callable or None</span>
<span class="sd">            Called with the response as its argument when received.</span>
<span class="sd">        timeout : number or None, optional</span>
<span class="sd">            Seconds to wait before a CaprotoTimeoutError is raised. Default is</span>
<span class="sd">            ``PV.timeout``, which falls back to ``PV.context.timeout`` if not</span>
<span class="sd">            set. If None, never timeout.</span>
<span class="sd">        data_type : {&#39;native&#39;, &#39;status&#39;, &#39;time&#39;, &#39;graphic&#39;, &#39;control&#39;} or ChannelType or int ID, optional</span>
<span class="sd">            Request specific data type or a class of data types, matched to the</span>
<span class="sd">            channel&#39;s native data type. Default is Channel&#39;s native data type.</span>
<span class="sd">        data_count : integer, optional</span>
<span class="sd">            Requested number of values. Default is the channel&#39;s native data</span>
<span class="sd">            count.</span>
<span class="sd">        notify: boolean, optional</span>
<span class="sd">            Send a ``ReadNotifyRequest`` instead of a ``ReadRequest``. True by</span>
<span class="sd">            default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="n">PV_DEFAULT_TIMEOUT</span><span class="p">:</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span>
        <span class="n">cm</span><span class="p">,</span> <span class="n">chan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit_manager</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_channel</span>
        <span class="n">ioid</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">_ioid_counter</span><span class="p">()</span>
        <span class="n">command</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">ioid</span><span class="o">=</span><span class="n">ioid</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">,</span>
                            <span class="n">data_count</span><span class="o">=</span><span class="n">data_count</span><span class="p">,</span> <span class="n">notify</span><span class="o">=</span><span class="n">notify</span><span class="p">)</span>
        <span class="c1"># Stash the ioid to match the response to the request.</span>

        <span class="n">event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="n">ioid_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">event</span><span class="o">=</span><span class="n">event</span><span class="p">,</span> <span class="n">pv</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="o">=</span><span class="n">command</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ioid_info</span><span class="p">[</span><span class="s1">&#39;callback&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">callback</span>

        <span class="n">cm</span><span class="o">.</span><span class="n">ioids</span><span class="p">[</span><span class="n">ioid</span><span class="p">]</span> <span class="o">=</span> <span class="n">ioid_info</span>

        <span class="n">deadline</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span> <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">ioid_info</span><span class="p">[</span><span class="s1">&#39;deadline&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deadline</span>
        <span class="n">cm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;pv&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">})</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">wait</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># The circuit_manager will put a reference to the response into</span>
        <span class="c1"># ioid_info and then set event.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">event</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">):</span>
            <span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">address</span>
            <span class="k">raise</span> <span class="n">CaprotoTimeoutError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Server at </span><span class="si">{</span><span class="n">host</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">port</span><span class="si">}</span><span class="s2"> did &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;not respond to attempt to read channel named &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> within </span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span><span class="si">:</span><span class="s2">.3</span><span class="si">}</span><span class="s2">-second timeout. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;The ioid of the expected response is </span><span class="si">{</span><span class="n">ioid</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">dead</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="c1"># This circuit has died sometime during this function call.</span>
            <span class="c1"># The exception raised here will be caught by</span>
            <span class="c1"># @ensure_connected, which will retry the function call a</span>
            <span class="c1"># in hopes of getting a working circuit until our `timeout` has</span>
            <span class="c1"># been used up.</span>
            <span class="k">raise</span> <span class="n">DeadCircuitError</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ioid_info</span><span class="p">[</span><span class="s1">&#39;response&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="PV.write"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.PV.write">[docs]</a>    <span class="nd">@ensure_connected</span>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">timeout</span><span class="o">=</span><span class="n">PV_DEFAULT_TIMEOUT</span><span class="p">,</span>
              <span class="n">notify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_count</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a new value. Optionally, request confirmation from the server.</span>

<span class="sd">        Can do one or both of:</span>
<span class="sd">        - Block while waiting for the response, and return it.</span>
<span class="sd">        - Pass the response to callback, with or without blocking.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : str, int, or float or any Iterable of these</span>
<span class="sd">            Value(s) to write.</span>
<span class="sd">        wait : boolean</span>
<span class="sd">            If True (default) block until a matching WriteNotifyResponse is</span>
<span class="sd">            received from the server. Raises CaprotoTimeoutError if that</span>
<span class="sd">            response is not received within the time specified by the `timeout`</span>
<span class="sd">            parameter.</span>
<span class="sd">        callback : callable or None</span>
<span class="sd">            Called with the WriteNotifyResponse as its argument when received.</span>
<span class="sd">        timeout : number or None, optional</span>
<span class="sd">            Seconds to wait before a CaprotoTimeoutError is raised. Default is</span>
<span class="sd">            ``PV.timeout``, which falls back to ``PV.context.timeout`` if not</span>
<span class="sd">            set. If None, never timeout.</span>
<span class="sd">        notify : boolean or None</span>
<span class="sd">            If None (default), set to True if wait=True or callback is set.</span>
<span class="sd">            Can be manually set to True or False. Will raise ValueError if set</span>
<span class="sd">            to False while wait=True or callback is set.</span>
<span class="sd">        data_type : {&#39;native&#39;, &#39;status&#39;, &#39;time&#39;, &#39;graphic&#39;, &#39;control&#39;} or ChannelType or int ID, optional</span>
<span class="sd">            Write specific data type or a class of data types, matched to the</span>
<span class="sd">            channel&#39;s native data type. Default is Channel&#39;s native data type.</span>
<span class="sd">        data_count : integer, optional</span>
<span class="sd">            Requested number of values. Default is the channel&#39;s native data</span>
<span class="sd">            count.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="n">PV_DEFAULT_TIMEOUT</span><span class="p">:</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span>
        <span class="n">cm</span><span class="p">,</span> <span class="n">chan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_circuit_manager</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_channel</span>
        <span class="k">if</span> <span class="n">notify</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">notify</span> <span class="o">=</span> <span class="p">(</span><span class="n">wait</span> <span class="ow">or</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">ioid</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">_ioid_counter</span><span class="p">()</span>
        <span class="n">command</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ioid</span><span class="o">=</span><span class="n">ioid</span><span class="p">,</span> <span class="n">notify</span><span class="o">=</span><span class="n">notify</span><span class="p">,</span>
                             <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">,</span> <span class="n">data_count</span><span class="o">=</span><span class="n">data_count</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">notify</span><span class="p">:</span>
            <span class="n">event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
            <span class="n">ioid_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">event</span><span class="o">=</span><span class="n">event</span><span class="p">,</span> <span class="n">pv</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="o">=</span><span class="n">command</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ioid_info</span><span class="p">[</span><span class="s1">&#39;callback&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">callback</span>

            <span class="n">cm</span><span class="o">.</span><span class="n">ioids</span><span class="p">[</span><span class="n">ioid</span><span class="p">]</span> <span class="o">=</span> <span class="n">ioid_info</span>

            <span class="n">deadline</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span> <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">ioid_info</span><span class="p">[</span><span class="s1">&#39;deadline&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deadline</span>
            <span class="c1"># do not need to lock this, locking happens in circuit command</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wait</span> <span class="ow">or</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CaprotoValueError</span><span class="p">(</span><span class="s2">&quot;Must set notify=True in order to use &quot;</span>
                                        <span class="s2">&quot;`wait` or `callback` because, without a &quot;</span>
                                        <span class="s2">&quot;notification of &#39;put-completion&#39; from the &quot;</span>
                                        <span class="s2">&quot;server, there is nothing to wait on or to &quot;</span>
                                        <span class="s2">&quot;trigger a callback.&quot;</span><span class="p">)</span>
        <span class="n">cm</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;pv&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">})</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">wait</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># The circuit_manager will put a reference to the response into</span>
        <span class="c1"># ioid_info and then set event.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">event</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">dead</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
                <span class="c1"># This circuit has died sometime during this function call.</span>
                <span class="c1"># The exception raised here will be caught by</span>
                <span class="c1"># @ensure_connected, which will retry the function call a</span>
                <span class="c1"># in hopes of getting a working circuit until our `timeout` has</span>
                <span class="c1"># been used up.</span>
                <span class="k">raise</span> <span class="n">DeadCircuitError</span><span class="p">()</span>
            <span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">address</span>
            <span class="k">raise</span> <span class="n">CaprotoTimeoutError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Server at </span><span class="si">{</span><span class="n">host</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">port</span><span class="si">}</span><span class="s2"> did &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;not respond to attempt to write to channel named &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> within </span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span><span class="si">:</span><span class="s2">.3</span><span class="si">}</span><span class="s2">-second timeout. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;The ioid of the expected response is </span><span class="si">{</span><span class="n">ioid</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ioid_info</span><span class="p">[</span><span class="s1">&#39;response&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="PV.subscribe"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.PV.subscribe">[docs]</a>    <span class="k">def</span> <span class="nf">subscribe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">low</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Start a new subscription to which user callback may be added.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_type : {&#39;native&#39;, &#39;status&#39;, &#39;time&#39;, &#39;graphic&#39;, &#39;control&#39;} or ChannelType or int ID, optional</span>
<span class="sd">            Request specific data type or a class of data types, matched to the</span>
<span class="sd">            channel&#39;s native data type. Default is Channel&#39;s native data type.</span>
<span class="sd">        data_count : integer, optional</span>
<span class="sd">            Requested number of values. Default is the channel&#39;s native data</span>
<span class="sd">            count.</span>
<span class="sd">        low, high, to : float, optional</span>
<span class="sd">            deprecated by Channel Access, not yet implemented by caproto</span>
<span class="sd">        mask :  SubscriptionType, optional</span>
<span class="sd">            Subscribe to selective updates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        subscription : Subscription</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Define a subscription.</span>

<span class="sd">        &gt;&gt;&gt; sub = pv.subscribe()</span>

<span class="sd">        Add a user callback. The subscription will be transparently activated</span>
<span class="sd">        (i.e. an ``EventAddRequest`` will be sent) when the first user callback</span>
<span class="sd">        is added.</span>

<span class="sd">        &gt;&gt;&gt; sub.add_callback(my_func)</span>

<span class="sd">        Multiple callbacks may be added to the same subscription.</span>

<span class="sd">        &gt;&gt;&gt; sub.add_callback(another_func)</span>

<span class="sd">        See the docstring for :class:`Subscription` for more.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># A Subscription is uniquely identified by the Signature created by its</span>
        <span class="c1"># args and kwargs.</span>
        <span class="n">bound</span> <span class="o">=</span> <span class="n">SUBSCRIBE_SIG</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">data_type</span><span class="p">,</span> <span class="n">data_count</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bound</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subscriptions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">Subscription</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">data_type</span><span class="p">,</span> <span class="n">data_count</span><span class="p">,</span>
                               <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subscriptions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub</span>
        <span class="c1"># The actual EPICS messages will not be sent until the user adds</span>
        <span class="c1"># callbacks via sub.add_callback(user_func).</span>
        <span class="k">return</span> <span class="n">sub</span></div>

<div class="viewcode-block" id="PV.unsubscribe_all"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.PV.unsubscribe_all">[docs]</a>    <span class="k">def</span> <span class="nf">unsubscribe_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Clear all subscriptions. (Remove all user callbacks from them.)&quot;</span>
        <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subscriptions</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">sub</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

<div class="viewcode-block" id="PV.time_since_last_heard"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.PV.time_since_last_heard">[docs]</a>    <span class="nd">@ensure_connected</span>
    <span class="k">def</span> <span class="nf">time_since_last_heard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">PV_DEFAULT_TIMEOUT</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Seconds since last message from the server that provides this channel.</span>

<span class="sd">        The time is reset to 0 whenever we receive a TCP message related to</span>
<span class="sd">        user activity *or* a Beacon. Servers are expected to send Beacons at</span>
<span class="sd">        regular intervals. If we do not receive either a Beacon or TCP message,</span>
<span class="sd">        we initiate an Echo over TCP, to which the server is expected to</span>
<span class="sd">        promptly respond.</span>

<span class="sd">        Therefore, the time reported here should not much exceed</span>
<span class="sd">        ``EPICS_CA_CONN_TMO`` (default 30 seconds unless overriden by that</span>
<span class="sd">        environment variable) if the server is healthy.</span>

<span class="sd">        If the server fails to send a Beacon on schedule *and* fails to reply to</span>
<span class="sd">        an Echo, the server is assumed dead. A warning is issued, and all PVs</span>
<span class="sd">        are disconnected to initiate a reconnection attempt.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timeout : number or None, optional</span>
<span class="sd">            Seconds to wait before a CaprotoTimeoutError is raised. Default is</span>
<span class="sd">            ``PV.timeout``, which falls back to ``PV.context.timeout`` if not</span>
<span class="sd">            set. If None, never timeout.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">address</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit_manager</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">address</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">broadcaster</span><span class="o">.</span><span class="n">time_since_last_heard</span><span class="p">()[</span><span class="n">address</span><span class="p">]</span></div></div>

    <span class="c1"># def __hash__(self):</span>
    <span class="c1">#     return id((self.context, self.circuit_manager, self.name))</span>


<span class="k">class</span> <span class="nc">CallbackHandler</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pv</span><span class="p">):</span>
        <span class="c1"># NOTE: not a WeakValueDictionary or WeakSet as PV is unhashable...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pv</span> <span class="o">=</span> <span class="n">pv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callback_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_call_values</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">add_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">run</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">removed</span><span class="p">(</span><span class="n">_</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_callback</span><span class="p">(</span><span class="n">cb_id</span><span class="p">)</span>  <span class="c1"># defined below inside the lock</span>

        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakMethod</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">removed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: strong reference to non-instance methods?</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">removed</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_lock</span><span class="p">:</span>
            <span class="n">cb_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callback_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_callback_id</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">[</span><span class="n">cb_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref</span>

        <span class="k">if</span> <span class="n">run</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_call_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_lock</span><span class="p">:</span>
                <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_call_values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cb_id</span>

    <span class="k">def</span> <span class="nf">remove_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a fast operation that submits jobs to the Context&#39;s</span>
<span class="sd">        ThreadPoolExecutor and then returns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_lock</span><span class="p">:</span>
            <span class="n">callbacks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_call_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cb_id</span><span class="p">,</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">callbacks</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">ref</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cb_id</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pv</span><span class="o">.</span><span class="n">circuit_manager</span><span class="o">.</span><span class="n">user_callback_executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                <span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_lock</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">remove_id</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">remove_id</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>


<div class="viewcode-block" id="Subscription"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.Subscription">[docs]</a><span class="k">class</span> <span class="nc">Subscription</span><span class="p">(</span><span class="n">CallbackHandler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents one subscription, specified by a PV and configurational parameters</span>

<span class="sd">    It may fan out to zero, one, or multiple user-registered callback</span>
<span class="sd">    functions.</span>

<span class="sd">    This object should never be instantiated directly by user code; rather</span>
<span class="sd">    it should be made by calling the ``subscribe()`` method on a ``PV`` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">data_count</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>
        <span class="c1"># Stash everything, but do not send any EPICS messages until the first</span>
        <span class="c1"># user callback is attached.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="o">=</span> <span class="n">data_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_count</span> <span class="o">=</span> <span class="n">data_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">low</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">high</span> <span class="o">=</span> <span class="n">high</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to</span> <span class="o">=</span> <span class="n">to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subscriptionid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">most_recent_response</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">needs_reactivation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># This is related to back-compat for user callbacks that have the old</span>
        <span class="c1"># signature, f(response).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wrapper_weakrefs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv</span><span class="o">.</span><span class="n">log</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;Subscription to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pv</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">subscriptionid</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

    <span class="k">def</span> <span class="nf">_subscribe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">PV_DEFAULT_TIMEOUT</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This is called automatically after the first callback is added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv</span><span class="o">.</span><span class="n">circuit_manager</span>
        <span class="k">if</span> <span class="n">cm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We are currently disconnected (perhaps have not yet connected).</span>
            <span class="c1"># When the PV connects, this subscription will be added.</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_lock</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">needs_reactivation</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We are (or very recently were) connected. In the rare event</span>
            <span class="c1"># where cm goes dead in the interim, subscription will be retried</span>
            <span class="c1"># by the activation loop.</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">context</span>
            <span class="k">with</span> <span class="n">ctx</span><span class="o">.</span><span class="n">subscriptions_lock</span><span class="p">:</span>
                <span class="n">ctx</span><span class="o">.</span><span class="n">subscriptions_to_activate</span><span class="p">[</span><span class="n">cm</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">activate_subscriptions_now</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

    <span class="nd">@ensure_connected</span>
    <span class="k">def</span> <span class="nf">compose_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">PV_DEFAULT_TIMEOUT</span><span class="p">):</span>
        <span class="s2">&quot;This is used by the Context to re-subscribe in bulk after dropping.&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">cm</span><span class="p">,</span> <span class="n">chan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv</span><span class="o">.</span><span class="n">_circuit_manager</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv</span><span class="o">.</span><span class="n">_channel</span>
            <span class="n">subscriptionid</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">_subscriptionid_counter</span><span class="p">()</span>
            <span class="n">command</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span>
                                     <span class="n">data_count</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_count</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">,</span>
                                     <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">high</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">,</span>
                                     <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
                                     <span class="n">subscriptionid</span><span class="o">=</span><span class="n">subscriptionid</span><span class="p">)</span>
            <span class="n">subscriptionid</span> <span class="o">=</span> <span class="n">command</span><span class="o">.</span><span class="n">subscriptionid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subscriptionid</span> <span class="o">=</span> <span class="n">subscriptionid</span>
        <span class="c1"># The circuit_manager needs to know the subscriptionid so that it can</span>
        <span class="c1"># route responses to this request.</span>
        <span class="n">cm</span><span class="o">.</span><span class="n">subscriptions</span><span class="p">[</span><span class="n">subscriptionid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">command</span>

<div class="viewcode-block" id="Subscription.clear"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.Subscription.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all callbacks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_lock</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cb_id</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_callback</span><span class="p">(</span><span class="n">cb_id</span><span class="p">)</span></div>
        <span class="c1"># Once self.callbacks is empty, self.remove_callback calls</span>
        <span class="c1"># self._unsubscribe for us.</span>

    <span class="k">def</span> <span class="nf">_unsubscribe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">PV_DEFAULT_TIMEOUT</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is automatically called if the number of callbacks goes to 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subscriptionid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Already unsubscribed.</span>
                <span class="k">return</span>
            <span class="n">subscriptionid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subscriptionid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subscriptionid</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">most_recent_response</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pv</span><span class="o">.</span><span class="n">circuit_manager</span><span class="o">.</span><span class="n">subscriptions</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">subscriptionid</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">chan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv</span><span class="o">.</span><span class="n">channel</span>
        <span class="k">if</span> <span class="n">chan</span> <span class="ow">and</span> <span class="n">chan</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">ca</span><span class="o">.</span><span class="n">CLIENT</span><span class="p">]</span> <span class="ow">is</span> <span class="n">ca</span><span class="o">.</span><span class="n">CONNECTED</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">command</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">unsubscribe</span><span class="p">(</span><span class="n">subscriptionid</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ca</span><span class="o">.</span><span class="n">CaprotoKeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pv</span><span class="o">.</span><span class="n">circuit_manager</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;pv&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv</span><span class="o">.</span><span class="n">name</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">):</span>
        <span class="c1"># TODO here i think we can decouple PV update rates and callback</span>
        <span class="c1"># handling rates, if desirable, to not bog down performance.</span>
        <span class="c1"># As implemented below, updates are blocking further messages from</span>
        <span class="c1"># the CA servers from processing. (-&gt; ThreadPool, etc.)</span>
        <span class="n">pv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pv</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2">: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pv</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">command</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">most_recent_response</span> <span class="o">=</span> <span class="n">command</span>

<div class="viewcode-block" id="Subscription.add_callback"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.Subscription.add_callback">[docs]</a>    <span class="k">def</span> <span class="nf">add_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a callback to receive responses.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            Expected signature: ``func(sub, response)``.</span>

<span class="sd">            The signature ``func(response)`` is also supported for</span>
<span class="sd">            backward-compatibility but will issue warnings. Support will be</span>
<span class="sd">            removed in a future release of caproto.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        token : int</span>
<span class="sd">            Integer token that can be passed to :meth:`remove_callback`.</span>

<span class="sd">        .. versionchanged:: 0.5.0</span>

<span class="sd">           Changed the expected signature of ``func`` from ``func(response)``</span>
<span class="sd">           to ``func(sub, response)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle func with signature func(response) for back-compat.</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">adapt_old_callback_signature</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__wrapper_weakrefs</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_lock</span><span class="p">:</span>
            <span class="n">was_empty</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span>
            <span class="n">cb_id</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="n">most_recent_response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">most_recent_response</span>
        <span class="k">if</span> <span class="n">was_empty</span><span class="p">:</span>
            <span class="c1"># This is the first callback. Set up a subscription, which</span>
            <span class="c1"># should elicit a response from the server soon giving the</span>
            <span class="c1"># current value to this func (and any other funcs added in the</span>
            <span class="c1"># mean time).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_subscribe</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This callback is piggy-backing onto an existing subscription.</span>
            <span class="c1"># Send it the most recent response, unless we are still waiting</span>
            <span class="c1"># for that first response from the server.</span>
            <span class="k">if</span> <span class="n">most_recent_response</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">most_recent_response</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span>
                        <span class="s2">&quot;Exception raised during processing most recent &quot;</span>
                        <span class="s2">&quot;response </span><span class="si">%r</span><span class="s2"> with new callback </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">most_recent_response</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cb_id</span></div>

<div class="viewcode-block" id="Subscription.remove_callback"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.Subscription.remove_callback">[docs]</a>    <span class="k">def</span> <span class="nf">remove_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove callback using token that was returned by :meth:`add_callback`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        token : integer</span>
<span class="sd">            Token returned by :meth:`add_callback`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_lock</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove_callback</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">:</span>
                <span class="c1"># Go dormant.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unsubscribe</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">most_recent_response</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">needs_reactivation</span> <span class="o">=</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">TimeoutError</span><span class="p">:</span>
            <span class="k">pass</span></div>


<div class="viewcode-block" id="Batch"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.Batch">[docs]</a><span class="k">class</span> <span class="nc">Batch</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Accumulate requests and then issue them all in batch.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    timeout : number or None</span>
<span class="sd">        Number of seconds to wait before ignoring late responses. Default</span>
<span class="sd">        is 2.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Read some PVs in batch and stash the readings in a dictionary as they</span>
<span class="sd">    come in.</span>

<span class="sd">    &gt;&gt;&gt; results = {}</span>
<span class="sd">    &gt;&gt;&gt; def stash_result(name, response):</span>
<span class="sd">    ...     results[name] = response.data</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; with Batch() as b:</span>
<span class="sd">    ...     for pv in pvs:</span>
<span class="sd">    ...         b.read(pv, functools.partial(stash_result, pv.name))</span>
<span class="sd">    ...     # The requests are sent upon exiting this &#39;with&#39; block.</span>
<span class="sd">    ...</span>

<span class="sd">    The ``results`` dictionary will be populated as responses come in.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_commands</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># map each circuit to commands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ioid_infos</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Batch.read"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.Batch.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_count</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Request a fresh reading as part of a batched request.</span>

<span class="sd">        Notice that, unlike :meth:`PV.read`, the callback is required. (There</span>
<span class="sd">        is no other way to get the result back from a batched read.)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pv : PV</span>
<span class="sd">        callback : callable</span>
<span class="sd">            Expected signature: ``f(response)``</span>
<span class="sd">        data_type : {&#39;native&#39;, &#39;status&#39;, &#39;time&#39;, &#39;graphic&#39;, &#39;control&#39;} or ChannelType or int ID, optional</span>
<span class="sd">            Request specific data type or a class of data types, matched to the</span>
<span class="sd">            channel&#39;s native data type. Default is Channel&#39;s native data type.</span>
<span class="sd">        data_count : integer, optional</span>
<span class="sd">            Requested number of values. Default is the channel&#39;s native data</span>
<span class="sd">            count.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ioid</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">circuit_manager</span><span class="o">.</span><span class="n">_ioid_counter</span><span class="p">()</span>
        <span class="n">command</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">ioid</span><span class="o">=</span><span class="n">ioid</span><span class="p">,</span>
                                  <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">,</span>
                                  <span class="n">data_count</span><span class="o">=</span><span class="n">data_count</span><span class="p">,</span>
                                  <span class="n">notify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_commands</span><span class="p">[</span><span class="n">pv</span><span class="o">.</span><span class="n">circuit_manager</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
        <span class="c1"># Stash the ioid to match the response to the request.</span>
        <span class="c1"># The request is used in the logging in __exit__. It is not needed</span>
        <span class="c1"># by the circuit.</span>
        <span class="n">ioid_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="n">pv</span><span class="o">=</span><span class="n">pv</span><span class="p">,</span> <span class="n">request</span><span class="o">=</span><span class="n">command</span><span class="p">)</span>
        <span class="n">pv</span><span class="o">.</span><span class="n">circuit_manager</span><span class="o">.</span><span class="n">ioids</span><span class="p">[</span><span class="n">ioid</span><span class="p">]</span> <span class="o">=</span> <span class="n">ioid_info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ioid_infos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ioid_info</span><span class="p">)</span></div>

<div class="viewcode-block" id="Batch.write"><a class="viewcode-back" href="../../../threading-client.html#caproto.threading.client.Batch.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_count</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write a new value as part of a batched request.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pv : PV</span>
<span class="sd">        data : str, int, or float or any Iterable of these</span>
<span class="sd">            Value(s) to write.</span>
<span class="sd">        callback : callable</span>
<span class="sd">            Expected signature: ``f(response)``</span>
<span class="sd">        data_type : {&#39;native&#39;, &#39;status&#39;, &#39;time&#39;, &#39;graphic&#39;, &#39;control&#39;} or ChannelType or int ID, optional</span>
<span class="sd">            Request specific data type or a class of data types, matched to the</span>
<span class="sd">            channel&#39;s native data type. Default is Channel&#39;s native data type.</span>
<span class="sd">        data_count : integer, optional</span>
<span class="sd">            Requested number of values. Default is the channel&#39;s native data</span>
<span class="sd">            count.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ioid</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">circuit_manager</span><span class="o">.</span><span class="n">_ioid_counter</span><span class="p">()</span>
        <span class="n">command</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                                   <span class="n">ioid</span><span class="o">=</span><span class="n">ioid</span><span class="p">,</span>
                                   <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">,</span>
                                   <span class="n">data_count</span><span class="o">=</span><span class="n">data_count</span><span class="p">,</span>
                                   <span class="n">notify</span><span class="o">=</span><span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_commands</span><span class="p">[</span><span class="n">pv</span><span class="o">.</span><span class="n">circuit_manager</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">callback</span><span class="p">:</span>
            <span class="c1"># Stash the ioid to match the response to the request.</span>
            <span class="c1"># The request is used in the logging in __exit__. It is not needed</span>
            <span class="c1"># by the circuit.</span>
            <span class="n">ioid_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="n">pv</span><span class="o">=</span><span class="n">pv</span><span class="p">,</span> <span class="n">request</span><span class="o">=</span><span class="n">command</span><span class="p">)</span>
            <span class="n">pv</span><span class="o">.</span><span class="n">circuit_manager</span><span class="o">.</span><span class="n">ioids</span><span class="p">[</span><span class="n">ioid</span><span class="p">]</span> <span class="o">=</span> <span class="n">ioid_info</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ioid_infos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ioid_info</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span>
        <span class="n">deadline</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span> <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">ioid_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ioid_infos</span><span class="p">:</span>
            <span class="n">ioid_info</span><span class="p">[</span><span class="s1">&#39;deadline&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deadline</span>
        <span class="k">for</span> <span class="n">circuit_manager</span><span class="p">,</span> <span class="n">commands</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_commands</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">circuit_manager</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="o">*</span><span class="n">commands</span><span class="p">)</span></div>


<span class="c1"># The signature of caproto._circuit.ClientChannel.subscribe, which is used to</span>
<span class="c1"># resolve the (args, kwargs) of a Subscription into a unique key.</span>
<span class="n">SUBSCRIBE_SIG</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">([</span>
    <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;data_type&#39;</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span>
    <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;data_count&#39;</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span>
    <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;high&#39;</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;to&#39;</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;mask&#39;</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)])</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017, Daniel Allan

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>